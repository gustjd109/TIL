# 웹소켓(WebSocket) & Socket.io

## 1. 웹소켓 소개
1. 웹소켓이란?
    - HTML5 웹 표준 기술이다.
        - 표준 기술이기 때문에 추가적인 라이브러리 설치 없이 사용할 수 있으나, 오래된 버전의 웹 브라우저는 이 기술을 지원하지 않는다.
    - 매우 빠르게 작동하며 통신할 때 아주 적은 데이터를 이용한다.
    - 이벤트를 단순히 듣고, 보내는 것만 가능하다.
    - 하나의 TCP 컨넥션으로 서버와 클라이언트 간에 양방향 통신을 할 수 있게 만든 프로토콜이다.
        - 양방향 통신을 지원하므로 브라우저 상에서 리프레시 없이 실시간성을 요구하는 애플리케이션을 구현할 수 있다.<br><br>
    - 이전에는 폴링 또는 롱폴링이라는 방법을 사용했다.
        - 폴링 : 클라이언트가 주기적으로 서버로 요청을 보내는 방식
        - 롱폴링 : 클라이언트가 요청을 보내고 서버에서 응답이 올 때까지 대기 후, 응답이 오면 바로 다시 요청을 보내는 방식<br><br>
2. 웹소켓 특징
    - 양방향 통신
        - 데이터의 송수신을 동시에 처리한다는 뜻이며, 클라이언트와 서버가 원하는 때 데이터를 주고받을 수 있다는 의미다.<br><br>
    - 실시간 네트워킹을 구현하는 것이 용이
        - 웹 환경에서 연속된 데이터를 빠르게 노출하고 싶은 때, 예를 들어 채팅이나 주식 앱에 적합하다.
        - 브로드캐스팅을 지원하므로 여러 클라이언트와 빠르게 데이터를 교환할 수 있어 편리하다.<br><br>
3. 웹소켓의 동작 방법
    - 웹소켓 포로토콜은 크게 핸드 쉐이크와 데이터 전송으로 나눌 수 있다.<br><br>
    - 웹소켓 프로토콜 동작 과정
        - 1단계
            - HTTP 핸드쉐이크를 수행해 연결을 맺는다.
                - 핸드 쉐이크
                    - 서버와 클라이언트가 커넥션을 맺는 과정으로써 최초 한 번만 일어난다.
                    - 이때는 HTTP 1.1 프로토콜을 사용하고, 헤더에 Upgrade: Websocket Connection: Upgrade를 추가해서 웹소켓 프로토콜을 사용하도록 해준다.<br><br>
            - 클라이언트가 다음과 같은 데이터를 서버로 보낸다.
                ```js
                GET /chat HTTP/1.1                          // 1. HTTP 1.1 이상
                Host: server.example.com
                Upgrade: websocket                          // 2. 현재 프로토콜에서 다른 프로토콜로 업그레이드하는 규칙
                Connection: Upgrade                         // 3. Upgrade 필도가 있으면 반드시 같이 명시
                Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== // 클라이언트 키
                Origin: http://example.com                  // 필수 항목. 클라이언트 주소
                Sec-WebSocket-Protocol: chat, superchat
                // 4. 클라이언트가 요청하는 하위 프로토콜
                Sec-WebSocket-Version: 13
                ```
                - 핸드쉐이킹은 GET으로 보내야 하며 HTTP 1.1 이상이 필수이다.
                - Upgrade 필드는 HTTP 프로토콜에서 웹소켓 프로토콜로 변경에 필요한 값이다.
                    - 프로토콜을 업그레이드하려면 반드시 명시해야 한다.
                - Upgrade 필드가 있으면 반드시 같이 명시해야 하며, 없으면 연결이 되지 않는다.
                - Sec-WebSocket-Protocol은 클라이언트가 요청하는 하위 프로토콜이다.
                    - 순서에 따라서 우선순위를 부여하며, 서버에서 여러 프로토콜이나 프로토콜 버전을 나눠서 서비스할 때 필요한 정보이다.<br><br>
            - 그러면 서버는 핸드쉐이크의 응답으로 다음과 같은 데이터를 보내준다.
                ```js
                HTTP/1.1 101 Switching Protocols // 1. 연결 성공
                    Upgrade: websocket
                    Connection: Upgrade
                    // 2. 클라이언트로부터 받은 키를 사용해 계산된 값
                    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+Oo=
                    Sec-WebSocket-Protocol: chat
                ```
                - 101 Switching Protocols로 응답이 오면 웹소켓 프로토콜로 전환해 연결이 잘된다는 것을 의미한다.
                    - 이제부터는 양방향 송수신을 할 수 있다.
                - Sec-WebSocket-Accept는 클라이언트로부터 받은 키를 사용해 계산한 값이다.
                    - 해당 값은 클라이언트와 서버 간 인증에 사용된다.<br><br>
        - 2단계
            - 핸드쉐이크가 완료되면 프로토콜이 HTTP에서 ws로, HTTPS라면 wss로 변경되어 데이터를 전송할 수 있는 2단계로 접어든다.
                - 데이터는 메시지라 부르며, 메시지는 프레임의 모음이다.
                    - 프레임
                        - 바이트의 배열이며, 헤더와 페이로드로 이루어져 있다.
                        - 헤더는 FIN, RSV1~3, 오프코드, 마스크, 페이로드 길이, 마스킹 키가 있다.<br><br>
        - 3단계
            - 접속을 끊는다.
                - 접속은 클라이언트와 서버 양쪽에서 모두 끊을 수 있으며, 오프코드에 1000을 담아서 보내면 된다.<br><br>
    - 웹소켓은 데이터를 전송하는 것만 지원할 뿐 전송되는 데이터를 가지고 무엇을 할지는 개발자의 몫이다.
        - 예를들어 채팅 애플리케이션을 만들고자 할 때 채팅방 만들기, 채팅방에 들어온 사람들 전체에게 메시지 발송하기, 접속이 끊어진 경우 자동으로 다시 연결하기 등의 기능을 구현하고자 한다면 이런 부분은 개발자가 모두 만들어줘야 한다.
        - socket.io를 사용하면 추가로 이런 부분들을 지원해주므로 웹소켓보다는 코드 작성의 부담이 적다.

## 2. socket.io
1. socket.io란?
    - 웹소켓을 기반으로 서버와 클라이언트의 양방향 통신을 지원하는 라이브러리이며 표준 기술이 아니다.
        - 라이브러리기 때문에 사용을 위해 추가 설치가 필요하다.
    - 기본적으로 웹소켓을 지원한다.
    - 웹소켓을 지원하지 않는 브라우저에서는 롱폴링 방식을 사용한 통신을 지원한다.
    - 소켓 연결 실패 시 fallback을 통해 다른 방식으로 알아서 해당 클라이언트와 연결을 시도한다.
    - 재접속, 브로드캐스팅, 멀티플렉싱(채팅방) 기능을 제공하기 때문에 WebSocket을 사용할 때 처럼 재연결, 승인, 방 개념을 이용해 일부 클라이언트에게만 데이터를 전송하는 브로드캐스팅 등과 같은 기능을 직접 구현할 필요가 없다.<br><br>
2. 메소드
    - 이벤트 수신(서버와 클라이언트 공통)
        - socket.on('받은 이벤트명', 이벤트 핸들러 함수)
        - socket.on은 해당 클라이언트의 특정 이벤트를 수신할 때 주로 사용한다.
    - 이벤트 송신(서버와 클라이언트 공통)
        - socket.emit('보낼 이벤트명', 이벤트 핸들러 함수)
        - socket.emit은 해당 클라이언트의 특정 이벤트를 송신할 때 주로 사용한다.
            - 지목된 클라이언트를 제외한 모든 클라이언트에게 전송(서버)
                - socket.broadcast.emit('보낼 이벤트명', 이벤트 헨들러 함수)
            - 특정 클라이언트에게만 전송(서버)
                - io.to(clientID).emit('보낼 이벤트명', 이벤트 헨들러 함수)
    - NameSpace
        - 서로 다른 엔드포인트, path를 할당할 때 사용한다.
        - Default Namespace는 / 을 사용한다.
    - Room
        - 네임스페이스 안에 특정한 채널을 구현한다
        - 말 그대로 채팅방이라 생각하면 되고, Join과 Leave를 활용하여 Room을 왔다갔다 할 수 있다.
        - ROOM은 백엔드에서 관리한다.
    - Join
        - socket.join()
        - 특정 룸에 접속할 때 사용한다.
    - Leave
        - socket.leave()
        - 특정 룸에 퇴장할 때 사용한다.

## 3. WebSocket VS Socket.io
1. WebSocket VS Socket.io
    - 그렇다면 우리에게 정말 중요한 것은 대체 언제 WebSocket을 사용하고, 언제 Socket.io를 사용해야할 지 기준을 정해야 하는 것이다.
    - 서버에서 연결된 소켓(사용자)들을 세밀하게 관리해야 하는 서비스인 경우에는 브로드캐스팅 기능이 있는 Socket.io을 쓰는게 유지보수 측면에서 훨씬 이점이 많다.
    - 가상화폐 거래소같이 데이터 전송이 많은 경우에는 빠르고 비용이 적은 표준 WebSocket을 이용하는게 바람직하다.