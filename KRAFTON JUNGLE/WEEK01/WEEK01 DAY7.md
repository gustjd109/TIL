# WEEK01 DAY7 TIL

## 1. 1주차 알고리즘 테스트
오늘은 1주차의 마지막 날인 1주차 알고리즘 테스트를 보는 날이다.  
저번 주 목요일부터 오늘까지 일주일간 새벽 3시 이후까지 잠도 안자고(못잔거다...😭) 백준 사이트에서 주어진 문제를 열심히 풀었다. 좋은 결과가 있었으면 좋았지만, 결과적으로는 1솔밖에 하지 못했다.

문제는 총 3문제로 1시간 30분 동안 1101번(더하기 사이클 : 수학, 구현 관련) / 9095번(1, 2, 3 더하기 : 재귀 관련) / 1182번(부분 수열의 함 : 브루트 포스 관련) 문제를 해결하는 것이었다.

1101번 문제는 빠르게 풀었지만, 2번 문제는 규칙을 찾지 못했고 3번 문제는 DFS와 재귀함수를 이용하여 문제를 풀던 중 시험이 종료되었다.  

## 2. 1주차 알고리즘 테스트 재도전!🔥
- 점화식을 이용한 9095번 문제 풀이 과정
    - 문제를 풀기 전에 식의 규칙을 찾기 위해 정수 N이 주어질 때 각각 1, 2, 3으로 만들어지는 방법이 몇 개 있는지 찾아보았다.
    - 의외로 빠르게 규칙을 찾을 수 있었고, N = 1 -> 1개 / N = 2 -> 2개 / N = 3 -> 4개 / N = 4 -> 7개씩 방법이 나온다.
    - 위의 계산값을 보고 규칙을 식으로 표현하면, f(N) = f(N - 1) + f(N - 2) + f(N - 3)가 된다.
    - 이 식을 이용하면 문제를 쉽게 풀 수 있고, 아래는 내가 구현한 코드이다.
    ```python
    import sys

    def recursive(N):
        if N == 1: return 1
        elif N == 2: return 2
        elif N == 3: return 4
        else: 
        return recursive(N - 1) + recursive(N - 2) + recursive(N - 3)

    T = int(sys.stdin.readline())

    for _ in range(T):
        print(recursive(int(sys.stdin.readline())))
    ```

- DFS와 재귀함수를 이용한 9095번 문제 풀이 과정  
    2주차 같은 조원인 박유빈 님의 DFS와 재귀함수를 이용한 풀이 방법에 관해서도 설명을 듣고 직접 다시 구현해 보았다.  
    - N = 4일 때, DFS함수 매개변수로 4가 들어가서 3과 나누어지는지 검사한다.
    - 나누어지기 때문에 함수를 재귀호출하고, 매개변수로 N - 3인 1을 전달한다. 3을 이용했기 때문에 1, 2, 3중에서 1을 더해야만 4가 되기 때문이다.
    - 1은 3과 2로 나누어지지 않고, 1로만 나누어지기 때문에 다시 재귀호출을 통해 0을 매개변수로 전달한다.
    - 0은 어느 것으로도 나눌 수 없으며, 함수 처음 부분의 N == 0 조건을 만족하여 카운트 값을 1 더해준다.
    - 위의 과정을 계속 반복하면 정수 N의 1, 2, 3의 합으로 만들어지는 모든 방법의 수를 구할 수 있다.
    ```python
    import sys

    def DFS(N):
        global cnt

        if N == 0:
            cnt += 1
            return
    
        if N // 3: DFS(N - 3)
        if N // 2: DFS(N - 2)
        if N // 1: DFS(N - 1)

    T = int(sys.stdin.readline())

    for _ in range(T):
    cnt = 0
    DFS(int(sys.stdin.readline()))
    print(cnt)
    ```

- DFS와 재귀함수를 이용한 1182번 문제 풀이 과정
세 번째 문제는 내가 풀던 방법으로 해결하는 것이 맞았고, 부분 수열 개념을 정확하게 알지 못하여 헤매었던 것 같다. 결국, 중복을 제외한 모든 경우의 수를 탐색하면 되는 문제였다.
    - 해당 문제를 풀기 위해 부분 수열이라는 것이 무엇인지 확인해보자.
    - 부분 수열이란 해당 수열에 있는 수들의 모든 조합을 말한다.
    - 예를 들어, [1, 2, 1, 3, 5, 6] 수열이 있다고 하자
    - [2, 1, 3]처럼 수들이 연속된 경우와 [1, 1, 3]처럼 불연속적으로 선택된 수들도 부분 수열이다.
    - 다만, 아무것도 선택하지 않는 경우는 제외된다.
    - 즉, 이 문제는 중복을 허용하지 않고 원소를 더한 값이 S가 되는 모든 경우의 수를 구하는 문제이다.
    ```python
    import sys

    def solve(start):
        global cnt
        # len(Tmp_Arr) > 0 : 부분수열 조건으로 아무것도 선택하지 않은 경우를 제외
        if sum(Tmp_Arr) == S and len(Tmp_Arr) > 0:
            cnt += 1
    
        for i in range(start, N):
            Tmp_Arr.append(N_List[i])
            # 중복을 허용하지 않기 위해 인덱스에 i + 1을 전달
            solve(i + 1)
            Tmp_Arr.pop()

    N, S = map(int, sys.stdin.readline().split())
    N_List = list(map(int, sys.stdin.readline().split()))
    Tmp_Arr = []
    cnt = 0
    solve(0)
    print(cnt)
    ```
    - 문제를 해결하던 중 발생한 문제가 하나 있다.
        - UnboundLocalError: cannot access local variable 'cnt' where it is not associated with a value라는 에러가 발생했다.
        - 해당 에러는 파이썬에서 전역 변수의 데이터를 확인할 수는 있지만, 수정할 수는 없으므로 전역 변수를 수정하고 싶은 경우 global로 정의를 해줘야 한다.

## 3. 이진 탐색(Binary Search)
- 이진 탐색이란?
    - 정렬된 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
    - 배열의 데이터가 정렬되어 있어야 효과적으로 사용 가능
    - 선형 검색보다 빠르게 검색할 수 있는 장점이 있음

- 이진 탐색 과정
    - 정렬된 배열인 a = [5, 7, 15, 28, 29, 31, 39, 58, 68, 70, 95]가 있다고 가정
        - 이진 검색에서는 먼저 배열의 중앙에 있는 원소 a[5]인 31에 주목
        - 찾아야 할 값인 39는 중앙 원소인 31보다 뒤쪽에 존재
        - 검색 대상이 a[6] ~ a[10]로 좁혀짐
        - 업데이트된 검색 대상 범위의 중앙 원소인 a[8]인 68에 주목
        - 39는 중앙 원소인 68보다 앞쪽에 존재
        - 검색 대상이 a[6] ~ a[7]로 좁혀짐
        - 다시 업데이트된 중앙 검색 대상 범위의 중앙 원소인 a[6]인 39에 주목
        - 찾아야 할 값인 39와 일치하므로 검색 종료
    - 검색 범위의 맨 앞, 맨 끝, 중앙의 인덱스를 각각 pl, pr, pc라고 함
    - 검색을 시작할 때, pl은 0, pr은 (n - 1), pc는 (n - 1) // 2로 초기화 함
    - 이진 검색을 한 단계씩 진행할 때마다 검색 범위는 거의 반으로 좁혀짐
    - 위의 예처럼 a[pc]와 key(찾아야 할 값)를 비교하여 검색에 성공할 수도 있지만, 찾지 못하면 다음과 같은 방법으로 검색 범위를 좁힐 수 있음
    - 이진 검색에서 범위를 좁히는 과정
        - a[pc] < key일 때 : 
            - 중앙(pc)에서 오른쪽으로 한 칸 이동하여 새로운 왼쪽 끝 pl로 지정하고, 검색 범위를 뒤쪽 절반으로 좁힌다.
        - a[pc] > key일 때 : 
            - 중앙(pc)에서 왼쪽으로 한 칸 이동하여 새로운 오른쪽 끝 pr로 지정하고, 검색 범위를 앞쪽 절반으로 좁힌다.
    - 이진 검색의 종료 조건
        - a[pc]와 key가 일치하는 경우
        - 검색 범위가 더 이상 없는 경우

- 이진 탐색의 시간 복잡도
    - 이진 탐색은 한 번 확인할 때마다 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 시간 복잡도가 O(log N)이다.
    - 절반씩 데이터를 줄어들도록 만든다는 점에서 퀵 정렬과 공통점이 있다.

- 이진 탐색 구현
    - 2가지 방법이 있으며, 재귀 함수를 이용하는 방법과 반복문을 이용하는 방법이 있다.
        - 재귀함수를 이용한 구현
            ```python
            import sys

            def binary_search(array, target, start, end):
	            # 시작점이 끝점보다 커질 경우 검색할 범위가 더 이상 없음으로 검색 실패
	            if start > end:
		            return None

	            mid = (start + end) // 2

	            # 찾은 경우 중간점 인덱스 반환
	            if array[mid] == target:
		            return mid

	            # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
	            elif array[mid] > target:
		            return binary_search(array, target, start, mid - 1)

	            # 중간점의 값보다 찾고자 하는 값이 작은 경우 오른쪽 확인
	            else:
		            return binary_search(array, target, mid + 1, end)

            # n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기
            n, target = list(map(int, sys.stdin.readline().split()))
            # 전체 원소 입력받기
            array = list(map(int, sys.stdin.readline().split()))

            # 이진 탐색 수행 결과 출력
            result = binary_search(array, target, 0, n - 1)
            if result == None:
	            print("원소가 존재하지 않습니다.")
            else:
	            print(result + 1)
        
            ```

        - 반복문을 이용한 구현
            ```python
            import sys

            def binary_search(array, target, start, end):
                while start <= end:
                    mid = (start + end) // 2

                    # 찾은 경우 중간점 인덱스 반환
                    if array[mid]  == target:
                        return mid
            
                    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
                    elif array[mid] > target:
                        end = mid - 1

                    # 중간점의 값보다 찾고자 하는 값이 작은 경우 오른쪽 확인
                    else:
                        start = mid + 1
                return None

            # n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기
            n, target = list(map(int, sys.stdin.readline().split()))
            # 전체 원소 입력받기
            array = list(map(int, sys.stdin.readline().split()))

            # 이진 탐색 수행 결과 출력
            result = binary_search(array, target, 0, n - 1)
            if result == None:
	            print("원소가 존재하지 않습니다.")
            else:
	            print(result + 1)
            ```

- 코딩 테스트에서의 이진 탐색
    - 이진 탐색은 코딩 테스트에서 단골로 나오는 문제이니 많은 연습이 필요하다.
    - 탐색 범위가 2,000만이 넘어가면 이진 탐색으로 문제에 접근해보는 것이 좋다.
    - 처리해야 할 데이터의 개수나 값이 1,000만 단위 이상으로 넘어가면 이진 탐색과 같이 O(log N)의 속도를 내야 하는 알고리즘을 떠올려야 문제를 풀 수 있는 경우가 많다.

- 파이썬 이진 탐색 라이브러리
    - bisect라는 이진 탐색 라이브러리(모듈)를 지원
        - bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메소드
        - bisect_right(a, x) : 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메소드
        ```python
        from bisect import bisect_left, bisect_right
        a = [1, 2, 4, 4, 8]
        x = 4

        print(bisect_left(a, x))
        >>> 2
        # 리스트 a에 4를 삽입할 가장 왼쪽 인덱스는 2이다.

        print(bisect_right(a, x))
        >>> 4
        # 리스트 a에 4를 삽입할 가장 오른쪽 인덱스는 4이다.
        ```

## 4. 1주차를 마치며...
이번 시험을 통해 몇 가지 나의 부족한 점을 확인할 수 있었다.  
첫 번째는 시간이라는 제한이 있다 보니 쫓끼면서 허둥지둥하면서 푸는 습관이다.  

두 번째는 문제를 좀 더 꼼꼼히 읽지 않는다는 것이다. 문제를 꼼꼼하게 확인하지 않고 바로 코드를 작성하니 구현이 제대로 될리 있나… 문제 안에 많은 조건, 힌트, 개념 등이 있는데 확실하게 읽고 정리해야 문제를 풀 수 있다. 또한, 오늘 원장님과 코치님께서 말씀해주신 것처럼 정말 몇십 년을 관련 공부를 해오신 대단한 분들이 몇 개월 또는 몇 년동안 고민해서 만든 알고리즘과 문제인데 그렇게 쉽게 읽고 풀 수 있는 문제가 아니라는 것이다.  

세 번째는 규칙을 찾기 위한 시도를 여러 방법으로 시도해보지 않는다는 것이다. 규칙을 찾기 위해 꼭 직접 수를 대입하여 노가다도 해봐야 한다.  

2주차부터는 공부하는 방법을 조금 바꿔보려고 한다.
- 허둥지둥 풀지 말고 문제 꼼꼼하게 읽고, 조건 등을 확실하게 숙지하자.
- 규칙을 찾기 위한 시도를 다양하게 해보자.
- 남들이 푼 풀이 방법을 다양하게 접해보고 생각하는 시야를 넓히자.
- 문제를 풀기 전에 항상 관련 개념을 먼저 공부하고 난 후에 문제를 풀어보자.  

시험이 종료되고 다른 분들의 문제 풀이 발표를 통해 하나의 문제를 여러 방법과 접근 방법이 있다는 것을 알게 되는 좋은 시간이 되었다.  

2주차도 화이팅!💪