# WEEK04 DAY5 TIL
오늘은 오전에 컴퓨터 시스템 1장의 남은 내용을 모두 읽었다. 다는 정리하지 못했고, 먼저 정리한 부분까지만 깃허브에 올렸다.
추가로 그리디 알고리즘 1931번 회의실 배정, 1946번 신입사원, 1700번 멀티탭 스케줄링 문제까지 풀었다.

## 1. 1931번 회의실 배정 문제 풀이
- 처음에 회의 시작 시간이 가장 빠른 것을 기준으로 정렬 후, 모든 회의에 대해서 탐색하면서 배열 하나에 회의 참가 횟수를 저장하여 마지막에 최대 값을 반환하는 방법을 통해 풀었지만 시간초과로 틀렸다.
- 이 문제는 빠르게 끝나는 회의일수록 더 많은 회의가 진행될 수 있으므로, 회의가 끝나는 시간이 빠른 것부터 우선적으로 오름차순 정렬을 해줘야 한다.
- 다음으로 그 안에서 회의가 끝나는 시간과 다음 회의가 시작하는 시간이 가까울수록 더 많은 회의를 진행할 수 있으므로, 회의 시작 시간이 빠른 것부터 다시 오름차순으로 정렬해 준다.
- 정렬된 회의들 중에서 첫 번째 회의부터 시작해서 마지막 회의까지 탐색하면서 회의실을 사용한 회의 개수를 증가시켜 준다.
- 마지막으로 회의 개수를 반환시켜 주면 된다.
- 정렬할 때는 lambda 함수를 이용하면 편하다.
- 소스코드
    ```python
    import sys

    def greedy():
        # 처음 회의는 회의실을 사용한 것으로 간주하고 회의실을 사용한 회의 개수 1로 초기화
        cnt = 1
        # 회의 종료 시간을 처음 회의실을 사용한 회의의 종료 시간으로 설정
        end = meetings[0][1]
        # 처음 회의는 회의실을 사용했으므로 다음 회의부터 탐색 시작
        for i in range(1, N):
            # 만약, i번째 회의의 시작 시간이 마지막으로 회의실을 사용한 회의의 종료 시간보다 같거나 크면
            if meetings[i][0] >= end:
                # 회의실을 사용한 회의 개수 1증가
                cnt += 1
                # 회의 종료 시간을 i번째 회의의 종료 시간으로 갱신
                end = meetings[i][1]
        print(cnt)

    if __name__ == "__main__":
        # 회의 개수 입력
        N = int(sys.stdin.readline())
        # 회의의 시작 시간과 끝나는 시간 입력
        meetings = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
        # 종료 시간을 기준으로 오름차순 정렬
        # 다음으로 그 안에서 시작 시간을 기준으로 오름차순 정렬
        meetings.sort(key=lambda x: (x[1], x[0]))
        greedy()
    ```

## 2. 1946번 신입사원 문제 풀이
- 처음 이 문제를 보고 입력된 값이 순위가 아닌 점수로 착각해서 문제를 풀고 있었다. 다시 한번 문제를 제대로 잘 읽어야 하는 중요성을 느꼈다.
- 이 문제를 해결하기 위해서는 먼저 서류심사 성적을 기준으로 오름차순 정렬을 해줘야 한다.
- 뒤에 정렬된 사람이 앞에 정렬된 사람보다 서류심사 성적이 무조건 낮으므로 면접 성적을 기준으로 채용할지를 정할 수 있기 때문이다.
- 즉, 앞사람들 중 면접 등수가 높은 사람이 있다면 합격, 면접 등수가 낮은 사람이 있다면 탈락시키면 된다.
- 따라서 min값을 잡은 후 그 min값보다 낮은 등수의 사람은 탈락, min값보다 높은 등수의 사람은 합격시키면 된다.
- 소스코드
    ```python
    import sys

    def greedy():
        # 제일 처음 지원자는 서류 순위가 1등이므로 무조건 채용하기 때문에 결과값 1로 초기화
        result = 1
        # 현재 지원자의 면접 순위를 비교할 지원자 면접 순위
        min = applicant_list[0][1]
        # 지원자 수만큼 반복문 수행
        for i in range(1, N):
            # 현재 지원자의 면접 순위가 이전 지원자의 면접 순위보다 높으면 채용이므로 결과값 1증차
            if applicant_list[i][1] < min:
                result += 1
                # 현재 지원자의 면접 순위를 비교할 지원자 면접 순위 갱신(더 이전 지원자의 면접 순위와는 비교할 필요가 없음)
                min = applicant_list[i][1]
        # 결과값 출력
        print(result)

    if __name__ == "__main__":
        sys.stdin = open("input.txt","rt")
        # 테스트 케이스 입력
        T = int(sys.stdin.readline())
        # 테스트 케이스만큼 반복문 수행
        for _ in range(T):
            # 지원자 수 입력
            N = int(sys.stdin.readline())
            # 지원자 서류, 면접 순위 입력
            applicant_list = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
            # 지원자 서류 순위를 기준으로 오름차순 정렬
            applicant_list.sort(key=lambda x: x[0])
            # 그리디 알고리즘 수행
            greedy()
    ```

## 3. 1700번 멀티탭 스케줄링 문제 풀이
- 이 문제는 너무 어려워서 결국 풀이를 보고 풀었다.
- 총 세 가지의 경우를 고려하고 풀어야 한다.
    - 멀티탭에 꽂을 전기용품이 이미 꽂혀있는 경우 -> 그냥 패스하면 된다.
    - 멀티탭에 꽂을 수 있는 공간이 있는 경우 -> 꽂을 수 있는 공간이 있으므로 꽂고자 하는 전기용품을 꽂는다.
    - 멀티탭에 꽂을 공간이 없는 경우 -> 이 경우가 까다롭다.
        - 우선, 멀티탭에 꽂혀 있는 플러그 중에서 다음에 꽂아야 하는 플러그 리스트에 있는지 확인한다.
            - 만약, 존재한다면
                - 다음에 꽂아야 하는 플러그의 순서를 인덱스를 통해 확인하고 인덱스의 위치 값을 가져온다.
                - 인덱스 값을 다음에 꽂아야 하는 플러그 리스트에 추가해 준다.
            - 존재하지 않는다면
                - 멀티탭에 꽂혀 있는 플러그가 다음에 꽂아야 하는 플러그 중에 없으면 플러그 사용순서의 최대 범위 +1을 인덱스 값에 삽입해 준다.
                - 인덱스 값인 101을 다음에 꽂아야 하는 플러그 리스트에 추가하여 플러그를 최우선으로 선택할 수 있게 한다.
                - 101을 주는 이유는 K의 범위가 100 이하이므로 사용되지 않는 전기용품을 다음에 가장 먼저 뽑힐 수 있도록 하기 위함이다.
        - 나중에 꽂아야 하는 플러그를 선택한다.
        - 멀티탭에서 선택한 플러그를 삭제하고 다음 전기용품을 꽂는다.
        - 플러그를 한번 뽑았으므로 카운트 수를 1 증가시켜 준다.
- 소스코드
    ```python
    import sys

    def greedy():
        global cnt

        for i in range(K):
            # 1. 멀티탭에 i번째 전기용품이 이미 꽂혀있을 경우 패스
            if elec_equips[i] in multitap:
                continue
        
            # 2. 멀티탭에 빈 구멍이 있을 경우 빈 공간에 전기용품을 꽂음
            if len(multitap) < N:
                multitap.append(elec_equips[i])
                continue

            # 나중에 꽂아야하는 플러그
            priority = []
            # 3. 멀티탭에 빈 공간이 없는 경우
            for j in multitap:
                # 멀티탭에 꽂혀 있는 플러그가 다음에 꽂아야하는 플러그 중에 있는지 확인
                if j in elec_equips[i:]:
                    # 다음에 꽂아야하는 플러그의 순서를 인덱스를 통해 확인하고 인덱스의 위치 값을 가져옴
                    # 인덱스 값을 다음에 꽂아야하는 플러그 리스트에 추가
                    priority.append(elec_equips[i:].index(j))
                else:
                    # 멀티탭에 꽂혀 있는 플러그가 다음에 꽂아야하는 플러그중에 없으면 플러그 사용순서의 최대 범위 +1을 인덱스 값에 삽입
                    # 인덱스 값인 101을 다음에 꽂아야하는 플러그 리스트에 추가하여 플러그를 최우선으로 선택
                    priority.append(101)

            # 나중에 꽂아야하는 플러그 선택
            target = priority.index(max(priority))
            # 멀티탭에서 나중에 꽂아야하는 플러그 삭제
            multitap.remove(multitap[target])
            # 멀티탭에 i번째 전기용품 추가
            multitap.append(elec_equips[i])
            # 카운트 1증가
            cnt += 1
        
        print(cnt)

    if __name__ == "__main__":
        sys.stdin = open("input.txt","rt")
        # 멀티탭 구멍의 개수, 전기 용품의 총 사용횟수 입력
        N, K = map(int, sys.stdin.readline().split())
        # 전기용품 사용 순서대로 입력
        elec_equips = list(map(int, sys.stdin.readline().split()))
        # 플러그를 뺀 횟수 0으로 초기화
        cnt = 0
        # 전기용품을 꽂기 위한 멀티탭 리스트 생성
        multitap = []
        greedy()
        ```

## 4. 4주차 5일차를 마치며...
컴퓨터 시스템 책 1장을 겨우 읽었다. 분명 한글인데도 이해가 안 가는 글들이 너무 많아서 엄청 여러 번 억지로 이해하려고 해야지 겨우 읽힌다(진짜 거의 수면제🥱). 인프런이라는 사이트에서 컴퓨터 구조와 운영체제에 대한 무료 강의가 있는데 같이 들으면서 필요한 부분들을 공부하고, 괜찮으면 책을 하나 사서 보는 것도 괜찮을 것 같다.

오늘 풀었던 문제 중에서 1700번 멀티탭 스케줄링 문제가 가장 어려웠는데 결국에는 다른 분이 푼 풀이를 보고 해결했다... 그리디 알고리즘도 접근 방법은 생각이 나도 막상 풀 때 구현해야 하는 부분들이 있다 보니 중간에 잘 막히는 것 같다. 다른 유형의 그리디 알고리즘 문제를 추가로 풀어보는 연습이 필요할 것 같다.