# WEEK04 DAY4 TIL
으늘은 다이나믹 프로그래밍 11049번 행렬 곱셈 순서 문제와 11053번 가장 긴 증가하는 부분 수열 문제를 풀었다.
그리디 알고리즘에 대해 학습한 후에 11047번 동전 0 문제와 1541번 읽어버린 괄호 문제도 풀었다.
추가로 컴퓨터 시스템 1.5 ~ 1.8까지 미리 읽었다.

## 1. 11049번 행렬 곱셈 순서 문제 풀이
- 오른쪽 아래로 대각선 방향으로 배열에 최소 연산 횟수 값을 채워나가는 문제다.
- 제일 먼저, i번째 앞의 숫자로 시작해서 j번째 뒤의 숫자로 끝나는 행렬의 연산 횟수가 저장하는 dp테이블을 생성하고 0으로 초기화해 준다.
- 첫 번째 반복문은 대각선의 값이 행렬 자신이므로 계산 안 하고 값을 0으로 유지하기 위해 i값을 1 ~ N으로 설정해 준다.
- 두 번째 반복문은 반복문이 지속되면서 계산 횟수가 N - 1로 감소하므로 j값을 0 ~ N - i로 설정해 준다.
- 대각선 다음 칸부터 계산하기 위해 x값을 i + j로 설정해 준다.
- 문제에서 정답은 2**31 - 1 보다 작거나 같은 자연수라고 헀으므로, min 연산을 위해 최댓값을 미리 할당해 준다.
- 세 번째 반복문은 어떤 행렬로 시작해서 어떤 행렬까지의 곱셈하는 모든 방법의 수만큼 반복문이 수행될 수 있도록 설정해 준다.
- 세 번째 반복문을 수행하면서 계산된 연산 횟수 값 중에서 최소 연산 횟수 값을 할당해 준다.
- 마지막으로 구해야 할 dp테이블의 0번째 줄의 마지막 값을 반환해 준다.
- 문제의 예제를 통해 최소 연산 횟수를 구하는 과정을 알아보자
    - 행렬의 총개수는 3개로, (5, 3), (3, 2), (2, 6) 크기의 행렬을 준다.
    - 5로 시작해서 2로 끝나는 행렬의 연산 횟수를 저장하는 방법
        - 5로 시작해서 2로 끝나는 행렬을 만들 수 있는 모든 방법을 비교하여 최솟값을 찾아야 하며, 다음과 같은 경우는 행렬을 만들 방법은 5 * 3 * 2 한 가지이다.
        - 5*3 연산 횟수 + 3*2 연산 횟수 + (5 * 3 * 2) = 0 + 0 + 30
            ```
              3   2   6
            5 0  30   
            3     0  36
            2         0
            ```
    - 5로 시작해서 6로 끝나는 행렬의 연산 횟수를 저장하는 방법
        - 5로 시작해서 6로 끝나는 행렬을 만들 수 있는 모든 방법을 비교하여 최솟값을 찾아야 하며, 다음과 같은 경우는 행렬을 만들 방법은 5 * 3 * 6과 5 * 2 * 6 두 가지이다.
        - 5 * 3 * 6은 5*3 연산 횟수 + 3*6 연산 횟수 + (5 * 3 * 6) = 0 + 36 + 90 = 126
        - 5 * 2 * 6은 5*2 연산 횟수 + 2*6 연산 횟수 + (5 * 2 * 6) = 30 + 0 + 60 + 90
        - 계산된 두 계산값 중에서 작은 값을 저장한다.
            ```
              3   2   6
            5 0  30  90
            3     0  36
            2         0
            ```
- 소스코드
    ```python
    import sys

    def DP():
        # 대각선은 자기 자신이므로 계산 안하고 값을 0으로 유지하기 위해 i값을 1 ~ N으로 설정
        for i in range(1, N):
            # 반복문이 지속되면서 계산 횟수가 N - 1로 감소하므로 j값을 0 ~ N - i로 설정
            for j in range(0, N - i):
                # 대각선 다음 칸부터 계산하기 위해 x값을 i + j로 설정
                x = i + j
                # min 연산을 위해 최대값 미리 할당
                dp[j][x] = 2 ** 32
                # 어떤 행렬로 시작해서 어떤 행렬까지의 곱셈하는 모든 방법의 수만큼 반복문 수행
                for k in range(j, x):
                    # 경우의 수만큼 계산된 연산 횟수 값들 중에서 최소 연산 횟수 값을 할당
                    dp[j][x] = min(dp[j][x], dp[j][k] + dp[k + 1][x] + M[j][0] * M[k][1] * M[x][1])
        # 최종적으로 구해야할 dp테이블의 0번째 줄의 마지막 값 반환
        print(dp[0][-1])

    if __name__ == "__main__":
        sys.stdin = open("input.txt","rt")
        # 행렬의 개수 N 입력
        N = int(sys.stdin.readline())
        # N개의 행렬 크기 r과 c 입력
        M = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
        # i번째 앞의 숫자로 시작해서 j번째 뒤의 숫자로 끝나는 행렬의 연산 횟수가 저장되는 dp테이블 초기화
        dp = [[0] * N for _ in range(N)]
        DP()
    ```

## 2. 11053번 가장 긴 증가하는 부분 수열 문제 풀이
- 이 문제는 2주차 때 이분 탐색을 이용하여 풀었던 문제로 이번에는 다이나믹 프로그래밍을 이용하여 문제를 풀었다.
- 우선 부분 수열의 길이를 저장할 dp테이블을 생성하고, 1로 모두 초기화시켜 준다.
- 이중 for문을 이용하여 전체 수열을 차례대로 탐색한다.
- 이때, A[i]값을 A[i]값 전까지의 값들까지만 탐색해 준다.
- A[i]가 A[j]보다 크면 DP[i]에 DP[i]와 DP[j] + 1을 비교하여 더 큰 값을 저장해 준다.
- 마지막으로 dp테이블에서 가장 큰 값을 출력해 준다.
- 소스코드
    ```python
    import sys

    def DP():
        for i in range(N):
            for j in range(i):
                # A[i]가 A[j]보다 크면 DP[i]에 DP[i]와 DP[j] + 1을 비교하여 더 큰 값을 저장
                if A[i] > A[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        print(max(dp))

    if __name__ == "__main__":
        N = int(sys.stdin.readline())
        A = list(map(int, sys.stdin.readline().split()))
        # A[i]를 마지막 값으로 가지는 가장 긴 증가 부분 수열의 길이 1로 초기화
        dp = [1] * N
        DP()
    ```

## 3. 그리디(Greedy) 알고리즘
- 그리디 알고리즘이란?
    - 탐욕법이라고도 하고, 단순 무식하게 탐욕적으로 문제를 푸는 알고리즘이다.
        - 탐욕적 : 현재 상황에서 지금 당장 좋은 것만 고르는 방법이다.
    - 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해 준다.
        - 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다.

- 그리디 알고리즘의 정당성
    - 그리디 알고리즘을 모든 알고리즘 문제에 적용할 수 있는 것은 아니다.
    - 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다.
        - 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유
            - 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.
            - 800원을 거슬러 줘야 하는데, 화폐 단위가 500원, 400원, 100원인 경우
                - 알고리즘으로는 4개의 동전(500원 + 100원 + 100원 + 100원)을 거슬러 주면 된다.
                - 하지만, 최적의 해는 2개의 동전 (400원 + 400원)을 거슬러 주는 것이다.
                - 즉, '가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다'라는 아이디어는 정당하다.
    - 대부분의 그리디 알고리즘 문제에서는 위처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

## 4. 1541번 읽어버린 괄호 문제 풀이
- 이 문제는 문자열을 나누는 것으로부터 아이디어를 얻었다.
- 처음 식을 입력받을 때 '-'를 기준으로 나눠서 입력받는다.
- 그리디 알고리즘을 수행할 때 다음 뺄셈이 나오기 전의 수들을 '+'를 기준으로 나눠준 후에 모두 더해준다.
- 다음 뺄셈이 나온 후의 수들을 '+'를 기준으로 나눠준 후에 모두 빼준다.
- 소스코드
    ```python
    import sys

    def greedy():
        # 식의 최소값을 저장할 변수 0으로 초기화
        result = 0
        # 다음 뺄셈이 나오기 전의 수들을 '+'를 기준으로 나눠준 후에 모두 더해준다.
        for i in expression[0].split('+'):
        result += int(i)
        # 다음 뺄셈이 나온 후의 수들을 '+'를 기준으로 나눠준 후에 모두 빼준다.
        for i in expression[1:]:
            for j in i.split('+'):
                result -= int(j)
        print(result)

    if __name__ == "__main__":
        sys.stdin = open("input.txt","rt")
        # 식 입력
        # 이때, 식의 값이 최솟값이 되기 위해서는 뺄셈을 기준으로 식을 나눠야 한다.
        expression = sys.stdin.readline().split('-')
        # 그리디 알고리즘 수행
        greedy()
    ```

## 5. 4주차 4일차를 마치며...
행렬 곱셈 순서 문제가 굉장히 어려웠고, 풀이를 보는데도 이해하는 데 시간이 너무 오래 걸렸다. 코딩 테스트 때 이런 문제가 나오면 진짜 못 풀 것 같은 느낌이 든다.
그래도 그리디 문제는 아이디어만 잘 생각해 내면 충분히 풀 수 있는 문제들이어서 괜찮았던 것 같다. 물론 뒤에 어려운 문제들은 또 모르겠지만...

요즘 일요일만 되면 이상하게 잠이 안 와서 정말 싫다. 저번 주도 그렇고 어제도 계속 잠이 안 와서 마지막으로 본 시간이 아침 7시 반이었나 그랬다... 몸이 이상해진 건지 머릿속에 생각이 많아서 그런 건지 잘 모르겠다.

강의실 나오기 전에 장혁님과 박희은님이 운동하시고 오셔서 마침 11053번 가장 긴 증가하는 부분 수열 문제의 연장선인 11055번 가장 큰 증가하는 부분 수열 문제를 설명해 주셔서 또 하나 알차게 배우고 마무리하고 같이 기숙사로 돌아왔다.