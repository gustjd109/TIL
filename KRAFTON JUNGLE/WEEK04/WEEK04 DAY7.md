# WEEK04 DAY7 TIL
오늘은 4주차 알고리즘 테스트 진행하고, 풀지 못했던 문제를 다시 풀어봤다.
내일부터 3주간 진행하는 과정에 대비해서 C언어와 Red-Black Tree에 대한 개념을 공부하려고 했지만, 테스트 문제 푸는데 시간을 너무 많이 써버렸다...
C언어와 Red-Black Tree에 대한 개념 공부는 내일부터 시작해야 할 듯싶다.

## 1. 4주차 알고리즘 테스트 문제 풀이
- 1890번 점프 문제 풀이
    - 이 문제는 반복문을 통해 (0, 0)칸에서 시작해서 (N - 1, N - 1)칸까지 가는 경우의 수를 DP 리스트에 저장해나가는 방법으로 해결해야 한다.
    - 예를 들어 A와 B라는 칸에서 C로 갈 수 있다고 했을 때, C칸까지 갈 수 있는 경우의 수는 A칸과 B칸까지 갈 수 있는 경우의 수의 합이 된다.
    - 즉, 시작칸부터 차례대로 게임판은 순회하면서 각 칸에서 갈 수 있는 칸에 현재 칸까지 오는 경우의 수를 더하고 마지막 칸까지 오는 경우의 수를 출력해주면 된다.
    - 소스코드
        ```python
        import sys

        def find_route_cnt():
            # (0, 0)에서 시작해서 (N - 1, N - 1)까지 가는 경우의 수를 저장할 dp리스트 0으로 초기화
            dp = [[0] * N for _ in range(N)]
            # dp리스트에서 (0, 0)값 1로 초기화
            dp[0][0] = 1

            # (0, 0)에서 (N - 1, N - 1)까지 탐색
            for i in range(N):
                for j in range(N):
                    # 현재 위치한 곳이 (N - 1, N - 1)이라면, 더 이상 진행할 수 없는 종착점이므로 (N - 1, N - 1)칸까지 오는 경우의 수 출력
                    if i == N - 1 and j == N - 1:
                        print(dp[i][j])
                        break

                    # 현재 위치에서 점프할 수 있는 칸의 값 할당
                    cur = game_map[i][j]

                    # 아래로 가는 경우
                    if i + cur < N:
                        # dp리스트에서 아래로 점프한 위치의 값에 현재 칸까지 오는 경우의 수만큼 증가
                        dp[i + cur][j] += dp[i][j]

                    # 오른쪽으로 가는 경우
                    if j + cur < N:
                        # dp리스트에서 오른쪽으로 점프한 위치의 값에 현재 칸까지 오는 경우의 수만큼 증가
                        dp[i][j + cur] += dp[i][j]


        if __name__ == "__main__":
            # 게임 판의 크기 입력
            N = int(sys.stdin.readline())
            # 게임 판의 크기만큼 점프할 수 있는 수 입력
            game_map = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
            # 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 갈 수 있는 경로 찾기 함수 수행
            find_route_cnt()
        ```

- 1520번 내리막 길 문제 풀이
    - 이 문제는 출발지인 (0, 0)부터 도착지인 (M - 1, N - 1)까지 DFS를 이용하여 모두 탐색하는 방법을 사용하면 시간초과가 발생한다.
    - 시간초과가 발생하는 것을 해결하기 위해 DFS와 DP 방식을 결합한 방식을 사용하여, 현재 방문중인 경로를 이미 다른 경로가 방문하였다면 탐색을 진행하지 않아 중복되는 것을 줄여 수행시간을 줄이는 것이다.
    - 문제 풀이 과정은 다음과 같다.
    - 방문하지 않은 곳이라면, 방문처리를 해준 다음 상하좌우를 탐색한다.
    - 방문하지 않은 곳으로부터 탐색한 상하좌우 칸 중에서 지도 범위 내에 있고, 현재 칸의 높이보다 해당 칸의 높이가 낮다면 해당 칸으로 이동한다.
    - 이동했다는 의미로 이동한 칸을 DP테이블에서 0으로 바꿔준다.
    - 도착지인 (M - 1, N - 1)에 도착하면, 시작점에서 도착점까지 성공적으로 방문한 한 가지 경우가 되므로 1을 리턴해주고, 해당 값을 지금까지 지나온 경로에 모두 더해준다.
    - 탐색중에 현재 방문중인 경로를 이미 다른 경로가 방문하였다면(즉, -1이 아닌 다른 값으로 갱신되어 있을 경우), 더 이상 탐색을 진행하지 않고 해당 값만 갱신시켜 준다.
    - DFS 탐색이 모두 끝나고 나서 dp[0][0]을 반환해 준다.
    - 소스코드
        ```python
        import sys
        sys.setrecursionlimit(10**9)

        def dfs(x, y):
            # 목적지에 도착했으면 1을 리턴하고, 목적지까지 이동한 모든 칸에 1증가
            if x == M - 1 and y == N - 1:
                return 1
    
            # 방문하지 않은 곳이라면 방문처리
            if dp[x][y] == -1:
                dp[x][y] = 0
        
                # 방문하지 않은 곳에서 상하좌우 탐색
                for i in range(4):
                    nx = dx[i] + x
                    ny = dy[i] + y
            
                    # nx와 ny값이 지도 범위 내에 있고, 현재 높이보다 낮은 높이라면
                    if 0 <= nx < M and 0 <= ny < N and travel_map[nx][ny] < travel_map[x][y]:
                        # (nx, ny) 지점에서 DFS 재귀호출
                        dp[x][y] += dfs(nx, ny)
    
            # 탐색한 곳이거나 탐색할 수 없는 곳이라면 자기 자신을 리턴
            # 마지막에 dp테이블의 (0, 0) 값을 리턴
            return dp[x][y]

        if __name__ == "__main__":
            sys.stdin = open("input.txt","rt")
            # 지도의 가로, 세로 크기 입력
            M, N = list(map(int, sys.stdin.readline().split()))
            # 지도의 각 지점의 높이 입력
            travel_map = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]
            # dp테이블 -1로 초기화
            dp = [[-1 for _ in range(N)] for _ in range(M)]
            # 방향 정보(상하좌우)
            dx = [-1, 1, 0, 0]
            dy = [0, 0, -1, 1]
            # DFS 함수 수행
            print(dfs(0, 0))
        ```

## 2. 4주차 7일차를 마치며...
드디어 4주간의 알고리즘 과정이 끝났다. 아직 많이 부족하지만, 4주 동안 알고리즘 문제만 풀면서 몰랐던 자료구조에 대한 개념과 유형별로 사용해야 하는 알고리즘 등에 대해서 많이 배운 것 같다.
김현수 코치님께서 알고리즘 테스트 코드리뷰와 발제 시간에 이것으로 알고리즘을 손 놓고 끝내면, 차후에 있을 코딩 테스트에서 감을 잃었기 때문에 좋은 결과를 얻기 힘들다고 하셨다.
이 말에 정말 공감이 가며, 사실 당장 저번에 풀었던 문제를 다시 풀어보면 분명히 못 푸는 문제가 많을 것이다.
따라서, 우리 반은 매주 수요일 다 같이 알고리즘 문제를 푸는 시간을 매주 금요일 오전 10시부터 12시까지 총 4문제를 풀고, 점심 먹고 와서 코드 리뷰를 하기로 했다.
추가로 더 진행하고 싶은 사람은 매일 1문제씩 더 풀어보기로 했고, 나도 대부분의 문제 풀이 시간을 모두 참여하여 마지막 날까지 알고리즘 문제를 풀어서 꼭 코딩 테스트를 통과할 수 있는 실력을 여기서 갖춰 나가고 싶다.