# WEEK03 DAY1 TIL
3주차 1일차 시작!🎉  
오늘은 트리 자료구조에 대해 공부한 후에 알고리즘 문제를 풀었으며, 풀면서 파이썬에서의 예외 처리와 재귀 최대 깊이 제한을 설정할 수 있는 방법에 대해 새롭게 배웠다.  
다음에는 앞으로 풀어야 할 그래프에 대해 자세하게 공부해 볼 계획이다. 그래프도 DFS, BFS 등 여러 그래프 알고리즘이 많아서 공부할 양이 어마어마 해 보인다.😱

## 1. 트리
- 트리란?
    - 노드로 이루어진 자료구조로 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다.
        - 선형 자료구조란?
            - 하나의 자료 뒤에 하나의 자료가 존재하는 것이다.
            - 자료 간의 앞뒤 관계가 1:1의 관계이다.
            - 대표적인 선형 구조로 배열, 리스트, 스택과 큐가 있다.
        - 비선형 자료구조란?
            - 하나의 자료 뒤에 여러 개의 자료가 존재할 수 있는 것이다.
            - 자료들 간의 앞뒤 관계가 1:N 또는 N:N의 관계이다.
            - 대표적인 비선형 구조로 트리와 그래프가 있다.
        - 좀 더 자세하게 정리해 보면, 다음과 같다.
            - 자료구조
                - 선형구조
                    - 선형 리스트 : 배열, 레코드
                    - 연결 리스트
                    - 스택
                    - 큐
                    - 데크
                - 비선형 구조
                    - 트리 : 일반 트리, 이진 트리
                    - 그래프 : 방향 그래프, 무방향 그래프
                - 파일 구조
                    - 직접 파일
                    - 순차 파일
                    - 색인 순차 파일
    - 계층적 관계를 표현하는 자료구조이다.

- 트리의 특징
    - 트리는 하나의 루트 노드를 갖는다.
    - 루트 노드는 0개 이상의 자식 노드를 갖는다.
    - 자식 노드 또한 0개 이상의 자식 노드를 갖는다.
    - 노드(Node)들과 노드들을 연결하는 간선(Edge)들로 구성되어 있다.
    - 트리에는 사이클(Cycle)이 존재할 수 없다.
        - 사이클이란 시작 노드에서 출발해 다른 노드를 거쳐 다시 시작 노드로 돌아올 수 있다면 사이클이 존재한다고 한다.
    - 트리는 사이클이 없는 하나의 연결 그래프라고 할 수 있다.
    - 트리의 노드는 Self-Loop가 존재 해서는 안 된다.
    - N개의 노드를 갖는 트리는 항상 N - 1개의 간선을 갖는다.
    - 모든 자식 노드는 한 개의 부모 노드만을 갖는다.

- 트리에 관련된 용어
    - 루트 노드(Root Node) : 부모가 없는 노드(가장 위쪽에 있는 노드)로 트리는 단 하나의 루트 노드를 가진다.
    - 단말 노드(Leaf Node) : 자식이 없는 노드(가장 아래쪽에 있는 노드)로 Terminal 노드라고도 부른다.
    - 내부 노드(Internal Node) : 단말 노드가 아닌 노드다.
    - 간선(Edge) : 노드를 연결하는 선이다.
    - 자식(Child) : 어떤 노드와 가지가 연결되었을 때 아래쪽 노드를 자식이라고 한다.
    - 부모(Parent) : 어떤 노드와 가지가 연결되었을 때 위쪽 노드를 부모라고 한다.
    - 형제(Sibling) : 같은 부모 노드를 갖는 노드들이다.
    - 조상(Ancestor) : 어떤 노드에서 위쪽으로 가지를 따라가면 만나는 모든 노드이다.
    - 자손(Descendant) : 어떤 노드에서 아래쪽으로 가지를 따라가면 만나는 모든 노드이다.
    - 높이(Height) : 루트 노드에서 가장 멀리 있는 리프까지의 거리이며, 리프 레벨의 최댓값이다.
    - 레벨(level) : 루트에서 얼마나 멀리 떨어져 있는지를 나타내는 것이다.
    - 차수(degree) : 각 노드가 갖는 자식 노드의 개수다.
    - 서브 트리(Sub Tree) : 어떤 노드를 루트로 하고, 그 자손으로 구성된 트리이다.
    - 빈 트리(None Tree / Null Tree) : 노드와 가지가 전혀 없는 트리이다.

- 트리의 종류
    - 이진 트리(Binary Tree)
        - 각 노드가 최대 두 개의 자식을 갖는 트리이다.
        - 각 노드는 자식이 없거나 한 개 이거나 두 개만을 갖는 것이다.
        - 이진 트리는 전위, 중위, 후위 순회를 통해 탐색할 수 있다.
            - 중위 순회(Inorder Traversal) : 왼쪽 서브 트리-루트 노드-오른쪽 서브 트리 순으로 탐색이 재귀적으로 진행된다. 
            - 전위 순회(Preorder Traversal) : 루트 노드-왼쪽 서브 트리-오른쪽 서브 트리 순으로 탐색이 재귀적으로 진행된다.
            - 후위 순회(Postorder Traversal) : 왼쪽 서브 트리-오른쪽 서브 트리-루트 노드 순으로 탐색이 재귀적으로 진행된다.
    - 완전 이진 트리(Complete Binary Tree)
        - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리이다.
        - 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
    - 전 이진 트리(Full Binary Tree)
        - 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리이다.
    - 포화 이진 트리(Perfect Binary Tree)
        - 모든 레벨이 노드로 꽉 차 있는 트리이다.
        - 다음과 같은 성질을 만족해야 한다.
            - 모든 노드가 0개 혹은 2개의 자식 노드를 갖는다.
            - 모든 말단 노드가 같은 깊이 또는 레벨을 갖는다.
            - 트리의 노드 개수가 정확히 2^k-1 개여야 한다. 여기서 k는 트리의 높이다.
    - 이진 탐색 트리(Binary Search Tree)
        - 효율적인 탐색을 위해 고안된 트리이다.
        - 이진 트리이면서 아래와 같은 속성을 갖는 트리이다.
            - 이진 탐색 트리의 노드에 저장된 키(key)는 유일하다.
            - 부모의 키가 왼쪽 자식 노드의 키보다 크다.
            - 부모의 키가 오른쪽 자식 노드의 키보다 작다.
            - 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.

## 2. 이진 탐색 트리(Binary Search Tree)
- 이진 탐색 트리 특징
    - 각 노드에 중복되지 않는 키(key)가 있다.
    - 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다.
    - 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다.
    - 좌우 서브 트리도 모두 이진 탐색 트리여야 한다.
    - 기존 이진 트리보다 탐색이 빠르다.
    - 탐색 연산은 트리의 높이(height)가 h라면 O(h)의 시간 복잡도를 갖는다.

- 이진 탐색 트리가 알고리즘에 폭넓게 사용되는 이유
    - 구조가 단순하다.
    - 중위 순회의 깊이 우선 검색(DFS)을 통해 노드 값을 오름차순으로 얻을 수 있다.
    - 이진 검색과 비슷한 방식으로 아주 빠르게 검색할 수 있다.
    - 노드를 삽입하기 쉽다.

- 탐색 과정
    - 루트 노드의 키와 찾고자 하는 값을 비교한다. 찾고자 하는 값이라면 탐색을 종료한다.
    - 찾고자 하는 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리로 탐색을 진행한다.
    - 찾고자 하는 값이 루트 노드의 키보다 크다면 오른쪽 서브 트리로 탐색을 진행한다.

- 삽입 과정
    - 삽입할 값을 루트 노드와 비교해서 같다면 오류를 발생한다(중복 값 허용 X)
    - 삽입할 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리를 탐색해서 비어있다면 추가하고, 비어있지 않다면 다시 값을 비교한다.
    - 삽입할 값이 루트 노드의 키보다 크다면 오른쪽 서브 트리를 탐색해서 비어있다면 추가하고, 비어있지 않다면 다시 값을 비교한다.

- 삭제 과정
    - 삭제하려는 노드가 단말 노드(Leaf Node)일 경우
        - 삭제할 노드의 부모 노드가 있다면 부모 노드를 NULL로 만들고, 삭제할 노드를 삭제(메모리 해제)해 준다.
    - 삭제하려는 노드의 서브 트리가 하나인 경우(왼쪽 혹은 오른쪽 서브트리)
        - 삭제할 노드의 자식노드를 삭제할 노드의 부모노드가 가리키게 하고 해당 노드를 삭제한다.
    - 삭제하려는 노드의 서브 트리가 두 개인 경우
        - 첫 번째 방법
            - 삭제할 노드 왼쪽 서브 트리의 가장 큰 자손을 해당 노드의 자리에 올린다.
        - 두 번째 방법
            - 삭제할 노드 오른쪽 서브 트리의 가장 작은 자손을 해당 노드의 자리에 올린다.

## 3. 5639번 이진 검색 트리 문제 풀이
- 트리를 사용한 풀이
    - 이 풀이 방법은 전위 순회한 결과로 왼쪽과 오른쪽 서브 트리를 이용하여 원래 트리를 만든 후, 후위 순회하여 결과를 출력하는 방식이다.
    ```python
    import sys
    # 재귀 최대 깊이 설정
    sys.setrecursionlimit(10**9)

    # 전위 순회한 결과를 이진 검색 트리로 만들어 주는 함수
    def maketree(N_list):
        # 전위 순회 입력값 리스트의 길이가 0이면, 리턴
        if len(N_list) == 0:
            return
    
        # 왼쪽, 오른쪽 서브트리 초기화
        left_subtree = []
        right_subtree = []
        # 루트값을 전위 순회 입력값 리스트의 0번째 인덱스 값으로 설정
        root = N_list[0]
        # 루트값을 이미 저장했기 때문에 전위 순회 입력값 리스트의 두 번째 인덱스부터 전위 순회 입력값 리스트의 마지막 인덱스까지 반복문 수행
        for i in range(1, len(N_list)):
            # 전위 순회 입력값 리스트의 i번째 값이 루트값보다 작으면, 왼쪽 서브트리에 i번째 값 삽입
            if N_list[i] < root:
                left_subtree.append(N_list[i])
            # 전위 순회 입력값 리스트의 i번째 값이 루트값보다 크면, 오른쪽 서브트리에 삽입
            else:
                right_subtree.append(N_list[i])
        # 반복문 종료

        # 왼쪽과 오른쪽 두 서브트리의 길이가 0이 아니면, 
        # 트리의 루트값(키)에 연결되는 왼쪽 노드에 왼쪽 서브트리의 0번째 값을
        # 오른쪽 노드에는 오른쪽 서브트리의 0번째 값을 삽입
        if len(left_subtree) != 0 and len(right_subtree) != 0:
            tree[root] = [left_subtree[0], right_subtree[0]]
        # 왼쪽 서브트리의 길이가 0이 아니고 오른쪽 서브트리의 길이가 0이면, 
        # 트리의 루트값(키)에 연결되는 왼쪽 노드에 왼쪽 서브트리의 0번째 값을
        # 오른쪽 노드에는 '.'을 삽입
        elif len(left_subtree) != 0 and len(right_subtree) == 0:
            tree[root] = [left_subtree[0], "."]
        # 왼쪽 서브트리의 길이가 0이고 오른쪽 서브트리의 길이가 0이 아니면,
        # 트리의 루트값(키)에 연결되는 오른쪽 노드에는 '.'을 
        # 왼쪽 노드에 왼쪽 서브트리의 0번째 값을 삽입
        elif len(left_subtree) == 0 and len(right_subtree) != 0:
            tree[root] = [".", right_subtree[0]]
        # 왼쪽과 오른쪽 두 서브트리의 길이가 0이면, 리턴
        else:
            return
    
        # 재귀함수를 호출하여 왼쪽, 오른쪽 서브트리의 첫 번째 값을 트리의 루트값으로 하여 반복 수행
        maketree(left_subtree)
        maketree(right_subtree)

    # 만들어진 이진 검색 트리로 후위 순회한 결과를 구해주는 함수
    def postorder(root):
        # 루트값이 '.'이면, 리턴
        if root == ".":
            return
        # 트리에 루트값이 없으면, 왼쪽과 오른쪽 노드가 없기 때문에 루트값 출력
        if root not in tree:
            print(root)
            return
        # 후위 순회를 하면서 루트값 출력
        postorder(tree[root][0])
        postorder(tree[root][1])
        print(root)

    if __name__ == "__main__":
        # 전위 순회 입력값 저장 리스트 / 트리 / 입력값의 개수(노드의 개수) 초기화
        N_list = []
        tree = {}
        input_cnt = 0
        # 전위 순회 입력값의 개수(노드의 개수)가 10,000개 이하일때만 반복문 수행
        while input_cnt <= 10000:
            try:
                N_list.append(int(sys.stdin.readline()))
            # 전위 순회 입력값이 10,000개가 넘어가거나, 공백을 입력하면 반복문 종료
            except:
                break
            input_cnt += 1
    
        # 전위 순회한 결과를 이진 검색 트리로 만들어 주는 함수 실행
        maketree(N_list)
        # 만들어진 이진 검색 트리로 후위 순회한 결과를 구해주는 함수
        postorder(N_list[0])

- 트리를 사용하지 않고 재귀함수만을 이용한 풀이
    - 이 풀이 방법은 더 좋은 다른 풀이 방법이 없을까 찾아본 결과 알아낸 방식이다.
    - 루트값을 기준으로 루트값보다 큰 값이 존재하면 그 값을 기준으로 왼쪽, 오른쪽 서브 트리를 나눠준 후, 재귀를 통해 이 과정을 반복하여 후위 순회한 결과를 출력한다.
    - 예를 들어, 이 문제의 부모 노드의 값은 50이다. 0부터 순차적으로 탐색하여 50보다 값이 커지는 순간을 찾는다. 이는 98에 해당하며, 이를 기준으로 30부터 45까지는 50 노드의 왼쪽 서브 트리에 해당하고 98부터 60까지는 50 노드의 오른쪽 서브 트리에 해당한다. 따라서, 먼저 왼쪽 서브 트리에 대하여 재귀적으로 호출하고 다음으로 오른쪽 서브 트리에 대하여 재귀적으로 호출한다. 그리고, 마지막에 부모 노드의 값인 50을 출력하도록 하면 후위 순회 결과를 얻을 수 있다.
    ```python
    import sys
    sys.setrecursionlimit(10**9)

    # 후위 순회한 결과를 구해주는 함수
    def postorder(start, end):
        # 배열을 모두 돌면, 리턴
        if start >= end:
            return
        # mid값을 기준으로 왼쪽, 오른쪽 서브트리로 분할
        mid = end + 1

        for i in range(start + 1, end + 1):
            # 현재 노드보다 큰 i번째 값이 있다면, 그 전까지의 값은 모두 왼쪽 서브트리
            # 현재 노드보다 큰 i번째 값 이후의 값은 모두 오른쪽 서브트리
            if N_list[start] < N_list[i]:
                mid = i
                break

        # 왼쪽 서브트리 재귀함수
        postorder(start + 1, mid - 1)
        # 오른쪽 서브트리 재귀함수
        postorder(mid, end)
        # 후위순회이므로 제일 마지막에 출력
        print(N_list[start])

    if __name__ == "__main__":
        # 전위 순회 입력값 저장 리스트 / 트리 / 입력값의 개수(노드의 개수) 초기화
        N_list = []
        input_cnt = 0
        # 전위 순회 입력값의 개수(노드의 개수)가 10,000개 이하일 때만 반복문 수행
        while input_cnt <= 10000:
            try:
                N_list.append(int(sys.stdin.readline()))
            # 전위 순회 입력값이 10,000개가 넘어가거나, 공백을 입력하면 반복문 종료
            except:
                break
            input_cnt += 1

    # 후위 순회한 결과를 구해주는 함수에 start : 0 / end : 전위 순회 입력값 저장 리스트 길이 - 1값 전달
    postorder(0, len(N_list) - 1)
    ```

## 4. 파이썬에서의 재귀 최대 깊이 제한 설정 방법
- 해당 내용은 파이썬을 이용하여 코딩테스트를 볼 때 하나의 팁이기도 하다.
- 재귀를 사용하여 문제를 풀어야 한다면, sys.setrecursionlimit()로 재귀 최대 깊이를 꼭 설정해 주자.
- 파이썬에서의 기본 재귀 최대 깊이 제한은 1000으로 매우 얕다.
- 따라서, 재귀로 문제를 풀 때 드물지 않게 recursion error로 인해 런타임 에러가 발생하는 경우가 있다.
- 코딩테스트 환경에서는 해당 에러 메시지를 볼 수 없으므로 원인 미상의 런타임 에러 때문에 시간을 잡아먹을 수 있다.
- 단, PyPy에서는 sys.setrecursionlimit()로 재귀의 최대 깊이를 설정할 수 없다.

## 5. 파이썬에서의 예외 처리 방법
- 예외 처리(exception handling)란?
    - 발생한 예외 상황을 처리할 수 있도록 프로그램의 흐름을 바꾸는 행위이다.
    - 또한, 파이썬은 발생할 수 있는 예외에 대해 exception 객체로 미리 정의해 두고 있다.
    - 미리 정의된 에러에 관한 내용을 아래 링크에서 확인할 수 있다.
        - http://docs.python.org/3/library/exceptions.html

- 몇 가지 예외 케이스
    - ZeroDivisionError : 값을 0으로 나누려고 할 때 발생하는 에러
    - SystemExit : 프로그램 종료하는 명령이 실행되었을 경우
    - KeyboardInterrupt : Ctrl + C 키가 입력되었을 경우
    - EOFError : 읽어드릴 데이터가 없을 경우
    - IndexError : list등에서 잘못된 인덱스로 접근할 경우
    - PermissionError : 명령을 실행할 권한이 없을 경우
    - 이 외에도 여러 가지의 에러 케이스들이 있다.

- 예외처리 종류
    - try ~ except
        - 예외처리하고자 하는 부분을 try로 감싸주고, except문을 마지막에 붙여주면 된다.
        - 'try안에 있는 코드를 시도해 보고, 예외가 발생하면 except문을 실행하라'는 것이다.
        ```python
        try:
            실행할 코드
        except:
            예외가 발생했을 때 실행할 코드
        ```

    - try ~ except ~ else
        - 어떤 로직을 수행할 때 오류상황이 아닐 때만 어떤 작업을 수행하는 코드를 작성할 때 사용한다.
        - else 문을 사용해 try~except 사이의 코드가 문제가 없다는 것을 확인할 수 있는 장점이 있다.
        ```python
        try:
            실행할 코드
        except:
            예외가 발생했을 때 실행할 코드
        else:
            except 절을 만나지 않았을 때 실행할 코드
        ```
    
    - try ~ except ~ finally
        - 오류 발생 유무와 상관 없이 어떤 코드를 무조건 실행시키기 위해서 사용한다.
        ```python
        try:
            실행할 코드
        except:
            예외가 발생했을 때 실행할 코드
        finally:
            무조건 실행시킬 코드
        ```
    
    - try ~ except ~ Exception as e
        - 예외 변수를 사용하여 예외의 에러 메시지를 받아올 수 있다.
        - as 다음에 예외 변수를 지정하면 예외 관련 정보를 얻을 수 있으며, print(e)로 예외 메시지를 출력할 수 있다.
        ```python
        try:
            실행할 코드
        except 정의된 에러:
           정의된 에러가 발생했을 때 실행할 코드
        # 파이썬에서 미리 정의된 에러 중 하나로, 값을 0으로 나누려고 할 때 발생하는 에러
        except ZeroDivisionError:
           ZeroDivisionError가 발생했을 때 실행할 코드
        except 예외 종류 as 예외 변수:
           예외가 발생했을 때 실행할 코드
        except Exception as e:
           print(e)
        ```
    
    - raise
        - 사용자의 입력이나, 프로그램이 돌아가다가 우리가 의도하지 않게 돌아가는 것을 방지하려고 일부러 에러를 발생시킬 때 사용한다.
        - raise 뒤에 파이썬에서 정의된 에러를 넣을 수 있다. (예 : raise ValueError)
        - raise 뒤에 메시지를 추가하여 우리가 원하는 메시지를 출력할 수 있다. (예 : raise Exception("메시지"))
        ```python
        a = int(input("1~5까지 숫자 입력 : "))
        # 범위를 벗어나면 error 발생
        if a < 1 or a > 5:
            raise
        # 범위 안에 있으면 정상 출력
        print(f"입력한 a : {a} 입니다.")
        ```

## 6. 3주차 1일차를 마치며...
문제 풀기 전과 풀면서 새로 배워야 하는 지식이 많다 보니 힘든 부분도 많다.  
특히, 하루 공부를 마치고 TIL을 작성하기 위해 정리할 내용이 많아서 공부를 마쳐도 작성하느라고 늦게 자는 날이 많다.  
하지만, 이 과정을 통해 마지막에 공부한 내용을 다시 한번 정리할 기회가 되어서 좋다.  
이런 자료 하나하나가 모여 앞으로 내게 정말 큰 도움이 될 것이기에 꾸준히 작성할 계획이다.  
물론 깃허브 오류로 지금까지 작성한 TIL과 알고리즘 문제 풀이 코드 등을 못 올리고 있지만...😅  
하루 빨리 해결해서 깃허브 🌱잔디도 초록색으로 덮이게 깔고 싶다.