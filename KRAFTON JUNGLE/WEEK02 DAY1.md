# WEEK02 DAY1 TIL

## 1. 2주차 시작!
드디어 2주차가 시작되었다. 1주차 마지막날 말했던 것 처럼 문제 풀기 전 이분 탐색에 대해 공부했고, 공부한 내용을 토대로 문제를 풀었다. 문제를 풀다가 투 포인터 알고리즘과 슬라이딩 윈도우 알고리즘에 대해서도 새롭게 배웠다.

## 2. 이분 탐색 문제 풀기
이분 탐색은 총 6 문제로 모두 해결하는 것이 목표였지만, 막히는 부분을 해결하는 데 오래 걸려 4문제밖에 풀지 못했다...😢 문제를 해결하면서 막혔던 부분을 정리해봤다.
- 2805번(나무 자르기)
    - 처음 이 문제를 풀고 제출했을 때, 시간초과로 인해 틀렸다. 하지만, 다른 조원으로부터 Python3가 아닌 PyPy로 제출하면 시간초과 없이 정상적으로 문제가 풀린다는 말을 듣고 해봤더니 정말 풀렸다! Python3와 PyPy의 차이점에 대해서는 차후에 한 번 자세하게 찾아봐야겠다. 아래는 내가 작성한 코드이다.
        ```python
        import sys
        N, M = map(int, sys.stdin.readline().split())
        N_list = list(map(int, sys.stdin.readline().split()))
        start, end = 0, max(N_list)
        while start <= end:
            mid = (start + end) // 2
            cnt = 0
            for i in N_list:
                if i > mid:
                    cnt += (i - mid)
        if cnt >= M:
            start = mid + 1
        else:
            end = mid - 1
        print(end)
        ```
    - 이 코드는 이분 탐색을 통해 모든 탐색을 마친 후에 결과 값을 출력하는 형태로 동작된다.
    - 문제의 예제를 보면 나무의 수가 4개, 상근이가 집으로 가져가려는 나무의 길이가 7이다. 나무들의 높이는 각각 20, 15, 10, 17미터이다.
    - 이때, 이분 탐색을 하면 2번 째 탐색할 때 상근이가 가져가려는 길이인 7미터가 딱 나온다.
    - 나는 이 코드를 이분 탐색을 실행하면서 중간에 결과값이 나오면 반복문을 종료하고 결과값을 리턴시켜주도록 코드를 수정했다. 분명 vscode에서는 예제를 실행했을 때 출력값이 맞게 잘 나왔는데 제출하면 틀렸다고 나온다. 이 과정에서 정말 오랜 시간이 걸렸다...
    - 다른 조원인 김용현님의 도움(감사합니다!🙏)으로 자른 나무들의 총합인 cnt값이 가져가려는 나무 길이보다 클 때에도 mid값을 결과값에 갱신해줘야 한다는 사실을 알게 되었고, 프로그램을 수정하여 해결할 수 있었다. 아래는 다시 수정한 코드이다.
        ```python
        import sys

        N, M = map(int, sys.stdin.readline().split())
        N_list = list(map(int, sys.stdin.readline().split()))
        start, end = 0, max(N_list)
        retult = 0

        while start <= end:
            mid = (start + end) // 2
            cnt = 0
            for i in N_list:
                if i > mid:
                    cnt += (i - mid)
                    if cnt > M:
                        break
            if cnt > M:
                start = mid + 1
                # 자른 나무들의 총합인 cnt값이 가져가려는 나무 길이보다 클때에도 mid값을 결과값에 넣어줘야 함
                result = mid
            elif cnt == M:
                result = mid
                break
            else:
                end = mid - 1

        print(result)
        ```

- 2110번(공유기 설치)
    - 사실 이 문제는 문제 자체를 이해하는데 정말 오랜 시간이 걸렸다(이제는 한국어도 이해 못하는듯...😂). 결국, 같은 조원인 박유빈님에게 도움을 요청하여 문제에 대한 자세한 설명을 듣고 정확하게 이해하여 문제를 풀 수 있었다.
    - 작성한 코드를 제출했을 때 틀렸고, 어느 부분이 문제인지 확인하기 위해 반례를 찾아봤다. 찾아본 반례는 아래와 같다.
    - 3 3   
      1   
      4   
      6   
      출력 : 2(내 코드에서의 출력 : 0)
    - 코드를 다시 확인해보니 start 초기 설정 부분에서 이상함이 느껴졌다. start값을 N_list[1] - N_list[0]으로 설정했을 떄, 반례의 start값이 3이 나오는 것이었다. 원래는 1이 나와야하며, 문제의 예제에서 1로 나오는 예제였기 때문에 아무 이상 없었던 것이었. start값을 1로 초기화시켜준 후에 반례를 다시 실행하였더니 출력값이 2가 나왔고, 문제를 해결할 수 있었다. 아래는 내가 작성한 코드이다.
        ```python
        import sys

        N, C = map(int, sys.stdin.readline().split())

        N_list = []
        for _ in range(N):
            N_list.append(int(sys.stdin.readline()))
        N_list.sort() # 이진탐색을 위해 집 좌표 리스트 정렬

        start = 1 # 집과 집 사이의 최소거리 1로 초기화
        end = N_list[-1] - N_list[0] # 집과 집 사이의 최대거리 가장 먼 집과 가장 가까운 집과의 거리로 초기화 

        result = 0

        while start <= end:
            mid = (start + end) // 2
            value = N_list[0] # 처음 집에는 공유기를 무조건 설치할 수 있기 때문에 value값에 처음 집 좌표 저장
            cnt = 1 # 처음 집은 무조건 설치 했기때문에 공유기 설치 카운트 수 1로 설정

            for i in range(1, N): # 처음 집은 설치 했기 때문에 다음 집부터 마지막 집까지 반복문 실행
                if N_list[i] >= value + mid: # i번째 집 좌표값이 value + mid보다 크거나 같으면
                    value = N_list[i] # 공유기를 설치할 수 있기때문에 value값에 집 좌표를 갱신
                    cnt += 1 # 공유기를 설치했기 때문에 카운트값 +1

            # 공유기 설치 카운드 값이 설치해야되는 개수보다 크거나 같으면, start값을 mid + 1해서
            # 집과 집 사이의 걸이가 더 멀어도 설치해야하는 공유기 개수만큼 설치가 가능한지 확인
            if cnt >= C: 
                start = mid + 1
                result = mid # 우선 결과값에 현재 mid값 저장(mid값이 공유기 C개를 설치할 수 있는 거리)
            # 공유기를 설치할 수 있는 개수가 부족하다면, end값을 mid - 1 해서
            # 공유기를 더 설치할 수 있는지 확인
            else:
                end = mid - 1

        print(result)
        ```

- 2470번(두 용액)
    - 이 문제는 그래도 이해하고 직접 구현하는 데 까지는 가능했지만, 쉽게 풀리지는 않았다.  
    이분 탐색이 아닌 다른 방법으로 풀어야 될 거 같다는 느낌이 들었고, 한참 고민하다가 검색을 해봤다. 그 결과, 이분 탐색과 비슷한 투 포인터 기법이라는 알고리즘을 사용하는 문제였고, 해당 기법을 이용하여 문제를 해결할 수 있었다.
        ```python
        import sys

        N = int(sys.stdin.readline())
        N_list = sorted(list(map(int, sys.stdin.readline().split())))
        start, end = 0, N - 1
        # 두 용액을 합한 특성값이 0에 가까운 두 용액을 저장하는 리스트
        result = []
        # 두 용액을 합한 특성값을 비교하여 더 작은 값을 저장 하기 위한 변수
        min_val = sys.maxsize

        # N개의 용액들의 특성값은 모두 다르다는 조건에 의해 <=가 아닌 <로 해줘야 함
        while start < end:
            # 두 용액의 특성값을 더한 값을 저장하기 위한 임시 변수
            tmp = N_list[start] + N_list[end]
            # 두 용액의 특성값을 더한 절대값이 min_val보다 작다면
            # 절대값으로 변환하여 저장하는 이유 : 0까지의 차이값을 구하는 것이기에 음수이든 양수이든 상관 없기 때문이다.
            if abs(tmp) < min_val:
                # min_val에 두 용액의 특성값을 더한 절대값을 저장
                min_val = abs(tmp)
                # 결과값에 두 용액의 특성값 저장
                result = (N_list[start], N_list[end])
            # 두 용액의 특성값을 더한 값이 0보다 작다면, start값에 +1
            # 0에 가까운 값으로 만들기 위해 더 작은 음수값을 더하기 위함
            if tmp < 0:
                start += 1
            # 두 용액의 특성값을 더한 값이 0보다 크다면, end값에 -1
            # 0에 가까운 값으로 만들기 위해 더 작은 양수값을 더하기 위함
            elif tmp > 0:
                end -= 1
            # 두 용액의 특성값을 더한 값이 0이거나, 투 포인터 검색이 끝나면 프로그램 종료
            else:
                break
        # 검색이 끝난 후, 저장된 두 용액의 특성값 출력
        print(*result)
        ```

## 3. 투 포인터 알고리즘
- 투 포인터 알고리즘이란?
    - 1차원 문자열이나 배열에서 두 개의 포인터를 이용하여 원하는 값을 찾을 때 알고리즘
    - 보통 l(left), r(right)나 s(start), e(end) 같은 식으로 포인터의 이름을 붙임

- 투 포인터 알고리즘의 2가지 유형
    - 2개의 포인터 변수 시작점이 배열의 시작점인 경우
    - 정렬된 배열 안에서 2개의 포인터 변수가 각각 시작점과 끝점에 위치한 경우

- 2개의 포인터 변수 시작점이 배열의 시작점인 경우의 동작 방식
    - start는 부분 배열의 앞 쪽을 가르키는 인덱스, end는 부분 배열의 뒤 쪽을 가르키는 인덱스가 된다.
    - 맨 처음에 두 포인터는 0에서 시작하며 항상 start<=end를 만족해야 함
    - 매 순간마다 구해야하는 값을 비교하여 포인터를 이동
    - 부분 배열의 합 < 구해야하는 값이라면
        - end를 오른쪽으로 한 칸 이동하여 부분 배열의 크기를 증가시킨다.(부분 배열의 길이를 늘려 합을 더해준다)
    - 부분 배열의 합 >= 구해야하는 값이라면
        - start를 오른쪽으로 한 칸 이동하여 부분 배열의 크기를 감소시킨다.(부분 배열의 길이를 줄여 합을 빼준다)
    - 부분 배열의 합이 구해야하는 값과 같으면 count += 1해준다.
    - 위의 과정을 반복한다.

- 투 포인터의 시간 복잡도
    - 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 각 포인터가 n번 누적 증가해야 알고리즘이 끝난다.
    - 각각 배열 끝에 다다르는데 O(N)이라 둘을 합쳐도 여전히 O(N)
    - 대표적인 백준 문제 : 2003번(수들의 합 2)

## 4. 슬라이딩 윈도우 알고리즘
-  슬라이딩 윈도우 알고리즘이란?
    - 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘
    - 배열이나 리스트의 요소의 일정 범위의 값을 비교할때 사용하면 매우 유용
    - 교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법
    - 대표적인 백준 문제 : 2096번(내려가기)

## 5. 투 포인터 알고리즘과 슬라이딩 윈도우 알고리즘의 공통점
- 1차원 문자열이나 배열을 2회 이상 탐색해야 할 경우 O(N^2) 이상 걸릴 시간 복잡도를
  부분 배열을 활용하여 O(N)으로 줄일 수 있음

## 6. 투 포인터 알고리즘과 슬라이딩 윈도우 알고리즘의 차이점
- 부분 배열 길이의 변화 여부가 두 알고리즘의 차이점
  - 투 포인터 알고리즘 : 부분 배열의 길이가 가변적
  - 슬라이딩 윈도우 알고리즘 : 부분 배열의 길이가 고정적
- 주로 정렬된 배열을 대상으로 하는 투 포인터와 달리 슬라이딩 윈도우는 정렬 여부에 관계없이 활용

## 7. 2주차 1일차를 마치며...
오늘은 그래도 2시에는 꼭 자야겠다. 문제 풀면서도 너무 피곤했는지 정신을 못차릴 정도록 계속 졸렸다... 오늘 TIL 작성 끝!...