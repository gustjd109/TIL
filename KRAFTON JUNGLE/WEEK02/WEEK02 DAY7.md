# WEEK02 DAY7 TIL
대망의 2주차 알고리즘 테스트 당일!... 두구두구~~ 과연 결과는!?🤔

이번에도 1주차와 동일하게 1솔이다... 어제 편의점에서 산 짱구 마카롱먹고 나온 흰둥이의 시무룩 포스트 카드가 오늘 테스트본 후 나의 기분을 미리 알려준듯 싶다...😭

이번에도 시간과 문제 수는 1시간 30분에 3문제인 5904번 Moo게임 / 16120번 PPAP / 1933번 스카이라인 문제를 푸는 것이었다. 처음에는 세 문제의 내용과 모두 골드 난이도에 정답 비율이 평균 30%대인걸 보고 놀랐다. 하지만, 그래도 한 문제씩 문제의 내용을 차근차근 읽어보면서 규칙 또는 접근방법을 찾아 바로 풀 수 있는 문제를 선택했다.

Moo게임은 규칙을 찾아 점화식까지 만들었지만, 막상 바로 어떻게 구현해야할지 생각이 떠오르질 않아 동일하게 규칙을 찾아낸 PPAP 문제를 풀었다.  

시험이 끝나고 3주차 발제와 점심식사 및 팀 면담을 마치고 Moo게임과 PPAP 문제를 다시 풀어봤다.

## 1. 2주차 알고리즘 테스트 재도전!🔥
- 5994번 Moo게임
    - 문제 풀이 과정
        - 이 문제는 수열에 대한 식을 찾아야 풀 수 있는 문제이다.
        - 문제의 예제를 통해 찾은 점화식은 len(S[K]) = len(S[K - 1]) + (K + 3) + len(S[K - 1]) -> len(S[K]) = 2 * len(S[K - 1]) + (K + 3)이다.
        - 찾은 점화식을 이용하여 재귀함수 호출을 통해 문제를 풀 수 있다.
        - N값이 3보다 작으면, 어짜피 S[0] 수열 내에있는 글자이기 때문에 S[0] 수열의 N - 1번째 글자를 출력해준다.
        - 현재 수열의 길이가 N값보다 작으면, N값이 S[K] 수열의 길이보다 길기 때문에 함수를 재귀호출하여 S[K + 1] 수열을 구한다.
        - 현재 수열의 길이가 N값보다 크면, 해당 수열에서 N번째 글자를 출력할 수 있다.
        - N값이 이전 수열의 길이보다 크고, 이전 수열의 길이 + 차수 + 3의 값보다 작거나 같을 때(즉, 중간값 범위에 N값이 있을 때),
        - 'N값 - 이전 수열의 길이'의 값이 1이 아니라면 'o'를 출력하고, 아니면 'm' 출력한다.
        - N값이 중간값 범위보다 초과하면, len(S[K - 1]) 값에서 값을 다시 찾기 위해 moogame함수를 재귀호출하여 위의 과정을 반복하여 N번째 글자를 찾는다.
    - 소스코드
        ```python
        import sys

        # moogame 함수
        # N : 찾고자하는 N번째 글자 / K : 차수 / L : 이전 수열의 길이
        def moogame(N, K, L):
            # 새로운 차수의 길이
            # 문제에서 주어진 수열을 바탕으로 구해진 점화식 : len(S[K]) = 2 * len(S[K - 1]) + (K + 3)
            new_L = 2 * L + (K + 3)
            # N값이 3이하면, S[0] 수열에 존재하는 글자이기 때문에 S[0] 수열의 N - 1번째 글자 출력
            # 출력 후, 프로그램 종료
            if N <= 3:
                print(S0[N - 1])
                sys.exit(0)
            # 현재 수열의 길이가 N값보다 작으면, N값이 S[K] 수열의 길이보다 길기 때문에 moogame함수를 재귀호출하여 S[K + 1] 수열을 구한다.
            if new_L < N:
                moogame(N, K + 1, new_L)
            # 현재 수열의 길이가 N값보다 크면, 해당 수열에서 N번째 글자를 출력할 수 있기 때문에 아래 코드를 수행
            else:
                # N값이 이전 수열의 길이보다 크고, 이전 수열의 길이 + 차수 + 3의 값보다 작거나 같으면, -> 중간값 범위에 N값이 있을 때
                if N > L and N <= L + K + 3:
                    # 'N값 - 이전 수열의 길이'의 값이 1이 아니라면 'o'를 출력하고, 아니면 'm' 출력
                    # 출력 후, 프로그램 종료
                    if N - L != 1:
                        print('o')
                    else:
                        print('m')
                    sys.exit(0)
                # N값이 중간값 범위보다 초과하면, len(S[K - 1]) 값에서 값을 다시 찾기 위해 moogame함수를 재귀호출
                else:
                    moogame(N - (L + K + 3), 1, 3)

        if __name__ == "__main__":
            N = int(sys.stdin.readline())
            #S[0]의 수열 초기값 설정
            S0 = ['m', 'o', 'o']
            # moogame함수 호출
            print(moogame(N, 1, 3))

- 16120번 PPAP
    - 문제 풀이 과정
        - 이 문제는 입력받은 문자열이 'P' 또는 'PPAP'이면 PPAP문자열로 판단하여 'PPAP'를 출력하고,
        - 아니면 아래 과정을 반복하여 결과값을 얻는다.
        - 입력받은 문자열의 각 원소를 탐색하면서 스택에 원소를 하나씩 삽입시킨다.
        - 삽입한 후, 스택에 저장된 마지막 값부터 -4번째 값까지 검색하여 'PPAP' 문자열이 존재하면
        - 스택에서 제일 앞의 'P'를 제외한 나머지 문자열인 'PAP'를 삭제한다.
        - 이렇게 하면, 'PPAP'문자열을 'P'로 변환한 것과 같은 효과를 볼 수 있다.
        - 문자열의 모든 원소에 대해 탐색이 종료되면, 스택에 남은 값을 확인하다.
        - 확인했을 때, 'P' 또는 'PPAP'가 남아있으면 'PPAP'를 출력하고, 아니면 'NP'를 출력한다.
    - 소스코드
        ```python
        import sys

        S = sys.stdin.readline().strip()

        # 입력받은 문자열 S가 P 또는 PPAP인 경우, PPAP문자열로 판단하여 'PPAP' 출력
        if S == 'P' or S == 'PPAP':
            print('PPAP')
        # 입력받은 문자열 S가 P 또는 PPAP 둘 다 아닌 경우
        else:
            stack = []
            PPAP = ['P', 'P', 'A', 'P']
            # 문자열 S의 각 원소 탐색
            for i in S:
                # 스택에 문자열 S의 i원소 삽입
                stack.append(i)
                # 만약 스택에 저장된 마지막 값부터 -4번째 값까지 PPAP 문자열이 존재하면
                if stack[-4:] == PPAP:
                    # 스택에서 P를 제외한 3개 원소인 'P', 'A', 'P' 삭제
                    stack.pop()
                    stack.pop()
                    stack.pop()

            # 문자열 S의 모든 원소의 탐색을 끝낸 후, 
            # 스택에 남은 값이 'P' 또는 'PPAP'이면 'PPAP' 출력하고, 아니면 'NP' 출력
            if stack == ['P'] or stack == PPAP:
                print('PPAP')
            else:
                print('NP')

- 1933번 스카이라인
    -   이 문제는 아직 풀지 못했다... 꼭 풀어서 내용 업데이트 할 수 있도록!

## 2. 2주차 7일차를 마치며...
오늘로서 2주차도 끝이 났다. 항상 느끼는거지만, 시간이 정말 빠르게 지나가는거 같다(어제가 일요일 같은데...⌛️).

1주차 알고리즘 테스트를 끝내고 세 가지 부족한 점을 찾았었다.
이런 부족한 점을 보완하기 위해 2주차에는 어떤 유형의 문제를 풀기 전에 꼭 해당 유형에 대한 공부를 먼저 시작했다.
문제를 항상 꼼꼼하게 읽고, 조건도 노트에 정리하면서 확실하게 숙지한 후에 규칙을 찾기 위한 시도를 다양하게 시도해보면서 풀었다.
그 결과, 전보다는 조금 더 문제를 잘 이해할 수 있게 되었고 아직 오래걸리지만 규칙도 어느정도 찾아내는 것 같다.

하지만, 아직 구현하는 능력에서는 많이 떨어지는 것 같아서 좀 아쉽다(이게 나에게 가장 걱정되는 문제다...😳).
구현 능력은 많은 문제를 풀어보면서 익숙해져야지 어느정도 가능할 것 같다는 생각이 들어서 우선 주어진 문제를 열심히 풀어볼 생각이다.
하면서 또 좋은 공부 방법이나 나에게 맞는 방법을 찾아내서 좀 더 효율적으로 공부하고 실력을 쌓을 수 있었으면 좋겠다.

내일부터 3주차가 다시 시작된다, 블루팀 모두 화이팅!👊