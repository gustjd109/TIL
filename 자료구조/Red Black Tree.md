# 레드 블랙 트리(Red-Black Tree)

## 1. 레드 블랙 트리(Red-Black Tree)
- 레드 블랙 트리란?
    - 이진 탐색 트리(Binary Search Tree)의 한 종류
        - 각 노드에서 자신보다 작은 값들은 노드의 왼쪽 서브 트리로 큰 값들은 오른쪽 서브 트리에 존재하는 특징을 만족하는 이진 트리
    - 스스로 균형을 잡는 트리라는 특징을 가짐
        - 이진 탐색 트리의 최악의 경우(worst case)의 단점을 개선할 수 있음
            - 예를 들어, 이진 탐색 트리의 노드가 한쪽으로 편향되어 있을 경우의 삽입, 삭제 시간 복잡도는 O(N)이 됨
            - 즉, 이진 탐색 트리에 있는 노드를 모두 한번씩 탐색하는 경우임
            - 레드 블랙 트리는 스스로 균형을 잡는 트리의 특징을 통해 트리가 편향된 구조가 되지 않도록 함으로서 최악의 경우에도 시간 복잡도가 O(log N)이 되도록 하여 이진 탐색 트리의 단점을 개선시킬 수 있음

## 2. 레드 블랙 트리의 속성
- 속성 1 : 모든 노드는 red 혹은 black
- 속성 2 : 루트 노드는 black
- 속성 3 : 모든 nil(leaf) 노드는 black
    - nil 노드란?
        - 레드 블랙 트리에만 존재하는 독특한 개념
        - 존재하지 않음을 의미하는 노드
        - 자녀가 없을 때 자녀를 nil 노드로 표기
        - 값이 있는 노드와 동등하게 취급
        - 레드 블랙 트리에서 leaf 노드는 nil 노드
- 속성 4 : red의 자녀들은 black(즉, red가 연속적으로 존재할 수 없음)
- 속성 5 : 임의의 노드에서 자손 nil 노드들까지 가는 경로들의 black 수는 같음(자기 자신은 카운트에서 제외)
    - 노드 x의 black height
        - 노드 x에서 임의의 자손 nil 노드까지 내려가는 경로에서의 black 수(자기 자신은 카운트에서 제외)
        - 속성 5를 만족해야 성립하는 개념
    - 색을 바꾸면서 속성 5를 유지하는 방법
        - 레드 블랙 트리가 속성 5를 만족하고, 두 자녀가 같은 색을 가질 때 부모와 두 자녀의 색을 바꿔줘도 속성 5는 여전히 만족
            - 부모 노드 입장에서, 바뀌기 전의 부모 노드로부터 자손 nil 노드까지 내려가는 경로에서의 black 수와 바뀌고 난 후의 부모 노드로부터 자손 nil 노드까지 내려가는 경로에서의 black 수는 동일

## 3. 레드 블랙 트리는 어떻게 균형을 잡는가?
- 삽입, 삭제 시 주로 속성 4와 5를 위반하며, 이들을 해결하려고 구조를 바꾸다 보면 자연스럽게 트리의 균형이 잡히게 됨

## 4. 레드 블랙 트리의 삽입
- 삽입의 전체적인 과정
    - 과정 0 : 삽입 전, 레드 블랙 트리 속성을 만족한 상태
    - 과정 1 : 삽입 방식은 일반적인 이진 검색 트리와 동일
    - 과정 2 : 삽입 후, 레드 블랙 트리 위반 여부 확인
    - 과정 3 : 레드 블랙 트리 속성을 위반했다면 재조정
    - 과정 4 : 레드 블랙 트리 속성을 다시 만족
- 삽입 과정
    - 삽입 노드의 색은 항상 red
        - 새로 삽입하는 노드가 red인 이유는 삽입 후에도 속성 5를 만족하기 위함
    - 노드를 삽입할 때, 두 nil 노드의 색은 black으로 고정
        - 속성 3 만족하기 위함
- 삽입 과정에서 발생하는 속성 위반 여부 및 각 CASE별 해결 방법
    - CASE 1 : 속성 2 위반
        - 해결 방법
            - 루트 노드를 black으로 변경
    - CASE 2 : 속성 4 위반 1
        - red가 한쪽으로 몰려 있는 경우
        - 해결 방법
            - red 하나를 반대편으로 이동
            - 이때, 이진 탐색 트리의 특징 또한 유지하면서 넘겨야 함(각 노드에서 자신보다 작은 값들은 노드의 왼쪽 서브 트리로 큰 값들은 오른쪽 서브 트리에 존재하는 특징)
            - 이진 탐색 트리의 특징을 유지시키는 방법으로 회전을 사용
            - 삽입된 red 노드가 부모의 왼쪽 자녀 & 부모도 red고 할아버지의 왼쪽 자녀 & 삼촌(=부모의 형제)은 black이라면, 부모와 할아버지의 색을 바꾼 후 할아버지를 기준으로 오른쪽으로 회전
    - CASE 3 : 속성 4 위반 2
        - CASE 2와 다른 점은 삽입된 노드를 기준으로 할아버지까지의 경로가 꺾였다는 점
        - 해결 방법
            - 꺾인 부분을 펴줘서 CASE 2와 같은 형태로 만들면, CASE 2과 같은 방식으로 해결 가능
            - 삽입된 red 노드가 부모의 오른쪽* 자녀 & 부모도 red고 할아버지의 왼쪽* 자녀 & 삼촌(=부모의 형제)은 black이라면, 부모를 기준으로 왼쪽*으로 회전한 뒤 CASE 3의 방식으로 해결
                - 오른쪽 왼쪽을 바꿔도 성립
    - CASE 4 : 속성 4 위반 3
        - red가 한쪽으로 몰려 있지 않은 경우로 노드를 옮길 수 없음
        - 해결 방법
            - 삽입된 red 노드의 부모도 red & 삼촌(=부모의 형제)도 red라면, 부모와 삼촌(=부모의 형제)을 black으로 바꾸고 할아버지를 red로 바꾼 뒤 할아버지에서 다시 확인을 시작

## 5. 레드 블랙 트리의 삭제
- 삭제의 전체적인 과정
    - 과정 0 : 삭제 전, 레드 블랙 트리 속성을 만족한 상태
    - 과정 1 : 삭제 방식은 일반적인 이진 검색 트리와 동일
    - 과정 2 : 삭제 후, 레드 블랙 트리 위반 여부 확인
    - 과정 3 : 레드 블랙 트리 속성을 위반했다면 재조정
    - 과정 4 : 레드 블랙 트리 속성을 다시 만족
- 삭제 과정에서 발생하는 속성 위반 여부를 확인하는 방법
    - 레드 블랙 트리에서 노드를 삭제할 때 어떤 색이 삭제되는지가 속성 위반 여부를 확인할 때 매우 중요
    - 삭제되는 색
        - 삭제하려는 노드의 *자녀(유효한 값을 가지는 자녀)가 없거나 하나인 경우
            - 삭제되는 색 = 삭제되는 노드의 색
        - 삭제하려는 노드의 *자녀(유효한 값을 가지는 자녀)가 둘인 경우
            - 삭제되는 색 = 삭제되는 노드의 succesor의 색
                - Successor란?
                    - 선택한 노드의 오른쪽 서브 트리 중에서 가장 작은 값을 가지는 노드를 의미
                    - 선택한 노드보다 크면서 제일 작은값
                - Predecessor란?
                    - 선택한 노드의 왼쪽 서브 트리 중에서 가장 큰 값을 가지는 노드를 의미
                    - 선택한 노드보다 작으면서 제일 큰 값
        - 삭제되는 색이 red라면, 어떠한 속성도 위반하지 않음
        - 삭제되는 색이 black이라면, 속성 2, 4, 5를 위반할 수 있음
            - 특수한 상황을 제외하면, 속성 5를 항상 위반하게 됨
- 삭제 과정에서 발생하는 속성 위반 여부 및 각 CASE별 해결 방법
    - CASE 1 : 속성 2 위반
        - 해결 방법
            - 루트 노드를 black으로 변경
    - CASE 2 : 삭제되는 색이 black이고 속성 5 위반
        - 해결 방법
            - 속성을 다시 만족시키기 위해 삭제된 색의 위치를 대체한 노드에 extra black을 부여
                - extra black의 역할
                    - 경로에서 black 수를 카운트할 때 extra black은 하나의 black으로 카운트 됨
                - 색이 black인 노드를 삭제했을 때 자녀가 없으면 삭제된 위치를 대체할 노드는 nil 노드이며, nil 노드에 extra black을 부여
                    - doubly black : extra black이 부여된 black 노드
                - 색이 black인 노드를 삭제했을 때 자녀의 색이 red이면, red 노드에 extra black을 부여
                    - red-and-black : extra black이 부여된 red 노드
        - extra black을 부여한 후, red-and-black을 해결하는 방법
            - red-and-black을 black으로 변경
        - extra black을 부여한 후, 생성된 doubly black 노드를 없애는 방법
            - 총 네 가지 CASE로 분류(분류 기준 : doubly black의 형제의 색과 그 형제의 자녀들의 색)
                - CASE 1 : doubly black의 오른쪽* 형제가 black & 그 형제의 오른쪽* 자녀가 red인 경우
                    - 그 red를 doubly black 위로 옮기고, 옮긴 red로 extra black을 전달해서 red-and-black으로 만든 다음 red-and-black을 black으로 변경
                    - 즉, 오른쪽* 형제는 부모의 색으로, 오른쪽* 형제의 오른쪽* 자녀는 black으로, 부모는 black으로 바꾼 후에 부모를 기준으로 왼쪽으로 회전
                        - 오른쪽 왼쪽을 바꿔도 성립
                - CASE 2 : doubly black의 오른쪽* 형제가 black & 그 형제의 왼쪽* 자녀가 red & 그 형제의 오른쪽 자녀가 black인 경우
                    - doubly black의 오른쪽* 형제와 그 형제의 왼쪽* 자녀외 색을 바꾼 후에 부모를 기준으로 오른쪽* 회전한 후에 CASE 1을 적용
                    - 즉, doubly black의 형제의 오른쪽* 자녀를 red가 되게 만들어서 이후엔 CASE 1을 젹용
                        - 오른쪽 왼쪽을 바꿔도 성립
                - CASE 3 : doubly black의 형제가 black & 그 형제의 두 자녀 모두 black인 경우
                    - doubly black과 그 형제의 black을 모아서 부모에게 전달하여 부모가 extra black을 해결하도록 위임
                        - doubly black은 black이 되고, 그 형제는 red가 됨
                        - black을 전달받은 부모는 red-and-black 혹은 doubly black이 됨
                    - 부모가 red-and-black이 된 경우, black으로 변경하여 해결
                    - 부모가 doubly black이 된 경우, 부모가 루트노드라면 black으로 변경하여 해결하고, 아니라면 CASE 1 ~ 4중에 하나로 해결
                - CASE 4 : doubly black의 형제가 red인 경우
                    - doubly black의 형제를 black으로 만든 후, CASE 1, 2, 3 중에 하나로 해결
                    - doubly black의 부모를 기준으로 왼쪽*으로 회전하면, doubly black의 형제는 black이 됨
                    - 회전 후에도 속성 5를 만족하려면, 왼쪽*으로 회전하기 전에 doubly black의 부모와 doubly black의 형제의 색을 미리 변경시켜 줘야 함
                    - 회전 후, doubly black의 형제는 black이 됐으므로 CASE 1, 2, 3 중에 하나로 해결
                        - 오른쪽 왼쪽을 바꿔도 성립
            - 전체적으로 정리를 해보자면, 삭제되는 색이 black일 때 삭제되는 색이 있던 위치를 대체한 노드에 extra black을 부여한다. 대체한 노드가 red-and-black이 됐다면 black으로 바꿔주어 해결하고, 대체한 노드가 doubly black이 됐다면 CASE 1, 2, 3, 4 중에 하나로 해결한다.

## 6. 레드 블랙 트리의 시간복잡도
- 레드 블랙 트리의 삽입, 삭제, 검색의 평균과 최악의 시간 복잡도는 O(log N)으로 동일
    - N = 트리의 노드 수

## 7. 레드 블랙 트리와 균형 이진 탐색 트리와의 차이
- 이진 탐색 트리 여부
    - 레드 블랙 트리 : O
    - 균형 이진 탐색 트리 : O
- 삽입, 삭제, 검색의 시간 복잡도
    - 레드 블랙 트리 : worst case에서도 O(log N)
    - 균형 이진 탐색 트리 : worst case에서도 O(log N)
- 삽입, 삭제 성능
    - 레드 블랙 트리 : 균형 이진 탐색 트리에 비해 빠름
    - 균형 이진 탐색 트리 : 레드 블랙 트리에 비해 느림
        - 삽입, 삭제 후, 루트 노드까지 올라가면서 balance factor를 확인하고, balance factor가 조건을 만족하지 않으면 구조를 바꾸줌
        - 따라서, 균형을 더 엄격하게 잡기 때문에 삽입, 삭제할 때마다 시간적 비용이 레드 블랙 트리보다 더 많이 소요되기 때문임
- 검색 기능
    - 레드 블랙 트리 : 균형 이진 탐색 트리에 비해 느림
    - 균형 이진 탐색 트리 : 레드 블랙 트리에 비해 빠름
        - 시간 복잡도는 동일하지만, 균형을 좀 더 엄격하게 잡기 때문에 레드 블랙 트리보다 더 나은 규형을 가지기 때문임
- 균형 잡는 방식
    - 레드 블랙 트리 : 레드 블랙 트리의 속성을 만족시키도록 균형을 잡음
    - 균형 이진 탐색 트리 : balance factor가 {-1, 0, 1}이 되도록 균형을 잡음
- 응용 사례
    - 레드 블랙 트리 : linux kernel 내부에서 사용 / Java TreeMap 구현 / C++ std::map 구현 등
    - 균형 이진 탐색 트리 : dictionary / 한번 만들어 놓으면 삽입, 삭제가 거의 없고 검색이 대부분인 상황에서 사용

## 8. 레드 블랙 트리 전체 정리 이미지
<img src="/Users/hyunsunghwang/Desktop/GitHub/TIL/자료구조/Red Black Tree.JPG">