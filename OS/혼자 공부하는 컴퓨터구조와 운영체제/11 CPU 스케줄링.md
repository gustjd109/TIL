# 11 CPU 스케줄링

## 1. CPU 스케줄링 개요
1. 프로세스 우선순위
    - CPU 스케줄링이란?
        - 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것<br><br>

    - CPU 버스트와 입출력 버스트
        - CPU 버스트(CPU burst) : CPU를 이용하는 작업
        - 입출력 버스트(I/O burst) : 입출력장치를 기다리는 작업
        - 프로세스는 CPU 버스트와 입출력 버스트를 반복하며 실행됨<br><br>

    - 입출력 집중 프로세스와 CPU 집중 프로세스
        - 입출력 집중 프로세스(I/O bound process)
            - 입출력 버스트가 많은 프로세스
            - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무름
        - CPU 집중 프로세스(CPU bound process)
            - CPU 버스트가 많은 프로세스
            - 대기 상태보다 실행 상태에 더 많이 머무름
        - 입출력 집중 프로세스가 CPU 집중 프로세스보다 우선순위가 높은 이유
            - 입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어짜피 대기 상태가 될 예정
            - 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있음<br><br>

2. 스케줄링 큐(scheduling queue)
    - 스케줄링 큐란?
        - CPU를 사용할 다음 프로세스를 찾기 위해 모든 프로세스의 PCB를 확인하는 것은 비효율적이므로 각 자원을 사용하고 싶어하는 프로세스들을 줄세워 관리하는 것<br><br>

    - 운영체제가 관리하는 큐의 종류
        - 준비 큐(ready queue)
            - CPU를 이용하고 싶은 프로세스들이 서는 줄
            - 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다림
            - 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행
        - 대기 큐(waiting queue)
            - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
            - 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다림
            - 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 검색
            - 찾은 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거하고 준비 큐로 이동<br><br>

    - 선점형과 비선점형 스케줄링
        - 선점형 스케줄링(preemptive scheduling)
            - 프로세스가 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
            - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 배분할 수 있음
            - 문맥 교환 과정에서 오버헤드가 발생할 수 있음
        - 비선점형 스케줄링(non-preemptive scheduling)
            - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식
            - 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드가 적음
            - 모든 프로세스가 골고루 자원을 사용할 수 없음<br><br>

## 2. CPU 스케줄링 알고리즘
1. 스케줄링 알고리즘의 종류
    - 선입 선처리 스케줄링(FCFS, First Come First Served Scheduling)
        - CPU를 먼저 요청한 프로세스부터 CPU를 할당하여 처리하는 비선점형 스케줄링 방식
        - CPU를 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 그 프로세스가 CPU를 사용하는 동안 무작정 기다리는 호위 효과(convoy effect) 현상이 발생<br><br>

    - 최단 작업 우선 스케줄링(SJF, Shortest Job First Scheduling)
        - CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식
        - 기본적으로 비선점형 스케줄링 알고리즘이지만, 선점형으로도 구현 가능<br><br>

    - 라운드 로빈 스케줄링(RR, Round Robin Scheduling)
        - 선입 선처리 스케줄링에 각 프로세스가 CPU를 사용할 수 있는 정해진 시간인 타임 슬라이스라는 개념이 더해진 스케줄링 방식
        - 타임 슬라이스가 지나치게 크면 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 수 있고, 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데 온 힘을 다 쓸 여지가 있음<br><br>

    - 최소 잔여 시간 우선 스케줄링(SRT, Shorted Remaining Time)
        - 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식
        - 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택<br><br>

    - 우선순위 스케줄링(Priority Scheduling)
        - 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 알고리즘
        - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링됨
        - 우선순위가 낮은 프로세스의 실행이 계속해서 연기될 수 있음 = 기아(starvation) 현상
        - 기아 현상을 방지하기 위한 에이징(aging) 기법을 사용
            - 오래 대기한 프로세스의 우선순위를 점차 높이는 방식<br><br>

    - 다단계 큐 스케줄링(multilevel queue scheduling)
        - 우선순위 스케줄링의 발전된 형태로, 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
        - 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리
        - 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리
        - 큐별로 타임 슬라이스를 여러 개 지정할 수도, 다른 스케줄링 알고리즘을 사용할 수도 있음
        - 프로세스들이 큐 사이를 이동할 수 없어 기아 현상이 발생할 수 있음<br><br>

    - 다단계 피드백 큐 스케줄링(multilevel feedback queue scheduling)
        - 다단계 큐 스케줄링의 발전된 형태로, 프로세스들이 큐 사이를 이동할 수 있는 스케줄링 방식
        - 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행
            - 실행한 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행되는 과정을 수행
            - CPU를 오래 사용해야 하는 CPU 집중 프로세스들은 우선순위가 낮아지고, CPU를 적게 사용하는 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행
        - 자연스럽게 에이징 기법을 적용하여 기아 현상을 예방
        - 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘
        - 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘