# PROJECT3 : VIRTUAL MEMORY

## 1. PROJECT3(VIRTUAL MEMORY) GitBook Contents
### Introduction
#### Project3: Virtual Memory
- 지금까지 핀토스의 내부 작동 방식에 어느 정도 익숙해졌을 것입니다. OS는 적절한 동기화를 통해 여러 스레드의 실행을 적절히 처리할 수 있으며, 여러 사용자 프로그램을 한 번에 로드할 수 있습니다. 그러나, 실행할 수 있는 프로그램의 수와 크기는 시스템의 기본 메모리 크기에 따라 제한됩니다. 이 과제에서는 무한 메모리의 환영을 구축하여 이러한 제한을 제거합니다.
- 이 과제는 지난 과제 위에 구축됩니다. 프로젝트 2의 테스트 프로그램은 프로젝트 3에서도 작동해야 합니다. 프로젝트 2에서 발생하는 버그는 프로젝트 3에서도 동일한 문제를 일으킬 가능성이 높으므로, 프로젝트 3 작업을 시작하기 전에 프로젝트 2의 모든 버그를 수정해야 합니다.
- 프로젝트 3의 경우, 우리는 당신의 편의를 위해 단계별로 방향을 제시합니다.

### Background
#### 소스 파일(Source Files)
- 이 프로젝트의 vm 디렉토리에서 작업하게 됩니다. Makefile이 업데이트되어 -DVM 설정을 켭니다. 우리는 엄청난 양의 템플릿 코드를 제공합니다. 반드시 주어진 템플릿을 따라야 합니다. 즉, 주어진 템플릿을 기반으로 하지 않는 코드를 제출하면 0점을 받습니다. 또한, 'DO NOT CHANGE'라고 표시된 템플릿은 절대로 변경해서는 안 됩니다. 여기에서는 수정할 각 템플릿 파일에 대한 몇 가지 세부 정보를 제공합니다.
    - include/vm/vm.h, vm/vm.c
        - 가상 메모리를 위한 일반 인터페이스를 제공합니다. 헤더 파일에서 가상 메모리 시스템이 지원해야 하는 다양한 vm_type(VM_UNINIT, VM_ANON, VM_FILE, VM_PAGE_CACHE)에 대한 정의와 설명을 확인할 수 있습니다(VM_PAGE_CACHE는 프로젝트 4용이므로 지금은 무시하세요). 여기에서 supplemental page table도 구현합니다(아래 참조).
    - include/vm/uninit.h, vm/uninit.c
        - 초기화되지 않은 페이지에 대한 작업을 제공합니다(vm_type = VM_UNINIT). 현재 설계에서는 초기에 초기화되지 않은 페이지로 설정된 후 익명 페이지 또는 파일 지원 페이지로 변환됩니다.
    - include/vm/anon.h, vm/anon.c
        - 익명 페이지에 대한 작업을 제공합니다(vm_type = VM_ANON).
    - include/vm/file.h, vm/file.c
        - 파일 지원 페이지에 대한 작업을 제공합니다(vm_type = VM_FILE).
    - include/vm/inspect.h, vm/inspect.c
        - 채점을 위한 메모리 검사 작업이 포함되어 있습니다. 이 파일을 변경하지 마십시오.<br><br>
- 이 프로젝트에 대해 작성하는 대부분의 코드는 vm 디렉토리에 있는 파일과 이전 프로젝트에서 소개한 파일에 포함됩니다. 다음과 같은 몇 개의 파일만 처음 접하게 될 것입니다.
    - include/devices/block.h, devices/block.c
        - 블록 장치에 대한 섹터 기반 읽기 및 쓰기 액세스를 제공합니다. 이 인터페이스를 사용하여 블록 장치로 스왑 파티션에 액세스합니다.
#### 메모리 용어(Memory Terminology)
- 먼저 메모리와 스토리지에 대한 몇 가지 용어를 소개합니다. 이 용어 중 일부는 프로젝트 2(가상 메모리 레이아웃 참조 : https://casys-kaist.github.io/pintos-kaist/project2/introduction.html)에서 익숙한 것이지만 대부분은 새로운 용어입니다.
1. 페이지(Pages)
    - 가상 페이지라고도 하는 페이지는 길이가 4,096바이트(페이지 크기)인 가상 메모리의 연속적인 영역입니다. 페이지는 페이지 정렬, 즉 페이지 크기로 균등하게 나눌 수 있는 가상 주소에서 시작해야 합니다. 따라서 64비트 가상 주소의 마지막 12비트는 페이지 오프셋(또는 그냥 오프셋)입니다. 상위 비트는 곧 소개될 페이지 테이블의 인덱스를 나타내는 데 사용됩니다. 64비트 시스템에서는 4단계 페이지 테이블을 사용하여 가상 주소를 다음과 같이 만듭니다 :
        ```
        63          48 47            39 38            30 29            21 20         12 11          0
        +-------------+----------------+----------------+----------------+-------------+------------+
        | Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
        |             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
        +-------------+----------------+----------------+----------------+-------------+------------+
                      |                |                |                |             |            |
                      +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                                  Virtual Address
        ```
    - 각 프로세스에는 독립적인 사용자(가상) 페이지 집합이 있으며, 이 페이지는 가상 주소 KERN_BASE(0x8004000000) 아래에 있는 페이지입니다. 반면, 커널(가상) 페이지 집합은 전역이므로 실행 중인 스레드나 프로세스에 관계없이 동일한 위치에 유지됩니다. 커널은 사용자 페이지와 커널 페이지에 모두 액세스할 수 있지만, 사용자 프로세스는 자신의 사용자 페이지에만 액세스할 수 있습니다. 자세한 내용은 가상 메모리 레이아웃(https://casys-kaist.github.io/pintos-kaist/project2/introduction.html)을 참조하십시오.
    - 핀토스는 가상 주소 작업에 유용한 몇 가지 기능을 제공합니다. 자세한 내용은 가상 주소(https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html) 섹션을 참조하십시오.<br><br>
2. 프레임(Frames)
    - 물리적 프레임 또는 페이지 프레임이라고도 하는 프레임은 물리적 메모리의 연속적인 영역입니다. 페이지와 마찬가지로 프레임도 페이지 크기와 페이지 정렬이 맞아야 합니다. 따라서, 64비트 물리적 주소는 다음과 같이 프레임 번호와 프레임 오프셋(또는 그냥 오프셋)으로 나눌 수 있습니다 :
        ```
                              12 11         0
        +-----------------------+-----------+
        |      Frame Number     |   Offset  |
        +-----------------------+-----------+
                  Physical Address
        ```
    - x86-64는 물리적 주소에서 메모리에 직접 액세스할 수 있는 방법을 제공하지 않습니다. 핀토스는 커널 가상 메모리를 물리적 메모리에 직접 매핑하여 이 문제를 해결합니다. 커널 가상 메모리의 첫 번째 페이지는 물리적 메모리의 첫 번째 프레임에 매핑되고, 두 번째 페이지는 두 번째 프레임에 매핑되는 식입니다. 따라서, 커널 가상 메모리를 통해 프레임에 액세스할 수 있습니다.<br><br>
3. 페이지 테이블(Page Tables)
    - 페이지 테이블은 CPU가 가상 주소를 물리적 주소, 즉 페이지에서 프레임으로 변환하는 데 사용하는 데이터 구조입니다. 페이지 테이블 형식은 x86-64 아키텍처에 따라 결정됩니다. 핀토스는 threads/mmu.c에서 페이지 테이블 관리 코드를 제공합니다.
    - 아래 다이어그램은 페이지와 프레임 간의 관계를 보여줍니다. 왼쪽의 가상 주소는 페이지 번호와 오프셋으로 구성됩니다. 페이지 테이블은 페이지 번호를 프레임 번호로 변환하고, 수정되지 않은 오프셋과 결합하여 오른쪽의 물리적 주소를 얻습니다.
        ```
                              +----------+
             .--------------->|Page Table|-----------.
            /                 +----------+           |
            |   12 11  0                             V   12 11  0
        +---------+----+                         +---------+----+
        | Page Nr | Ofs|                         |Frame Nr | Ofs|
        +---------+----+                         +---------+----+
         Virt Addr   |                            Phys Addr    ^
                      \_______________________________________/
        ```
4. 스왑 슬롯(Swap Slots)
    - 스왑 슬롯은 스왑 파티션에 있는 디스크 공간의 페이지 크기 영역입니다. 슬롯 배치를 결정하는 하드웨어 제한이 프레임보다 더 유연하지만, 스왑 슬롯은 페이지 정렬을 수행하는 데 단점이 없으므로 이를 수행해야 합니다.
#### 리소스 관리 개요(Resource Management Overview)
- 다음 데이터 구조를 설계/구현해야 합니다 :
    1. 부가 페이지 테이블(Supplemental page table)
        - 페이지 테이블을 보완하여 page fault 처리를 가능하게 합니다. 아래의 supplemental page table 관리를 참조하십시오.
    2. 프레임 테이블(Frame table)
        - 물리적 프레임의 eviction 정책을 효율적으로 구현할 수 있습니다. 아래의 프레임 테이블 관리를 참조하십시오.
    3. 스왑 테이블(Swap table)
        - 스왑 슬롯의 사용량을 추적합니다. 아래의 스왑 테이블 관리를 참조하십시오.<br><br>
- 완전히 다른 세 가지 데이터 구조를 구현할 필요는 없습니다 : 관련 리소스를 전체 또는 부분적으로 통합 데이터 구조로 병합하는 것이 편리할 수 있습니다.
- 각 데이터 구조에 대해 각 요소가 포함해야 하는 정보를 결정해야 합니다. 또한 데이터 구조의 범위를 로컬(프로세스별) 또는 전역(전체 시스템에 적용)으로 결정하고, 해당 범위 내에서 필요한 인스턴스 수를 결정해야 합니다.
- 설계를 단순화하기 위해 이러한 데이터 구조를 페이지화할 수 없는 메모리(예 : calloc 또는 malloc으로 할당된 메모리)에 저장할 수 있습니다. 즉, 그들 사이의 포인터가 유효한 상태로 유지된다는 것을 확신할 수 있습니다.<br><br>
1. 성능 관점에서의 구현 선택사항(Choices of implementation(Performance perspective))
    - 구현할 수 있는 선택 사항에는 배열, 리스트, 비트맵 및 해시 테이블이 있습니다. 배열은 종종 가장 간단한 접근 방식이지만, 드물게 채워진 배열은 메모리를 낭비합니다. 리스트도 간단하지만, 특정 위치를 찾기 위해 긴 리스트를 탐색하는 것은 시간 낭비입니다. 배열과 리스트 모두 크기를 조정할 수 있지만, 리스트는 중간에 삽입 및 삭제를 더 효율적으로 지원합니다.
    - 핀토스는 lib/kenel/bitmap.c와 include/lib/kenel/bitmap.h에 비트맵 데이터 구조를 포함하고 있습니다. 비트맵은 각각 참 또는 거짓이 될 수 있는 비트의 배열입니다. 비트맵은 일반적으로 (동일한) 리소스 집합에서 사용량을 추적하는 데 사용됩니다 : 리소스 n이 사용 중이면 비트맵의 비트 n이 참입니다. 핀토스 비트맵은 크기가 고정되어 있지만, 크기 조정을 지원하도록 구현을 확장할 수 있습니다.
    - 핀토스에는 해시 테이블 데이터 구조도 포함되어 있습니다(해시 테이블(https://casys-kaist.github.io/pintos-kaist/appendix/hash_table.html) 참조). 핀토스 해시 테이블은 다양한 테이블 크기에 걸쳐 삽입과 삭제를 효율적으로 지원합니다.
    - 데이터 구조가 복잡할수록 더 나은 성능이나 기타 이점을 얻을 수 있지만, 구현이 불필요하게 복잡해질 수도 있습니다. 따라서, 설계의 일부로 고급 데이터 구조(예: 균형 잡힌 이진 트리)를 구현하는 것은 권장하지 않습니다.

#### 부가 페이지 테이블 관리(Managing the Supplemental Page Table)
- supplemental page table은 각 페이지에 대한 추가 데이터로 페이지 테이블을 보완합니다. 페이지 테이블의 형식에 따른 제한 때문에 필요합니다. 이러한 데이터 구조는 종종 '페이지 테이블'이라고도 불리며, 혼동을 줄이기 위해 '추가'이라는 단어를 추가합니다.
- supplemental page table은 적어도 두 가지 용도로 사용됩니다. 가장 중요한 것은 page fault 시, 커널이 supplemental page table에서 fault가 발생한 가상 페이지를 조회하여 어떤 데이터가 있어야 하는지 알아내는 것입니다. 둘째, 커널은 프로세스가 종료될 때 supplemental page table을 참조하여 해제할 리소스를 결정합니다.<br><br>
1. 부가 페이지 테이블 구성(Organization of Supplemental Page Table)
    - 원하는 대로 supplemental page table을 구성할 수 있습니다. 구성에는 최소한 두 가지 기본 접근 방식이 있습니다 : 세그먼트 또는 페이지 측면에서 구성할 수 있다. 여기서 세그먼트는 연속된 페이지 그룹, 즉 실행 파일 또는 메모리 매핑 파일이 포함된 메모리 영역을 의미합니다.
    - 선택 사항으로 페이지 테이블을 자체를 사용하여 supplemental page table의 멤버을 추적할 수 있습니다. 그렇게 하려면, threads/mmu.c에서 핀토스 페이지 테이블 구현을 수정해야 합니다. 이 접근 방식은 고급 학생에게만 권장합니다.<br><br>
2. 페이지 폴트 처리(Handling page fault)
    - supplemental page table을 사용하는 데 있어서 가장 중요한 것은 page fault 처리입니다. 프로젝트 2에서 page fault는 항상 커널 또는 사용자 프로그램의 버그를 의미했습니다. 프로젝트 3에서는 더 이상 그렇지 않습니다. 이제 페이지 오류는 파일 또는 스왑 슬롯에서 페이지를 가져와야 한다는 것을 나타낼 수 있습니다. 이러한 경우를 처리하려면, 보다 정교한 page fault handler를 구현해야 합니다. userprog/exception.c의 page_fault()인 page fault handler는 vm/vm.c의 page fault handler인 vm_try_handle_fault()를 호출합니다. page fault handler는 대략 다음과 같은 작업을 수행해야 합니다 :
        1. supplemental page table에서 오류가 발생한 페이지를 찾습니다. 메모리 참조가 유효한 경우 supplemental page table 항목을 사용하여 파일 시스템이나, 스왑 슬롯에 있거나 단순히 0 페이지일 수 있는 페이지에 있는 데이터를 찾습니다. 공유(예 : Copy-on-Write)를 구현하는 경우, 페이지의 데이터가 이미 페이지 프레임에 있지만 페이지 테이블에는 없을 수도 있습니다. supplemental page table에 사용자 프로세스가 액세스하려는 주소에 데이터가 없거나, 페이지가 커널 가상 메모리 내에 있거나, 액세스가 읽기 전용 페이지에 쓰려는 시도인 경우 액세스가 유효하지 않다고 표시되어 있으면 해당 액세스는 유효하지 않습니다. 유효하지 않은 액세스는 프로세스를 종료하여 모든 리소스를 해제합니다.
        2. 페이지를 저장할 프레임을 얻습니다. 공유를 구현하는 경우 필요한 데이터가 이미 프레임에 있을 수 있으며, 이 경우 해당 프레임을 찾을 수 있어야 합니다.
        3. 파일 시스템 또는 스왑에서 데이터를 읽거나, 제로화하는 등의 방식으로 데이터를 프레임으로 가져옵니다. 공유를 구현하는 경우 필요한 페이지가 이미 프레임에 있을 수 있으며, 이 경우 이 단계에서 조치가 필요하지 않습니다.
        4. 결함이 있는 가상 주소에 대한 페이지 테이블 항목이 물리적 페이지를 가리키도록 합니다. threads/mmu.c에서 함수를 사용할 수 있습니다.

#### 프레임 테이블 관리(Managing the Frame Table)
- 프레임 테이블에는 각 프레임에 대해 하나의 엔트리가 포함됩니다. 프레임 테이블의 각 엔트리에는 현재 해당 항목을 차지하고 있는 페이지에 대한 포인터(있는 경우)와 당신의 선택에 따라 넣을 수 있는 기타 데이터가 포함되어 있습니다. 프레임 테이블은 비어있는 프레임이 없을 때 evict할 페이지를 골라줌으로써, 핀토스가 효율적으로 eviction 정책을 구현할 수 있도록 해줍니다.
- 사용자 페이지에 사용되는 프레임은 palloc_get_page(PAL_USER)를 호출하여 '유저 풀'에서 가져와야 합니다. 커널 풀에서 할당했다가 예상치 못하게 테스트 케이스에서 실패하는 일을 막기 위해서는, 반드시 PAL_USER를 사용하여야 합니다. 프레임 테이블 구현의 일부로 palloc.c를 수정하는 경우 두 풀 간의 구분을 유지해야 합니다.
- 프레임 테이블에서 가장 중요한 작업은 사용하지 않는 프레임을 획득하는 것입니다. 프레임이 비어 있는 상태라면 간단한 일입니다. 하지만, 빈 프레임이 없는 경우 프레임에서 일부 페이지를 evict하여 프레임을 빈 프레임으로 만들어야 합니다.
- 스왑 슬롯의 할당 없이 evict시킬 수 있는 프레임이 없는데 스왑 슬롯이 가득 차있다면, 커널은 패닉 상태에 빠집니다. 실제 운영체제에서는 이러한 상황을 복구하거나 예방하기 위해 다양한 정책을 적용하지만, 이러한 정책은 이 프로젝트의 범위를 벗어납니다.<br><br>
- eviction 절차는 대략 다음 단계로 구성됩니다 :
    1. 페이지 교체 알고리즘을 사용하여 evict할 프레임을 선택합니다. 아래에 설명된 페이지 테이블의 'Accessed and Dirty Bits'가 유용하게 사용될 것입니다.
    2. 프레임을 참조하는 모든 페이지 테이블에서 프레임에 대한 참조를 제거합니다. 공유를 구현하지 않은 경우, 한 번에 하나의 페이지만 프레임을 참조해야 합니다.
    3. 필요한 경우 페이지를 파일 시스템에 쓰거나 스왑합니다. evict된 프레임은 다른 페이지를 저장하는 데 사용될 수 있습니다.<br><br>
1. Accessed 비트와 Dirty 비트(Accessed and Dirty Bits)
    - x86-64 하드웨어는 각 페이지의 페이지 테이블 엔트리(PTE)에 있는 한 쌍의 비트를 통해 페이지 교체 알고리즘을 구현하는 데 약간의 지원을 제공합니다. 페이지에 대한 읽기 또는 쓰기 시 CPU는 페이지의 PTE에서 accessed 비트를 1로 설정하고, 쓰기 시 dirty 비트를 1로 설정합니다. CPU는 이러한 비트를 0으로 재설정하지 않지만, OS는 재설정할 수 있습니다.
    - 동일한 프레임을 참조하는 두 개 이상의 페이지인 aliases에 대해 알고 있어야 합니다. aliases된 프레임이 액세스 될 때, accessed와 dirty 비트는 하나의 페이지 테이블 엔트리(액세스에 사용된 페이지에 대한 엔트리)에서만 업데이트됩니다. 다른 aliases에 대한 accessed와 dirty 비트는 업데이트 되지 않습니다.
    - 핀토스에서는 모든 사용자 가상 페이지가 커널 가상 페이지에 aliases되어 있습니다. 반드시 이 aliases를 관리해야 합니다. 예를 들어, 코드에서 두 주소 모두에 대해 accessed와 dirty 비트를 확인하고 업데이트할 수 있어야 합니다. 또는, 커널이 사용자 가상 주소를 통해서만 사용자 데이터에 액세스하게 함으로써 이 문제를 피하게 할 수 있습니다.
    - Other aliases는 공유를 구현하거나 코드에 버그가 있는 경우에만 발생해야 합니다.
    - accessed와 dirty 비트로 작업하는 함수에 대한 자세한 내용은 accessed와 dirty 비트 섹션(https://casys-kaist.github.io/pintos-kaist/appendix/page_table.html)을 참조하십시오.

#### 스왑 테이블 관리(Managing the Swap Table)
- 스왑 테이블은 사용중인 스왑 슬롯과 빈 스왑 슬롯들을 추적합니다. 프레임에서 스왑 파티션으로 페이지를 evicting하기 위해 사용하지 않는 스왑 슬롯을 선택할 수 있어야 합니다. 페이지를 다시 읽거나 페이지가 스왑된 프로세스가 종료될 때 스왑 슬롯을 해제할 수 있어야 합니다.
- vm/build 디렉터리에서 pintos-mkdisk swap.dsk --swap-size=n 명령을 사용하여 n-MB 스왑 파티션이 포함된 swap.dsk라는 이름의 디스크를 생성합니다. 이후에는 핀토스를 실행할 때 swap.dsk가 자동으로 추가 디스크로 첨부됩니다. 또는, --swap-size=n 명령어를 사용하여 n-MB의 임시 스왑 디스크를 일회성 실행을 위해 사용하도록 핀토스에 명령할 수 있습니다.
- 스왑 슬롯은 게으르게 할당되어야 합니다. 즉, eviction이 실제로 필요할 때만 할당되어야 합니다. 실행 파일에서 데이터 페이지를 읽고 프로세스 시작 시 즉시 스왑에 쓰는 것은 게으르지 않습니다.
- 특정 페이지를 저장하기 위해 스왑 슬롯을 예약해서는 안 됩니다.
- 스왑 슬롯의 내용물이 프레임으로 다시 읽을 때 스왑 슬롯을 해제한다.

#### 메모리 매핑 파일 관리(Managing Memory Mapped Files)
- 파일 시스템은 읽기 및 쓰기 시스템 콜을 통해 가장 일반적으로 액세스합니다. 두 번째 인터페이스는 mmap 시스템 콜을 사용하여 파일을 가상 페이지에 '매핑'하는 것입니다. 그러면, 프로그램이 파일 데이터에 직접 메모리 명령을 사용할 수 있습니다. 파일 foo의 길이가 0x1000바이트(4kB, 즉 한 페이지)라고 가정해 봅시다. 만약, foo 가 0x5000 주소에서 시작하는 메모리에 매핑된 경우, 0x5000. . .0x5fff 공간에 메모리 접근을 하면 그에 대응되는 foo 파일의 바이트들에 접근될 것입니다.
- 다음은 mmap을 사용하여 콘솔에 파일을 인쇄하는 프로그램입니다. 이 프로그램은 커맨드라인에 명시된 파일을 열고 가상 주소 0x10000000에 매핑한 다음, 매핑된 데이터를 콘솔에 쓰고(fd 1) 파일 매핑을 해제합니다.
    ```C
    #include <stdio.h>
    #include <syscall.h>
    int main (int argc UNUSED, char *argv[])
    {
    void *data = (void *) 0x10000000;                 /* Address at which to map. */
    int fd = open (argv[1]);                          /* Open file. */
    void *map = mmap (data, filesize (fd), 0, fd, 0); /* Map file. */
    write (1, data, filesize (fd));                   /* Write file to console. */
    munmap (map);                                     /* Unmap file (optional). */
    return 0;
    }
    ```
- 당신의 제출물은 어떤 메모리가 메모리-매핑 파일에 의해 사용되었는지를 반드시 추적할 수 있어야 합니다. 이는 매핑된 영역에서 페이지 오류를 올바르게 처리하고, 매핑된 파일이 프로세스 내의 다른 세그먼트와 겹치지 않도록 하기 위해 필요합니다.

### Memory Management
#### Memory Management
- 가상 메모리 시스템을 지원하려면 가상 페이지와 물리적 프레임을 효과적으로 관리해야 합니다. 즉, 어떤 (가상 또는 물리적) 메모리 영역이 어떤 목적으로, 누구에 의해 사용되고 있는지 등을 추적해야 합니다. 먼저 supplemental page table을 다룬 다음 실제 프레임을 다룹니다. 이해를 돕기 위해, 저희는 "페이지"라는 용어를 가상 페이지를 의미하는 데 사용하며, "프레임"이라는 용어를 물리적인 페이지를 의미하는 데 사용합니다.<br><br>
1. 페이지 구조 및 작업(Page Structure and Operations)
    1. 페이지 구조체(Struct Page)
        - include/vm/vm.h에 정의된 페이지는 가상 메모리에 있는 페이지를 나타내는 구조체입니다. 이 구조체는 페이지에 대해 알아야 할 모든 필요한 데이터를 저장합니다. 현재 템플릿에서는 다음과 같이 구조체가 정의되어 있습니다 :
            ```C
            struct page {
            const struct page_operations *operations;
            void *va;              /* Address in terms of user space */
            struct frame *frame;   /* Back reference for frame */

                union {
                    struct uninit_page uninit;
                    struct anon_page anon;
                    struct file_page file;
            #ifdef EFILESYS
                    struct page_cache page_cache;
            #endif
                };
            };
            ```
            - 이 구조체에는 아래에 설명된 페이지 작업, 가상 주소, 물리적인 프레임이 포함되어 있습니다. 더불어, 유니온 필드도 존재합니다. 유니온은 특별한 데이터 타입으로, 다른 유형의 데이터를 메모리 영역에 저장할 수 있도록 해줍니다. 이 유니언에는 여러 개의 멤버가 있지만, 동시에 하나의 멤버만 값을 가질 수 있습니다. 이는 시스템에서 페이지가 uninit_page, anon_page, file_page, 또는 page_cache 중 하나일 수 있음을 의미합니다. 예를 들어, 페이지가 익명 페이지(https://casys-kaist.github.io/pintos-kaist/project3/anon.html 참고)인 경우, 페이지 구조체에는 멤버 중 하나로 struct anon_page anon 필드가 포함됩니다. anon_page에는 익명 페이지에 대해 유지해야 할 모든 필요한 정보가 포함됩니다.<br><br>
    2. 페이지 작업(Page Operations)
        - 위에서도 설명했고 include/vm/vm.h 에도 정의되어 있듯이, 한 페이지는 VM_UNINIT, VM_ANON 또는 VM_FILE일 수 있습니다. 페이지에는 스왑 인(Swapping In), 스왑 아웃(Swapping Out), 페이지 파괴(Destroying the Page)와 같은 여러 동작이 필요합니다. 페이지 유형에 따라 이러한 작업에 필요한 단계와 작업이 다릅니다. 즉, VM_ANON 페이지와 VM_FILE 페이지는 서로 다른 destroy 함수를 호출합니다. 이를 위해 switch-case 구문을 활용해서 각 케이스에 맞는 함수를 사용하는 방법이 하나 있습니다. 이를 처리하기 위해 객체 지향 프로그래밍의 "클래스 상속" 개념을 소개합니다. 실제로 C 프로그래밍 언어에서는 "클래스"나 "상속"이 존재하지 않습니다. 대신에 함수 포인터를 활용하여 이러한 개념을 구현합니다. 이는 리눅스와 같은 실제 운영 체제 코드에서도 유사하게 사용되는 방식입니다.
            - 스왑 인(Swapping In) : 디스크에서 페이지를 메모리로 이동시키는 동작입니다. 페이지가 메모리에 없고 디스크에 스왑 영역에 저장되어 있을 때, 해당 페이지를 메모리로 로드하는 과정입니다. 이로써 해당 페이지에 대한 접근이 가능해지고, 프로세스가 페이지를 사용할 수 있게 됩니다.
            - 스왑 아웃(Swapping Out) : 메모리에 있는 페이지를 디스크로 이동시키는 동작입니다. 메모리에 있는 페이지가 다른 페이지로 대체되어야 하는 경우, 해당 페이지를 디스크의 스왑 영역으로 이동시킵니다. 이는 메모리의 공간을 확보하고, 더 많은 페이지를 메모리에 올릴 수 있게 합니다.
            - 페이지 파괴(Destroying the Page) : 페이지를 메모리에서 제거하는 동작입니다. 페이지가 더 이상 필요하지 않거나, 프로세스가 종료되는 경우, 해당 페이지를 메모리에서 파괴하여 메모리 공간을 확보합니다. 이로써 다른 페이지나 데이터가 메모리에 로드될 수 있게 됩니다.
        - 함수 포인터는 지금까지 배운 다른 포인터와 마찬가지로 메모리 내의 함수 또는 실행 가능한 코드를 가리키는 포인터입니다. 함수 포인터는 런타임 값에 따라 특정 함수를 호출하여 검사 없이 실행할 수 있는 간단한 방법을 제공하기 때문에 유용합니다. 우리의 경우에는 코드 수준에서 단순히 destroy(page)를 호출하는 것만으로 충분합니다. 컴파일러는 페이지 유형에 따라 적절한 destroy 루틴을 선택하기 위해 올바른 함수 포인터를 호출합니다.
        - 페이지 연산을 위한 구조체 page_operations는 include/vm/vm.h에 정의되어 있습니다.  이 구조체를 3개의 함수 포인터를 포함한 하나의 함수 테이블로 이해하십시오.
            ```C
            struct page_operations {
                bool (*swap_in) (struct page *, void *);
                bool (*swap_out) (struct page *);
                void (*destroy) (struct page *);
                enum vm_type type;
            };
            ```
        - 이제 page_operation 구조체를 어디에서 찾을 수 있는지 살펴보겠습니다. 만약 include/vm/vm.h 파일에서 struct page라는 페이지 구조체를 살펴보면, 해당 구조체에는 operations라는 필드가 존재하는 것을 확인할 수 있습니다. 이제 vm/file.c 파일로 이동하면, 함수 프로토 타입 이전에 선언된 page_operations 구조체 file_ops를 볼 수 있습니다. 이것은 파일을 기반으로 하는 페이지에 대한 함수 포인터 테이블입니다. .destroy 필드에는 file_backed_destroy라는 값이 있습니다. 이 값은 페이지를 파괴하는 함수이며, 같은 파일에서 정의되어 있습니다.
        - 함수 포인터 인터페이스를 사용하여 file_backed_destroy가 어떻게 호출되는지 이해해 보겠습니다. vm/vm.c에서 vm_dealloc_page(page)가 호출되고 이 페이지가 파일 백업 페이지(VM_FILE)라고 가정해 보겠습니다. 함수 내부에서는 destroy(page)를 호출합니다. destroy(page)는 다음과 같이 include/vm/vm.h에 매크로를 사용하여 정의합니다 :
            ```C
            #define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
            ```
            - 이는 destroy 함수를 호출하면 실제로 (page)->operations->destroy(page)가 호출되며, 페이지 구조체에서 검색한 destroy 함수입니다. 이 페이지는 VM_FILE 페이지이므로 .destroy 필드가 file_backed_destory를 가리킵니다. 결과적으로 파일 기반 페이지의 destroy 루틴이 수행됩니다.<br><br>
2. 부가 페이지 테이블 구현(Implement Supplemental Page Table)
    - 현재 시점에서, 당신의 핀토스는 메모리의 가상 및 물리 매핑을 관리하기 위한 페이지 테이블(pml4)을 가지고 있습니다. 그러나 이것만으로는 충분하지 않습니다. 이전 섹션에서 논의한대로, page fault 및 자원 관리를 처리하기 위해 각 페이지에 대한 추가 정보를 담을 supplemental page table이 필요합니다. 따라서, 프로젝트 3의 첫 번째 작업으로 supplemental page table에 대한 일부 기본 기능을 구현하는 것을 제안합니다.
    - vm/vm.c에서 supplemental page table 관리 기능을 구현하세요.
    - 먼저, 핀토스에서 어떻게 supplemental page table을 설계할지 결정해야 합니다. 고유한 supplemental page table을 설계한 후, 아래 세 가지 함수를 해당 설계에 따라 구현하세요.
        ```C
        void supplemental_page_table_init (struct supplemental_page_table *spt);
        ```
        - supplemental page table을 초기화합니다. supplemental page table에 사용할 데이터 구조를 선택할 수 있습니다. 이 함수는 새로운 프로세스가 시작될 때(userprog/process.c의 initd 함수)와 프로세스가 포크될 때(userprog/process.c의 __do_fork 함수) 호출됩니다.
        ```C
        struct page *spt_find_page (struct supplemental_page_table *spt, void *va);
        ```
        - 주어진 supplemental page table에서 va에 해당하는 struct page를 찾습니다. 실패한 경우 NULL을 반환합니다.
        ```C
        bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);
        ```
        - 주어진 supplemental page table에 struct page를 삽입합니다. 이 함수는 주어진 supplemental page table에 가상 주소가 존재하지 않는지 확인해야 합니다.<br><br>
3. 프레임 관리(Frame Management)
    - 이제부터 모든 페이지는 생성될 때 메모리의 메타데이터만을 담고 있는 것이 아닙니다. 따라서 물리 메모리를 관리하기 위해 다른 방식이 필요합니다. include/vm/vm.h에는 물리 메모리를 나타내는 struct frame이 존재합니다. 현재 이 구조는 다음과 같이 보입니다 : 
        ```C
        /* The representation of "frame" */
        struct frame {
            void *kva;
            struct page *page;
        };
        ```
        - 현재 struct frame은 두 개의 필드만을 가지고 있습니다. 첫 번째는 커널 가상 주소를 나타내는 kva이고, 두 번째는 페이지 구조를 나타내는 page입니다. 프레임 관리 인터페이스를 구현하면서 필요에 따라 추가 멤버를 추가할 수 있습니다.
    - vm/vm.c에서 vm_get_frame, vm_claim_page 및 vm_do_claim_page를 구현하세요.
        ```C
        static struct frame *vm_get_frame (void);
        ```
        - palloc_get_page를 호출하여 사용자 풀에서 새로운 물리 페이지를 가져옵니다. 사용자 풀에서 페이지를 성공적으로 가져오면, 프레임을 할당하고 그 멤버들을 초기화한 후 반환합니다. vm_get_frame을 구현한 후에는 모든 사용자 공간 페이지(PALLOC_USER)를 이 함수를 통해 할당해야 합니다. 현재 페이지 할당 실패 시 스왑 아웃을 처리할 필요는 없습니다. 단지 해당 경우에는 PANIC("todo")로 표시하면 됩니다.
        ```C
        bool vm_do_claim_page (struct page *page);
        ```
        - 페이지를 할당하고(즉, 물리 프레임을 할당합니다). 먼저, vm_get_frame을 호출하여 프레임을 가져옵니다(이 부분은 이미 템플릿에서 완료되었습니다). 그런 다음, MMU를 설정해야 합니다. 다시 말해, 가상 주소와 물리 주소 사이의 매핑을 페이지 테이블에 추가합니다. 반환 값은 작업이 성공했는지 여부를 나타내어야 합니다.
### Anonymous Page
- 이 프로젝트의 이 부분에서는 디스크 기반이 아닌 익명 페이지라고 불리는 이미지를 구현할 것입니다.
- 익명 매핑은 백업 파일이나 장치를 가지지 않습니다. 파일 기반 페이지와 달리 명명된 파일 소스가 없으므로 익명이라고 합니다. 익명 페이지는 스택 및 힙과 같은 실행 파일에 사용됩니다.
- 익명 페이지를 설명하는 구조체인 include/vm/anon.h의 anon_page가 있습니다. 현재 비어 있지만, 구현하는 동안 익명 페이지의 필요한 정보나 상태를 저장할 멤버를 추가할 수 있습니다. 또한, include/vm/vm.h에 있는 struct page를 참조하세요. 이는 페이지의 일반적인 정보를 담고 있습니다. 익명 페이지의 경우, 해당 페이지 구조에 struct anon_page anon이 포함되어 있음을 유의하세요.

#### 지연 로딩을 통한 페이지 초기화(Page Initialization with Lazy Loading)
- 지연 로딩은 메모리 로딩이 필요한 시점까지 지연되는 디자인 패턴입니다. 페이지가 할당되어 해당 페이지에 대응하는 페이지 구조가 있지만, 전용 물리 프레임은 없으며 페이지의 실제 내용은 아직 로드되지 않은 상태입니다. 내용은 실제로 필요한 시점에만 로드되며, 이는 page fault에 의해 신호가 발생함을 의미합니다.
- 세 가지 종류의 페이지가 있기 때문에, 각 페이지 유형에 따라 초기화 루틴이 다릅니다. 이후 섹션에서 다시 설명될 예정이지만, 여기에서는 페이지 초기화 흐름의 고수준 개요를 제공합니다. 먼저, 커널이 새로운 페이지 요청을 받으면 vm_alloc_page_with_initializer 함수가 호출됩니다. 이 초기화기는 페이지 구조를 할당하고, 페이지 유형에 따라 적절한 초기화기를 설정하여 새로운 페이지를 초기화한 다음, 제어를 사용자 프로그램에 반환합니다. 사용자 프로그램이 실행되는 동안 특정 시점에서 page fault가 발생합니다. 이는 프로그램이 아직 내용이 없는 페이지에 접근하려고 하기 때문입니다. page fault 처리 절차 중에 uninit_initialize가 호출되고, 이전에 설정한 초기화기를 호출합니다. 초기화기는 익명 페이지에 대해 anon_initializer를 사용하고, 파일 기반 페이지에 대해서는 file_backed_initializer를 사용합니다.
- 각 페이지는 초기화 -> (page fault -> 지연 로딩 -> 스왑 인 -> 스왑 아웃 -> ...) -> 소멸의 생명주기를 가질 수 있습니다. 생명주기의 각 전환마다 페이지 유형(또는 VM_TYPE)에 따라 필요한 절차가 다릅니다. 이전 단락은 초기화를 예로 들었습니다. 이 프로젝트에서는 각 페이지 유형에 대한 이러한 전환 프로세스를 구현하게 됩니다.
#### 실행 파일의 지연 로딩(Lazy Loading for Executable)
- 지연 로딩에서는 프로세스가 실행을 시작할 때 즉시 필요한 메모리 부분만 주 메모리에 로드됩니다. 이는 한 번에 모든 이진 이미지를 메모리에 로드하는 이른바 즉시 로딩에 비해 오버헤드를 줄일 수 있습니다.
- 지연 로딩을 지원하기 위해, include/vm/vm.h에 VM_UNINIT라는 페이지 유형을 소개합니다. 모든 페이지는 초기에 VM_UNINIT 페이지로 생성됩니다. 또한, 초기화되지 않은 페이지를 위한 페이지 구조체인 include/vm/uninit.h의 struct uninit_page를 제공합니다. 초기화되지 않은 페이지를 생성, 초기화, 소멸하기 위한 함수들은 include/vm/uninit.c에 있습니다. 이러한 함수들을 나중에 완성해야 합니다.
- page fault가 발생하면, page fault handler (userprog/exception.c의 page_fault)는 제어를 vm/vm.c의 vm_try_handle_fault로 전달합니다. 이 함수에서는 먼저 유효한 page fault인지 확인합니다. 여기서 유효하다는 것은 잘못된 접근으로 발생한 fault를 의미합니다. 만약 잘못된 fault인 경우, 페이지에 일부 내용을 로드하고 제어를 사용자 프로그램에 반환합니다.
- 세 가지 잘못된 page fault 경우가 있습니다 : 지연 로딩된 페이지, 스왑 아웃된 페이지, 그리고 쓰기가 보호된 페이지(자세한 내용은 Copy-on-Write(https://casys-kaist.github.io/pintos-kaist/project3/cow.html)를 참조하십시오). 현재는 첫 번째 경우인 지연 로딩된 페이지만 고려합니다. 지연 로딩을 위한 페이지 부재가 발생한 경우, 커널은 이전에 설정한 초기화 함수 중 하나를 호출하여 세그먼트를 지연 로딩합니다. userprog/process.c에 있는 lazy_load_segment 함수를 구현해야 합니다.
- vm_alloc_page_with_initializer() 함수를 구현하세요. 전달된 vm_type에 따라 적합한 초기화 함수를 가져와서 uninit_new를 호출해야 합니다.
    ```C
    bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
        bool writable, vm_initializer *init, void *aux);
    ```
    - 주어진 유형으로 초기화되지 않은 페이지를 생성하세요. uninit 페이지의 swap_in 핸들러는 유형에 따라 페이지를 자동으로 초기화하고 주어진 AUX와 함께 INIT을 호출합니다. 페이지 구조체를 얻으면 프로세스의 supplemental page table에 페이지를 삽입하세요. vm.h에 정의된 VM_TYPE 매크로를 사용하면 편리합니다.
- page fault handler는 호출 체인을 따라 진행하다가, swap_in을 호출할 때 uninit_initialize에 도달합니다. 우리는 이를 위한 완전한 구현을 제공합니다. 그러나 당신의 설계에 따라 uninit_initialize를 수정해야 할 수도 있습니다.
    ```C
    static bool uninit_initialize (struct page *page, void *kva);
    ```
    - 첫 번째 page fault 시 페이지를 초기화합니다. 템플릿 코드는 먼저 vm_initializer와 aux를 가져와 함수 포인터를 통해 해당하는 page_initializer를 호출합니다. 당신의 설계에 따라 함수를 수정해야 할 수도 있습니다.
- 당신의 요구에 맞게 vm/anon.c 파일의 vm_anon_init 및 anon_initializer 함수를 수정할 수 있습니다.
    ```C
    void vm_anon_init (void);
    ```
    - 익명 페이지 서브시스템을 위한 초기화입니다. 이 함수에서는 익명 페이지와 관련된 모든 설정을 수행할 수 있습니다.
    ```C
    bool anon_initializer (struct page *page,enum vm_type type, void *kva);
    ```
    - 이 함수는 먼저 page->operations에서 익명 페이지에 대한 핸들러를 설정합니다. 현재는 빈 구조체인 anon_page에 일부 정보를 업데이트해야 할 수도 있습니다. 이 함수는 익명 페이지 (즉, VM_ANON)의 초기화 함수로 사용됩니다.
- userprog/process.c에 load_segment와 lazy_load_segment를 구현하세요. 실행 파일에서 세그먼트를 로드하는 기능을 구현합니다. 이들 모든 페이지는 지연시켜서 로드되어야 합니다. 즉, 커널이 해당 페이지에 대한 page fault를 가로챌 때만 로드됩니다.
- userprog/process.c의 load_segment 함수의 핵심인 루프를 수정해야 합니다. 루프의 각 반복마다, vm_alloc_page_with_initializer를 호출하여 보류 중인 페이지 객체를 생성합니다. page fault가 발생할 때, 해당 세그먼트가 실제로 파일에서 로드됩니다.
    ```C
    static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
        uint32_t read_bytes, uint32_t zero_bytes, bool writable);
    ```
    - 현재 코드는 메인 루프 내에서 파일로부터 읽을 바이트 수와 0으로 채울 바이트 수를 계산합니다. 그런 다음, vm_alloc_page_with_initializer를 호출하여 보류 중인 객체를 생성합니다. vm_alloc_page_with_initializer에 전달할 aux 인수로 auxiliary 값을 설정해야 합니다. 이진 파일의 로딩에 필요한 정보를 포함하는 구조체를 만들 수도 있습니다.
    ```C
    static bool lazy_load_segment (struct page *page, void *aux);
    ```
    - load_segment에서 vm_alloc_page_with_initializer의 네 번째 인자로 lazy_load_segment가 전달되는 것을 알 수 있습니다. 이 함수는 실행 파일의 페이지를 초기화하는 역할을 하며, page fault가 발생할 때 호출됩니다. 이 함수는 페이지 구조체와 aux를 인자로 받습니다. aux에는 load_segment에서 설정한 정보가 포함되어 있습니다. 이 정보를 사용하여 세그먼트를 읽어들일 파일을 찾고, 세그먼트를 메모리에 로드해야 합니다.
- 새로운 메모리 관리 시스템에 스택 할당을 맞추기 위해 userprog/process.c의 setup_stack 함수를 조정해야 합니다. 첫 번째 스택 페이지는 지연시켜서 할당될 필요가 없습니다. 실행 시 명령줄 인수로 스택 페이지를 할당하고 초기화할 수 있으며, fault가 발생하기를 기다릴 필요가 없습니다. 스택을 식별할 수 있는 방법을 제공해야 할 수도 있습니다. vm/vm.h의 vm_type의 보조 마커(예: VM_MARKER_0)를 사용하여 페이지를 표시할 수 있습니다.
- 마지막으로, vm_try_handle_fault 함수를 수정하여 supplemental page table을 통해 fault된 주소에 해당하는 페이지 구조체를 해결합니다. 이를 위해 spt_find_page를 사용합니다.
- 모든 요구사항을 구현한 후에는 fork를 제외한 프로젝트 2의 모든 테스트가 통과해야 합니다.
#### 부가 페이지 테이블 - 재검토(Supplemental Page Table - Revisit)
- 이제 우리는 생성(구체적으로는 자식 프로세스 생성) 또는 프로세스 삭제 시 필요한 복사 및 정리 작업을 지원하기 위해 supplemental page table 인터페이스를 다시 살펴보려고 합니다. 자세한 내용은 아래에서 설명됩니다. 지금 supplemental page table을 다시 검토하는 이유는 위에서 구현한 일부 초기화 함수를 사용하고자 할 수 있기 때문입니다.
- vm/vm.c에 있는 supplemental_page_table_copy와 supplemental_page_table_kill를 구현하세요.
    ```C
    bool supplemental_page_table_copy (struct supplemental_page_table *dst,
        struct supplemental_page_table *src);
    ```
    - src에서 dst로 supplemental page table을 복사합니다. 이 작업은 자식이 부모의 실행 컨텍스트를 상속해야 할 때 사용됩니다(예: fork()). src의 supplemental page table의 각 페이지를 반복하고, dst의 supplemental page table에 해당 항목을 정확하게 복사합니다. 초기화되지 않은 페이지를 할당하고 즉시 해당 페이지를 사용합니다.
    ```C
    void supplemental_page_table_kill (struct supplemental_page_table *spt);
    ```
    - supplemental page table에 의해 유지되는 모든 리소스를 해제합니다. 이 함수는 프로세스가 종료될 때 호출됩니다(userprog/process.c의 process_exit() 함수에서 호출됩니다). 페이지 엔트리를 반복하며 테이블 내의 페이지에 대해 destroy(page)를 호출해야 합니다. 이 함수에서는 실제 페이지 테이블 (pml4)과 물리적 메모리 (palloc으로 할당된 메모리)에 대해서는 걱정할 필요가 없습니다. 이 함수에서 supplemental page table이 정리된 후 호출자가 이를 정리합니다.
#### 페이지 정리(Page Cleanup)
- vm/uninit.c 파일에 uninit_destroy를 구현하고, vm/anon.c 파일에 anon_destroy를 구현하세요. 이는 초기화되지 않은 페이지에 대한 destroy 작업을 처리하는 핸들러입니다. 초기화되지 않은 페이지는 다른 페이지 객체로 변환되지만, 프로세스가 종료될 때에도 여전히 초기화되지 않은 페이지가 존재할 수 있습니다.
    ```C
    static void uninit_destroy (struct page *page);

    ```
    - page 구조체가 보유한 자원을 해제합니다. 페이지의 vm 유형을 확인하고, 해당 유형에 따라 적절한 처리를 수행해야 합니다.
- 현재는 익명 페이지만 처리할 수 있습니다. 나중에 파일 기반 페이지를 정리하기 위해 이 함수를 다시 검토할 것입니다.
    ```C
    static void anon_destroy (struct page *page);
    ```
    - 익명 페이지가 보유한 리소스를 해제합니다. 페이지 구조체를 명시적으로 해제할 필요는 없으며, 호출자가 이를 수행해야 합니다.
- 이제 프로젝트 2의 모든 테스트가 통과해야 합니다.

### Stack Growth
- 프로젝트 2에서는 스택이 USER_STACK을 시작으로 한 페이지로 제한되고, 프로그램 실행도 이 크기로 제한되었습니다. 이제 스택이 현재 크기를 초과하면 필요에 따라 추가 페이지를 할당합니다.
- 스택 접근과 다른 접근을 구별하기 위해 스택 접근으로 보이는 경우에만 추가 페이지를 할당합니다. 스택 접근을 구분하기 위한 휴리스틱을 개발하세요.
- 일반적인 실제 운영 체제는 "시그널"을 전달하기 위해 언제든지 프로세스를 중단할 수 있으므로, 스택 포인터 아래의 스택에 쓰기를 하는 경우 사용자 프로그램은 오류가 됩니다. 그러나 x86-64 PUSH 명령은 스택 포인터를 조정하기 전에 액세스 권한을 확인하므로, 스택 포인터로부터 8바이트 아래에서 page fault가 발생할 수 있습니다.
- 사용자 프로그램의 스택 포인터의 현재 값을 얻을 수 있어야 합니다. 시스템 호출 내부나 사용자 프로그램에서 발생한 page fault에서는 각각 syscall_handler() 또는 page_fault()에 전달된 struct intr_frame의 rsp 멤버에서 해당 값을 가져올 수 있습니다. 유효하지 않은 메모리 접근을 감지하기 위해 page fault에 의존하는 경우, 커널에서 page fault가 발생하는 경우를 처리해야 합니다. 프로세서는 예외로 인해 사용자 모드에서 커널 모드로 전환될 때에만 스택 포인터를 저장하므로, page_fault()에 전달된 struct intr_frame에서 rsp를 읽으면 정의되지 않은 값이 반환되며 사용자 스택 포인터가 아닙니다. 사용자 모드에서 커널 모드로의 초기 전환 시, rsp를 struct thread에 저장하는 등 다른 방법을 마련해야 할 것입니다.
- 스택 확장 기능을 구현하세요. 이를 위해 먼저 vm/vm.c의 vm_try_handle_fault를 수정하여 스택 확장을 식별해야 합니다. 스택 확장이 식별되면, vm/vm.c의 vm_stack_growth를 호출하여 스택을 확장해야 합니다. vm_stack_growth를 구현하세요.
    ```C
    bool vm_try_handle_fault (struct intr_frame *f, void *addr,
        bool user, bool write, bool not_present);
    ```
    - 이 함수는 userprog/exception.c의 page_fault에서 page fault 예외를 처리하는 동안 호출됩니다. 이 함수에서는 page fault가 스택 확장의 유효한 경우인지 확인해야 합니다. fault를 스택 확장으로 처리할 수 있다고 확인한 경우, 해당 fault 주소를 인자로하여 vm_stack_growth를 호출하세요.
    ```C
    void vm_stack_growth (void *addr);
    ```
    - addr를 포함하지 않는 하나 이상의 익명 페이지를 할당하여 스택 크기를 증가시킵니다. 할당 처리 시 addr을 PGSIZE로 내림하여 처리하는 것을 확인해주세요.
- 대부분의 운영 체제는 스택 크기에 절대적인 제한을 두고 있습니다. 일부 운영 체제에서는 ulimit 명령을 사용하여 사용자가 스택 크기를 조정할 수 있습니다. 많은 GNU/Linux 시스템에서는 기본적으로 8MB의 스택 크기 제한이 있습니다. 이 프로젝트에서는 최대 1MB로 스택 크기를 제한해야 합니다.
- 이제, 스택 확장과 관련된 모든 테스트 케이스가 통과해야 합니다.

### Memory Mapped Files
- 이 섹션에서는 메모리 매핑된 페이지를 구현할 것입니다. 익명 페이지와 달리 메모리 매핑된 페이지는 파일 기반 매핑입니다. 페이지 내용은 기존 파일의 데이터를 반영합니다. page fault가 발생하면 물리적인 프레임이 즉시 할당되고, 파일에서 메모리로 내용이 복사됩니다. 메모리 매핑된 페이지가 언매핑되거나 스왑되면 내용의 변경 사항이 파일에 반영됩니다.

#### mmap과 munmap 시스템 콜(mmap and munmap System Call)
- mmap과 munmap을 구현해야 합니다. 이 두 시스템 호출은 메모리 매핑된 파일을 위한 시스템 호출입니다. VM 시스템은 mmap 영역에서 페이지를 지연 로딩하고, 매핑을 위한 백업 저장소로 mmap된 파일 자체를 사용해야 합니다. 이를 구현하기 위해 vm/file.c에 정의된 do_mmap과 do_munmap을 구현하고 사용해야 합니다.
    ```C
    void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
    ```
    - fd로 열린 파일을 offset 바이트부터 시작하여 length 바이트를 프로세스의 가상 주소 공간인 addr에 매핑합니다. 전체 파일은 addr에서 시작하는 연속적인 가상 페이지에 매핑됩니다. 파일의 길이가 PGSIZE의 배수가 아닌 경우, 파일의 끝을 넘어서는 일부 바이트가 "더 보여집니다". 해당 페이지가 page fault로 로딩될 때 이러한 바이트를 0으로 설정하고, 페이지가 디스크로 다시 쓰여질 때는 해당 바이트를 폐기합니다. 성공하면 파일이 매핑된 가상 주소를 반환하고, 실패하면 유효하지 않은 주소인 NULL을 반환해야 합니다.
- mmap 함수 호출은 파일로 열린 fd의 길이가 0바이트인 경우 실패할 수 있습니다. 또한, addr이 페이지에 정렬되지 않았거나 이미 매핑된 페이지 집합(스택 또는 실행 파일 로드 시 매핑된 페이지 포함)과 겹치는 페이지 범위인 경우에도 실패해야 합니다. Linux에서는 addr이 NULL인 경우, 커널은 매핑을 생성할 적절한 주소를 찾습니다. 단순화를 위해 주어진 addr에 매핑을 시도할 수 있습니다. 따라서, addr이 0인 경우 실패해야 합니다. 왜냐하면, 핀토스 코드 중 일부는 가상 페이지 0이 매핑되지 않았다고 가정하기 때문입니다. 또한, length가 0인 경우에도 mmap은 실패해야 합니다. 마지막으로, 콘솔 입력과 출력을 나타내는 파일 디스크립터는 매핑할 수 없습니다.
- 메모리 매핑된 페이지는 익명 페이지와 마찬가지로 지연 방식으로 할당되어야 합니다. vm_alloc_page_with_initializer 또는 vm_alloc_page를 사용하여 페이지 개체를 만들 수 있습니다.
    ```C
    void munmap (void *addr);
    ```
    - 이 함수는 이전에 동일한 프로세스에서 mmap 호출로 반환된 가상 주소 범위인 addr의 매핑을 해제합니다. 이 매핑은 아직 해제되지 않았어야 합니다.
- 모든 매핑은 프로세스가 exit을 통해 종료되거나 다른 방법으로 종료될 때 암묵적으로 언매핑됩니다. 매핑이 언매핑되면, 암묵적이든 명시적이든 프로세스에 의해 쓰여진 모든 페이지는 파일로 기록되어야 하며, 쓰여지지 않은 페이지는 기록되지 않아야 합니다. 그런 다음 이러한 페이지는 프로세스의 가상 페이지 목록에서 제거됩니다.
- 파일을 닫거나 제거하는 것은 해당 파일의 매핑을 언매핑하지 않습니다. 한 번 생성된 매핑은 munmap이 호출되거나 프로세스가 종료될 때까지 유효합니다. 이는 Unix 규칙을 따릅니다. 자세한 내용은 "Removing an Open File(https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html)"을 참조하십시오. 각 매핑에 대해 독립적이고 독립적인 참조를 얻기 위해 file_reopen 함수를 사용해야 합니다.
- 두 개 이상의 프로세스가 동일한 파일을 매핑하는 경우 데이터의 일관성을 보장하는 요구 사항은 없습니다. Unix는 두 매핑이 동일한 물리적 페이지를 공유하도록 처리하며, mmap 시스템 호출에는 페이지를 공유하거나 개인적으로 사용할지 (즉, 복사 시에만 작성)를 지정할 수 있는 인수도 있습니다.
- 필요에 따라 vm/vm.c의 vm_file_init 및 vm_file_initializer를 수정할 수도 있습니다.
    ```C
    void vm_file_init (void);
    ```
    - 파일을 백업하는 페이지 시스템을 초기화합니다. 이 함수에서는 파일 백업 페이지와 관련된 모든 설정을 수행할 수 있습니다.
    ```C
    bool file_backed_initializer (struct page *page, enum vm_type type, void *kva);
    ```
    - 파일로 백업된 페이지를 초기화합니다. 이 함수는 먼저 페이지의 file-backed 페이지에 대한 핸들러를 설정합니다. 페이지 구조체에서 메모리를 백업하는 파일과 같은 몇 가지 정보를 업데이트할 수도 있습니다.
    ```C
    static void file_backed_destroy (struct page *page);
    ```
    - 연관된 파일을 닫아 파일로 백업된 페이지를 소멸시킵니다. 내용이 변경되었다면 변경 사항을 파일에 기록해야 합니다. 이 함수에서는 페이지 구조체를 해제할 필요가 없습니다. file_backed_destroy의 호출자가 처리하도록 합니다.

### Swap In/Out
- 메모리 스와핑은 물리적 메모리 사용을 최대화하기 위한 메모리 회수 기술입니다. 메인 메모리의 프레임이 할당되면 시스템은 더 이상 사용자 프로그램의 메모리 할당 요청을 처리할 수 없습니다. 이럴 때 해결책은 현재 사용되지 않는 메모리 프레임을 디스크로 스왑아웃하는 것입니다. 이렇게 하면 일부 메모리 리소스가 해제되어 다른 애플리케이션에서 사용할 수 있게 됩니다.
- 스와핑은 운영 체제에 의해 수행됩니다. 시스템이 메모리를 모두 소진한 상태에서 메모리 할당 요청을 받으면, 스왑 디스크로 페이지를 밀어내는 방식으로 수행됩니다. 그런 다음, 메모리 프레임의 정확한 상태가 디스크로 복사됩니다. 스왑 아웃된 페이지에 접근하려는 프로세스가 있을 경우, 운영 체제는 정확한 내용을 메모리로 다시 가져와서 페이지를 복구합니다.
- 선택된 페이지는 익명 페이지이거나 파일로 백업된 페이지일 수 있습니다. 이 섹션에서는 각각의 경우를 처리할 것입니다.
- 모든 스왑 작업은 명시적으로 호출되지 않지만, 함수 포인터로 호출됩니다. 이들은 struct page_operations file_ops의 멤버로 있으며, 각 페이지의 초기화 작업으로 등록됩니다.

#### 익명 페이지(Anonymous Page)
- vm_anon_init과 anon_initializer 함수를 vm/anon.c 파일에서 수정하세요. 익명 페이지는 백업 저장소를 가지고 있지 않습니다. 익명 페이지의 스왑을 지원하기 위해 스왑 디스크라고 불리는 임시 백업 저장소를 제공합니다. 스왑 디스크를 활용하여 익명 페이지의 스왑을 구현할 것입니다.
    ```C
    void vm_anon_init (void);
    ```
    - 이 함수에서는 스왑 디스크를 설정해야 합니다. 스왑 디스크에서 빈 영역과 사용 중인 영역을 관리하기 위한 데이터 구조가 필요합니다. 스왑 영역은 PGSIZE (4096 바이트)의 단위로 관리됩니다.
    ```C
    bool anon_initializer (struct page *page, enum vm_type type, void *kva);
    ```
    - 이것은 익명 페이지의 초기화 함수입니다. 스왑을 지원하기 위해 익명 페이지에 일부 정보를 추가해야 합니다.
- 이제 익명 페이지의 스왑을 지원하기 위해 vm/anon.c에 anon_swap_in 및 anon_swap_out을 구현하세요. 페이지를 스왑인하려면 먼저 스왑아웃을 구현하는 것이 좋습니다. 데이터 내용을 스왑 디스크로 이동시키고 안전하게 메모리로 다시 가져와야 합니다.
    ```C
    static bool anon_swap_in (struct page *page, void *kva);
    ```
    - 스왑 디스크에서 데이터 콘텐츠를 읽어 메모리로 익명 페이지를 스왑인합니다. 페이지가 스왑아웃될 때 스왑 디스크에 데이터의 위치를 page 구조체에 저장해야 합니다. 스왑 테이블을 업데이트하는 것을 잊지 마세요 (스왑 테이블 관리(https://casys-kaist.github.io/pintos-kaist/project3/introduction.html) 참조).
    ```C
    static bool anon_swap_out (struct page *page);
    ```
    - 데이터를 메모리에서 디스크로 복사하여 익명 페이지를 스왑 디스크에 스왑아웃합니다. 먼저, 스왑 테이블을 사용하여 디스크에서 빈 스왑 슬롯을 찾은 다음, 데이터 페이지를 해당 슬롯에 복사합니다. 데이터의 위치는 페이지 구조체에 저장되어야 합니다. 디스크에 더 이상 빈 슬롯이 없는 경우, 커널을 패닉 상태로 전환할 수 있습니다.

#### 파일 매핑 페이지(File-Mapped Page)
- 파일 기반 페이지의 내용은 파일로부터 가져오기 때문에, mmap된 파일은 백업 저장소로 사용되어야 합니다. 즉, 파일 기반 페이지를 스왑 아웃할 때는 해당 페이지가 매핑된 파일로 다시 기록됩니다. vm/file.c에서 file_backed_swap_in과 file_backed_swap_out을 구현하세요. 또한, 설계에 맞게 file_backed_init과 file_initializer도 수정해야 할 수 있습니다.
    ```C
    static bool file_backed_swap_in (struct page *page, void *kva);
    ```
    - kva에 위치한 페이지를 파일로부터 읽어와서 스왑 인합니다. 파일 시스템과 동기화해야 합니다.
    ```C
    static bool file_backed_swap_out (struct page *page);
    ```
    - 페이지의 내용을 파일에 다시 씀으로써 페이지를 스왑 아웃합니다. 먼저 페이지가 변경되지 않았는지 확인하는 것이 좋습니다. 변경되지 않았다면 파일 내용을 수정할 필요가 없습니다. 페이지를 스왑 아웃한 후에는 페이지의 dirty 비트를 해제하는 것을 잊지 마세요.

## 2. PROJECT3(VIRTUAL MEMORY) 개념 학습
### 공용체(Union)
1. 공용체란?
    - C, C++ 언어에서 사용되는 특별한 데이터 타입이다.
    - 구조체와 선언 방식이 비슷하지만, 공용체는 모든 멤버가 하나의 저장 공간을 같이 사용한다.<br><br>
2. 공용체 특징
    - 여러 개의 멤버를 가지고 있지만, 동시에 오직 하나의 멤버만 값을 가질 수 있다.
        - 멤버 중 하나에 값을 할당하면 해당 멤버에 저장된 값은 유효한 상태가 되고, 다른 멤버에 저장된 값은 무효화된다.
        - 즉, 공용체 멤버는 언제든지 다른 멤버에 의해 값이 변할 수 있으므로 항상 각 멤버의 값을 확인해야 하는 단점이 있다.
        - 따라서, 공용체는 현재 유효한 멤버에 대해서만 접근이 가능하게 된다.
    - 여러 멤버가 하나의 저장 공간을 공유하므로 메모리를 절약할 수 있고, 특히 같은 공간에 저장된 값을 여러 가지 형태로 사용할 수 있는 장점이 있다.<br><br>
3. 공용체 규칙
    - 공용체 변수의 크기는 멤버 중에서 크기가 가장 큰 멤버로 결정된다.
        - 아래 예제에서 union student의 변수를 선언하면 double형 멤버의 크기인 8바이트의 저장 공간이 할당되고, num과 grade 멤버가 하나의 공간을 공유한다.<br><br>
    - 공용체 변수의 초기화는 중괄호를 사용하여 첫 번째 멤버만 초기화한다.
        - 첫 번째 멤버가 아닌 멤버를 초기화할 때는 멤버 접근 연산자 .로 멤버를 직접 지정해야 한다.
            ```C
            union student a = { .grade = 3.4 }; // grade 멤버를 3.4로 초기화
            ```
        - 첫 번째와 두 번째 학번 출력 결과가 왜 다른걸까?
            - 초기화했던 num 값이 다음에 입력된 grade 멤버에 의해 바뀌었기 때문이다.<br><br>
4. 공용체 예제
    ```C
    #include <stdio.h>

    union student
    {
        int num;
        double grade;
    };

    int main(void) {
        union student s1 = { 315 };

        printf("학번 : %d\n", s1.num);
        s1.grade = 4.4;
        printf("학점 : %d\n", s1.grade);
        printf("학번 : %d\n", s1.num);

        return 0;
    }

    출력결과
    학번 : 315
    학점 : 4.4
    학번 : -1717986918
    ```
    - 첫 번째와 두 번째 학번 출력 결과가 왜 다른걸까?
        - 초기화했던 num 값이 다음에 입력된 grade 멤버에 의해 바뀌었기 때문이다.

### 메모리(Memory)
1. 메모리란?
    - 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 장치이다.
    - 크게 내부 기억장치인 주기억장치와 외부 기억장치인 보조기억장치로 분류된다.

### 주기억장치(Main Memory)
1. 주기억장치란?
    - 크게 RAM(Random Access Memory)와 ROM(Read Only Memory)로 분류된다.
    - 메모리라는 용어는 보통 RAM을 지칭한다.<br><br>
2. RAM의 특징
    - 전원을 끄면 저장된 명령어와 데이터가 모두 날아가는 휘발성 저장 장치(Volatile Memory)이다.<br><br>
3. RAM의 용량과 성능
    - CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 이를 RAM으로 가져와야 할 텐데, RAM 용량이 적다면 보조기억장치에서 실행할 프로그램을 가져오는 일아 잦아 실행 시간이 길어진다.
        - 따라서, RAM 용량이 크면 많은 프로그램들을 동시에 빠르게 실행하는 데 유리하다.
        - 하지만, RAM 용량이 커지면 프로그램 실행 속도가 어느 정도 증가하는 것은 맞지만, 용량이 플요 이상으로 커졌을 때 속도가 그에 비례하여 증가하지는 않는다.<br><br>
4. RAM 종류
    - DRAM(Dynamic RAM)
        - 저장된 데이터가 동적으로 변하는(사라지는) RAM을 의미한다.
        - 즉, 시간이 지나면 저장된 데이터가 점차 사라진다.
        - 따라서, 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화(다시 저장)해야 한다.
        - 이런 단점에도 불구하고 우리가 일반적으로 메모리로써 사용하는 RAM은 DRAM이다.
            - 왜냐하면, 소비 전력이 비교적 낮고, 저렴하고, 집적도가 높기 때문에 대용량으로 설계하기가 용이하기 때문이다.
            - 여기서 "집적도가 높다"는 의미는 "더 작고 빽빽하게 만들 수 있다"는 말이다.<br><br>
    - SRAM(Static RAM)
        - 저장된 데이터가 변하지 않는 RAM을 의미한다.
        - 즉, 시간이 지나도 저장된 데이터가 사라지지 않는다.
        - DRAM 처럼 데이터를 재활성화할 필요도 없고, 속도도 더 빠르다.
        - 집적도가 낮고, 소비 전력도 크며, 가격도 비싸므로, 주로 캐시 메모리에서 사용된다.<br><br>
    - SDRAM(Synchronous Dynamic RAM)
        - 클럭 신호와 동기화된, 발전된 형태의 DRAM이다.
            - "클럭 신호와 동기화되었다"는 말은 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음을 의미한다.
        - 즉, SDRAM은 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 DRAM이다.
            - 한 클럭당 하나씩 데이터를 주고받을 수 있는 SDR SDRAM(Single Data Rate SDRAM)이라고도 한다.<br><br>
    - DDR SDRAM(Double Data Rate SDRAM)
        - 최근 가장 흔히 사용되는 RAM으로, 대역폭을 넓혀 속도를 빠르게 만든 SDRAM이다.
            - 대역폭(Data Rate)란 데이터를 주고받는 길의 너비를 의미한다.
            - 쉽게 말해 대역폭은 흔히 자동차 도로에 비유되며, 한 클럭에 하나씩 정보를 주고받을 수 있는 SDRAM과 비교했을 때 DDR SDRAM은 너비가 두 배인 도로와 같다.
        - 즉, 한 클럭에 한 번씩 CPU와 주고받을 수 있는 SDRAM에 비해 DDR SDRAM은 두 배의 대역폭으로 한 클럭당 두 번씩 CPU와 데이터를 주고받을 수 있다.
        - DDR2 SDRAM, DDR3 SDRAM, DDR4 SDRAM도 있다.<br><br>
5. ROM 특징
    - 전원이 꺼져도 저장된 명령어와 데이터가 모두 유지되는 비휘발성 저장 장치(Non-Valatile Memory)이다.
    - 저정된 데이터를 읽을 수만 있는 기억장치로써 일반적으로 쓰기가 불가능하다.
    - 주로 기본 입출력 시스템, 자가 진단 프로그램 같은 변경 가능성이 없는 시스템 소프트웨어를 기억시키는데 사용한다.<br><br>
6. ROM 종류
    - MROM(Mask ROM)
        - 제조 회사에서 제작할 때 기록하는 기억장치로, 내용 변경이 불가능하다.
    - PROM(Programmable ROM)
        - 한 번에 한해서만 직접 정보를 기록 가능하지만, 한 번 정보가 기록되면 변경이 불가능하다.
    - EPROM(Erassable PROM)
        - 기억된 자료를 자외선을 이용하여 삭제/기록이 가능한 ROM이다.
    - EEPROM(Electrcally EPROM)
        - 기억된 자료를 전기적인 방법으로 삭제/기록이 가능한 ROM이다.
    - EAROM(Rrasable Alterable ROM)
        - 전기적인 방법으로 기록된 정보의 일부를 변경 가능한 ROM이다.

### 보조기억장치(Secondary Memory)
1. 보조기억장치란?
    - 전원을 끄면 저장된 명령어와 데이터가 모두 날아가는 주기억장치의 단점 보완하기 위한 기억장치로 물리적인 디스크가 연결되어 있다.<br><br>
2. 보조기억장치 특징
    - 주기억장치에 비해 속도는 느리지만 전원이 차단되어도 내용이 그대로 유지되고 저장 용량이 크다.
    - CPU가 직접 접근할 수 없으며, 직접적으로 자료 교환이 불가능하다.
    - 접근시간이 오래걸린다.<br><br>
3. 보조기억장치 종류
    - 보조기억장치 종류로는 HDD, SSD, USB, DVD, CD-ROM 등이 있다.<br><br>
    - 하드 디스크(Hard Disk Drive)
        - 하드 디스크란?
            - 자기적인 방식으로 데이터를 저장하는 보조기억장치이며, 자기 디스크(Magnetic Disk)의 일종으로 지칭하기도 한다.
            - 대용량 저장 장치가 필요한 작업이나, 서버실에 자주 출입하는 작업을 수행할 때 자주 사용한다.<br><br>
        - 하드 디스크 구성
            - 우리가 아는 CD나 옛날 음향 장치인 LP처럼 생겼고, 실제로도 비슷하게 동작한다.
            - 플래터(Platter)
                - 실직적으로 데이터가 저장되는 곳으로, 동그란 원판이다.
                - 자기 물질로 덮여 있어 수많은 N극과 S극을 저장한다.
                    - N극과 S극은 0과 1의 역할을 수행한다.
                - CD나 LP에 비해 하드 디스크는 훨씬 더 많은 양의 데이터를 저장해야 하므로 여러 겹의 플래터로 이루어져 있고, 양면을 모두 사용할 수 있다.
            - 스핀들(Spindle)
                - 플래터를 회전시키는 구성 요소이다.
            - RPM(Revolution Per Minute)
                - 플래터를 돌리는 속도는 분당 회전수를 나타내는 단위이다.
            - 헤드(HEAD)
                - 플래터를 대상으로 데이터를 읽고 쓰는 구성 요소이다.
                - 플래터 위에서 미세하게 떠 있는 채로 데이터를 읽고 쓰는, 마치 바늘같이 생긴 부품이다.
                - 양면의 플래터를 사용하면, 위아래로 플래터당 두 개의 헤드가 사용된다.
            - 디스크 암(Disk Arm)
                - 원하는 위치로 헤드를 이동시키는 부품이다.
                - 모든 헤드는 디스크 암에 부착되어 다같이 이동된다.<br><br>
        - 하드 디스크에서의 데이터 저장
            - 플래터는 트랙(Track)과 섹터(Sector)라는 단위로 데이터를 저장한다.
                - 트랙 : 플래터를 여러 동심원으로 나누었을 때 그중 하나의 원이며, 운동장 트랙을 생각하면 이해하기 쉽다.
                - 섹터
                    - 트랙을 여러 조각으로 나누었을 때 한 조각을 섹터라고 한하며, 피자의 한 조각이라고 생각하면 이해하기 쉽다.
                    - 하드 디스크의 가장 작은 전송 단위이며, 일반적으로 512바이트 정도의 크기를 가지고 있지만, 하드 디스크에 따라 차이가 있다.(일부 하드 디스크의 섹터 크기는 4,096바이트)
                    - 블록(Block) : 하나 이상의 섹터를 묶어서 표현한 것이다.
                - 실린더(Cylinder)
                    - 여러 겹의 플래터 상에서 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위이다.
                    - 연속된 정보가 기록된다.
                        - 예를 들어 두 개의 플래터를 사용하는 하드 디스크에서 네 개 섹터에 걸쳐 데이터를 저장할 때는 첫 번째 플래터 윗면, 뒷면과 두 번째 플래터 윗면, 뒷면에 데이터를 저장한다.
                        - 연속된 정보를 하나의 실린더에 기록하는 이유는 디스크 암을 움직이지 않고 바로 데이터에 접근할 수 있기 때문이다.<br><br>
        - 하드 디스크에 저장된 데이터 접근 시간
            - 탐색 시간(Seek Time) : 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간이다.
            - 회전 지연(Rotational latency) : 헤드가 있는 곳으로 플래터를 회전시키는 시간이다.
            - 전송 시간(Transfer Time) : 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간이다.<br><br>
    - 플래시 메모리(Flash Memory)
        - 플래시 메모리란?
            - 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치이다.
            - 우리가 흔히 사용하는 USB 메모리, SD 카드, SSD와 같은 저장 장치를 말한다.<br><br>
        - 플래시 메모리 종류
            - NAND 플래시 메모리
                - NAND 연산을 수행하는 회로(NAND 게이트)를 기반으로 만들어진 메모리이다.
                - 대용량 저장 장치로 많이 사용되는 플래시 메모리이다.<br><br>
            - NOR 플래시 메모리
                - NOR 연산을 수행하하는 회로(NOR 게이트)를 기반으로 만들어진 메모리이다.<br><br>
        - 플래시 메모리 단위
            - 셀(Cell)
                - 플래시 메모리에서 데이터를 저장하는 가장 작은 단위이다.
                - 이 셀이 모여 MB, GB, TB 용량을 갖는 저장 장치기 된다.
                - 한 셀에 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리 종류가 나뉜다.
                    - SLC(Single Level Cell) : 한 셀에 1 비트를 저장할 수 있는 플래시 메모리이다.
                    - MLC(Multiple Level Cell) : 한 셀에 2 비트를 저장할 수 있는 플래시 메모리이다.
                    - TLC(Triple Level Cell) : 한 셀에 3 비트를 저장할 수 있는 플래시 메모리이다.
                    - QLC(Quadra Level Cell) : 한 셀에 4 비트를 저장할 수 있는 플래시 메모리이다.<br><br>
            - 페이지(Page) : 셀들이 모여 만들어진 단위이다.
            - 블록(Block) : 페이지가 모여 만들어진 단위이다.
            - 플레인(Plane) : 블록이 모여 만들어진 단위이다.
            - 다이(Die) : 플레인이 모여 만들어진 단위이다.<br><br>
        - 플래시 메모리 수명
            - 플래시 메모리에는 수명이 있으며, 하드 디스크 또한 수명이 있다.
            - 우리가 사용하는 USB, SSD, SD 카드는 수명이 다하면 더 이상 저장 장치로써 사용이 불가능하다.
                - 마치 종이에 연필로 쓰고 지우개로 지우고를 반복하면 결국 종이가 찢어지는 것처럼 한 셀에 일정 횟수 이상 데이터를 쓰고 지우면 그 셀은 더 이상 데이터를 저장할 수 없기 때문이다.<br><br>
        - SLC, MLC, TLC 타입의 특징
            - 간단하게 사람 한 명을 비트, 셀을 집에 비유하면, SLC 타입은 한집에 한 명, MLC 타입은 한 집에 두 명, TLC 타입은 한집에 세 명이 사는 구조로 비유할 수 있다.<br><br>
            - SLC
                - 한 셀로 두 개의 정보를 표현할 수 있다.
                - MLC나 TLC 타입에 비해 비트의 빠른 입출력이 가능하며, 수명도 길어서 수만에서 수십만 번 가까이 데이터를 쓰고 지우고를 반복할 수 있다.
                - 혼자 살면 감당해야 할 주거 비용이 커지듯이 용량 대비 가격이 높다.
                - 기업에서 데이터를 읽고 쓰기가 매우 많이 반복되며 고성능의 빠른 저장 장치가 필요할 때 사용한다.<br><br>
            - MLC
                - 한 셀로 네 개의 정보를 표현할 수 있다.
                - SLC에 비해 속도와 수명이 떨어지지만, 한 셀에 두 비트씩 저장할 수 있다는 점에서 대용화하기 유리하며, 용량 대비 가격이 저렴하다.
                - 시중에서 사용되는 많은 플래시 메모리 저장 장치들이 MLC 타입 또는 TLC 타입으로 만들어진다.<br><br>
            - TLC
                - 한 셀로 여덟 개의 정보를 표현할 수 있다.
                - SLC와 MLC 타입보다 수명과 속도가 떨어지지만, 한 셀에 세 비트씩 저장할 수 있다는 점에서 대용화하기 유리하며, 용량 대비 가격이 저렴하다.<br><br>
        - 정리
            - 즉, 같은 요량의 플래시 메모리 저장 장치라고 할지라도 셀의 타입에 따라 수명, 가격, 성능이 다르다.
            - 따라서, 썼다 지우기를 자주 반복해야 하는 경우 혹은 높은 성능을 원하는 경우에는 고가의 SLC 탕비을 선택하는 것이 좋다.
            - 저가의 대용량 저장 장치를 원한다면 TLC 타입, 그 중간을 원한다면 MLC 타입의 저장 장치를 선택하는 것이 좋다.<br><br>
        - 플래시 메모리 읽기와 쓰기
            - 플래시 메모리에서 읽기와 쓰기는 페이지 단위로 이루어지며, 삭제는 블록 단위로 이루어진다.<br><br>
            - 페이지는 세 개의 상태를 가진다.
                - Free
                    - 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태이다.
                - Valid
                     - 이미 유효한 데이터를 저장하고 있는 상태이다.
                - Invalid
                    - 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하고 있는 상태이다.
                    - 플래시 메모리는 하드 디스크와는 달리 덮어쓰기가 블가능하여 Valid 상태인 페이지에서는 새 데이터를 저장할 수 없다.

### 가상 메모리(Virtual Memory)
1. 가상 메모리 등장 배경
    - 초창기 컴퓨터에서는 사용 가능한 RAM 용량이 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했다. 그렇지 않을 경우, "메모리 부족"에 의해 애플리케이션을 실행할 수 없었다.
    - 이후 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정하는 "오버레이 기법"을 사용했지만, 메모리 부족 문제를 해결할 수 없었다.
        - 오버레이를 사용하는 프로그램은 메모리를 덜 사용했지만, 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우, 결국 메모리 부족 오류가 발생했다.
    - 더 발전한 가상 메모리 기법은 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 했다. 이런 접근 방식이 가능한 이유는 메모리 접근이 순차적이고 지역화되어 있기 때문이다.
    - 그렇다면 이렇게 애플리케이션의 일부분만 메모리에 올려진다면, 메모리에 올라가지 않는 나머지는 어디에 위치해야 할까?
        - 보조기억장치인 디스크에 저장하는 것이다. 즉, 디스크가 RAM의 보조기억장치처럼 작동하는 것이다.<br><br>
2. 가상 메모리란?
    - 가상 메모리는 실제 물리적인 메모리보다 큰 용량을 가질 수 있도록 해주는 기술로, 프로세스가 실행될 때 전체 프로세스가 메모리에 올라가지 않더라도 실행이 가능하도록 한다.
        - 이를 위해 실제 메모리 주소 대신 가상의 메모리 주소를 사용하며, 운영체제가 가상 주소를 실제 메모리 주소로 변환하여 데이터를 읽고 쓴다.
    - 가상 메모리는 메인 메모리의 한계를 극복하고, 다중 프로그래밍을 지원하며, 운영체제의 메모리 관리를 최적화하는 데 도움을 준다.
        - 즉, 필요한 데이터만 메인 메모리에 올리고, 필요하지 않은 데이터는 보조기억장치에 저장하여 공간을 효율적으로 활용할 수 있도록 해준다.
    - 가상 메모리는 프로세스의 주소 공간을 나누어 페이지 단위로 관리하며, 필요한 페이지만 주 메모리에 올리는 페이지 교체 기법을 사용한다.
        - 페이지 교체 기법은 주 메모리에 공간이 부족한 경우에 가장 오랫동안 참조되지 않은 페이지를 선택하여 보조기억장치로 옮기고, 필요한 페이지를 주 메모리로 로드하는 방식으로 작동한다.
    - 즉, 가상 메모리는 컴퓨터 시스템의 성능과 사용자 경험을 향상시키는 중요한 기술 중 하나입니다.

### 연속 메모리 할당(Contiguous allocation)
1. 연속 메모리 할당이란?
    - 프로세스 A는 A의 크기만큼 메모리 주소를 할당받아 연속적으로 배치되고, 프로세스 B는 프로세스 A 이후에 또 B의 크기만큼 연속적인 메모리 주소를 할당받아 배치되는 방식이다.
    - 즉, 프로세스에 연속적인 메모리 공간을 할당하는 방식이다.<br><br>
2. 연속 메모리 할당의 문제점
    - 연속 메모리 할당으로 인해 외부 단편화(External Fragmentation)이 발생할 수 있다.
    - 외부 단편화란 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생기는데, 이 공강보다 큰 프로세스를 적재하기 어려운 상황을 초래하여 메모리가 낭비되는 현상을 의미한다.
    - 여기서는 외부 단편화에 대해 간단하게 알아봤고, 단편화에 대해 자세하게 알아보기 전에 메모리 할당에 대해 먼저 알아보자.

### 메모리 할당(Memory Allocation)
1. 메모리 할당이란?
    - 컴퓨터 시스템에서 프로그램이나 데이터에 메모리 공간을 할당하는 과정이다.
    - 프로그램이 실행되거나 데이터가 사용되기 위해서는 메모리에 적절한 공간이 필요하다.
    - 따라서, 운영체제 또는 프로그래밍 언어는 이러한 메모리 공간을 할당하고 관리하는 역할을 수행한다.<br><br>
2. 메모리 할당 종류
    - 정적 메모리 할당(Static Memory Allocation)
        - 메모리의 크기가 하드 코딩되어 있기 때문에 프로그램이 실행될 때 이미 해당 메모리의 크기가 결정되는 것이 특징이다.
        - 컴파일 타임에 메모리 공간이 할당되는 방식이다.
        - 장점
            - 해제하지 않음으로 인한 메모리 누수와 같은 문제를 신경쓰지 않아도 된다.
            - 정적 할당된 메모리는 실행 도중에 해제되지 않고, 프로그램이 종료할 때 알아서 운영 체제가 회수한다.
        - 단점
            - 메모리의 크기가 하드 코딩되어 있어서 나중에 조절 할 수 없다.
            - 스택에 할당된 메모리이므로, 동적 할당에 비해 할당 받을 수 있는 최대 메모리에 제약을 받는다.
    - 동적 메모리 할당(Dynamic Memory Allocation)
        - 컴퓨터 프로그래밍에서 실행 시간 동안 사용할 메모리 공간을 할당하는 것이다.
        - 사용이 끝나면 운영체제가 쓸 수 있도록 반납하고, 다음에 요구가 오면 재 할당을 받을 수 있는 것이 특징이다.
        - 동적으로 할당된 메모리 공간은 프로그래머가 명시적으로 함수를 사용해서 해제하거나 쓰레기 수집이 일어나기 전까지 그대로 유지된다.
        - 프로세스의 힙영역에서 할당하므로, 프로세스가 종료되면 운영 체제에 메모리 리소스가 반납되므로 해제된다.
        - 장점
            - 상황에 따라 원하는 크기만큼의 메모리가 할당되므로 경제적이며, 이미 할당된 메모리라도 언제든지 크기를 조절할 수 있다.
        - 단점
            - 더 이상 사용하지 않을 때 명시적으로 메모리를 해제해 주어야 한다.<br><br>
3. 메모리 할당 방식
    - 최초 적합(First Fit)
        - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
        - 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이미ㅡ로 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능하다.
    - 최적 적합(Best Fit)
        - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.
    - 최악 접합(Worst Fit)
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.

### 단편화(Fragmentation)
- 단편화
    - 메모리 공간이 작은 조각으로 나눠져 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태일 떄 발생한다.
- 단편화 종류
    - 내부 단편화
        - 할당된 블록이 요구하는 데이터보다 더 크게 할당되어 사용하는 메모리 공간을 낭비할 때 발생한다.
        - 예를 들어, 아래 그림을 보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbfy5Je%2FbtqTIpMKXVU%2FNGzbVdi7cNZbyfjxxdrHW0%2Fimg.png"></img>
            - 정수는 4바이트이므로 5 * sizeof(int)는 5칸을 차지한다.
            - 하지만, 64바이트에서는 8바이트씩(2칸씩)만 배치할 수 있으므로 2의 배수로 할당해서 6칸을 차지한다.
            - 따라서, 4바이트가 낭비되고 있는 상태이다.
        - 정량화하기가 간단
            - 단순히 할당된 블록의 크기와 이들의 데이터 사이의 차이의 합이다.
    - 외부 단편화
        - 연속 메모리 할당으로 인해 발생하는 문제로 총 메모리 공간은 충분하지만, 요청을 처리할 수 있는 단일한 가용 블록이 없을 때 발생한다.
        - 예를 들어, 아래 그림을 보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSQYyv%2FbtqTF3QMGDL%2FcMgVLmauXSFSISfdR3UZek%2Fimg.png"></img>
            - 현재 여유 메모리는 6칸(24바이트)이나, 4칸과 2칸으로 나누어져 있으므로 24바이트 블록을 할당할 수 없다.
        - 할당기의 요구사항 중 "할당된 블록을 수정하지 않기"로 인해 할당된 블록을 수정하거나 이동이 불가능하여 정렬할 수 없으므로 대응이 어렵다.
        - 내부 단편화보다 측정하기 더 어렵고 예측하기 불가능하기 때문에 할당기들은 대개 많은 수의 더 작은 가용 블록들보다는 더 적은 수의 큰 블록들을 유지하려는 방법을 채택한다.
            - 예를 들어, 8칸을 배정할 경우 4개로 쪼개서 2칸씩 여기저기에 배치하는 것 보다는 8칸짜리로 한 곳에 배치하는 것을 선호한다는 것이다.<br><br>
- 외부 단편화 해결 방법
    - 압축(Compaction)
        - 메모리 조각 모음이라고도 하며, 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 저당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.
        - 즉, 비어있는 메모리 공간을 연속적인 공간으로 만드는 과정이다.
        - 이 과정에서 프로세스를 옮길 때 임시로 복사했다가 다시 가져오는 방식을 사용하므로, I/O Problem을 초래한다.
        - 이 과정에서 오버헤드가 발생할 가능성이 있으며, 이 문제를 해결하기 위해 페이징(Paging) 기법을 사용한다.

### 페이징(Paging)
- 프로세스 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포하고 있다.
    - 외부 단편화
    - 물리 메모리보다 큰 프로세스를 실행할 수 없다.<br><br>
- 가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
    - 이를 가능케 하는 가상 메모리 관리 기법에는 크게 페이징(Paging)과 세그멘테이션(Segmentation)이 있다.
    - 물리 메모리보다 큰 프로세스를 실행할 수 있을 뿐만 아니라 앞선 절에서 배운 외부 단편화 문제도 해결할 수 있는 페이징 기법을 먼저 알아보자.<br><br>
1. 페이징이란?
    - 메모리의 물리 주소 공간(물리 메모리 공간)을 프레임 단위로 자르고, 프로세스의 논리 주소 공간(가상 메모리 공간)을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
    - 페이지의 단위는 보통 4KB이며, 프레임은 특수한 경우가 아닌 이상 페이지 단위와 동일하다.
    - 예를 들어, 200MB 메모리에 50MB 프로세스 A와 100MB 프로세스 C가 들어 있고 각각 30MB와 20MB의 빈 공간이 있다고 하자.
    - 이때, 50MB 프로세스 B를 할당하려고 하면, 공간이 없어 할당 할 수 없다(=외부 단편화).
    - 따라서, 메모리 공간과 프로세스들을 10MB 단위의 일정한 크기로 자르고, 잘린 메모리 조각드에 프로세스 조각들을 불연속적으로 적재할 수 있다면, 외부 단편화는 발생하지 않는다.<br><br>
3. 페이징 장점
    - 유연성 : 프로세스의 주소 공간 사용 방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있다.
        - 예를 들어, 힙과 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도 된다.
    - 단순함 : 페이징이 제공하는 빈 공간 관리가 편리한다.
        - 예를 들어, 운영체제가 64바이트 주소 공간을 8페이지 물리 메모리에 배치하기를 원한다고 할 때, 운영체제는 비어 있는 페이지만 찾으면 된다.
4. 페이징에서의 스와핑
    - 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인이 되는 것이 아닌 페이지 단위로 스왑 아웃/스왑 인이 된다.
    - 즉, 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑인 되는 것이다.
    - 페이징에서 스왑 아웃은 페이지 아웃(Page Out), 스왑 인은 페이지 인(Page In)이라고 부르기도 한다.
    - 이를 다르게 말하면, 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 말과 같다.<br><br>
5. 페이징에서의 첫 번째 문제 : 특정 페이지가 어느 프레임에 적재되어 있는지 모르는 문제
    - 프로세스가 불연속적으로 배치어되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다.
    - 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기 어렵기 때문이다.
    - 이를 해결하기 위해 페이지 테이블을 이용한다.<br><br>
6. 페이지 테이블이란?
    - 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표이다.
    - CPU를 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있도록 해준다.
    - 즉, 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.<br><br>
7. 페이징에서의 두 번째 문제 : 내부 단편화(Internal Fragmentation) 문제 발생
    - 페이징은 외부 단편화 문제를 해결할 수 있지만, 내부 단편화 문제를 야기할 수 있다.
    - 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자른다.
    - 그런데 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것이 아니다. 즉, 프로세스 크기가 꼭 페이지의 배수가 아니라는 말이다.
    - 예를 들어, 페이지 크가기 10KB인데 프로세스의 크기가 108KB라면, 마지막 페이지는 2KB만큼 크기가 남기 때문에 메모리 낭비, 즉 내부 단편화가 발생한다.
    - 내부 단편화를 해결할 수 있는 기법으로는 세그멘테이션(Segmentation) 기법이 있다.<br><br>
8. 페이지 테이블 베이스 레지스터(PTBR, Page Table Base Register)
    - CPU 내의 PTBR은 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
    - 예를 들어, 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 기리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있다.<br><br>
9. 페이지 테이블을 메모리에 뒀을 때의 문제점 : 메모리의 접근 시간 증가
    - 페이지 테이블을 메모리에 두면, 메모리 접근 시간이 두 배로 늘어난다.
        - 메모리에 있는 페이지 테이블을 보기 위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 한 번, 이렇게 총 두 번의 메모리 접근이 필요하기 때문이다.
        - 이를 해결하기 위해 CPU 곁에(일반적으로 MMU 내에) 있는 TLB(Translation Lookaside Buffer)라는 페이지 테이블 캐시 메모리를 이용한다.
        - TLB는 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장한다.
        - 즉, CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우, 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없기 때문에 메모리 접근 시간을 줄일 수 있다.
        - MMU와 TLB에 대한 자세한 내용은 아래에 따로 정리되어 있다.<br><br>
10. 페이징에서의 주소 변환
    - 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있으며, 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.
        - 어떤 페이지 혹은 프레임에 접근하고 싶은가
        - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는가
    - 따라서, 페이징에는 모든 논리 주소가 기본적으로 페이지 번호(Page Number)와 변위(Offset)로 이루어져 있다.
        - 예를 들어, CPU가 32비트 주소를 내보냈다면 이 중 N비트는 페이지 번호, 32 - N비트는 변위로 이루어져 있다.
        - 페이지 번호 : 접근하고자 하는 페이지 번호이다.
        - 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보이다.
    - 즉, 논리 주소(페이지 번호, 변위)는 페이지 테이블을 통해 물리 주소(프레임 번호, 변위)로 변환된다.
        - 이때, 논리 주소와 물리 주소의 변위 값은 같다.<br><br>
11. 페이지 테이블 엔트리
    - 페이지 테이블 엔트리란?
        - 페이지 테이블의 각각의 행들을 의미한다.
        - 지금까지의 페이지 테이블 엔트리에 담기는 정보는 페이지 번호와 프레임 번호였지만, 추가로 유효 비트, 보호 비트, 참조 비트, 수정 비트(=더티 비트)가 있다.
    - 유효 비트(Vaild Bit)
        - 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
        - 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지 알려주는 비트이다.
        - 즉, 페이지가 메모리에 적재되어 있다면 유효 비트가 1, 메모리에 적재되어 있지 않다면 0이 된다.
        - 만약, CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 페이지 폴트(Page Fault)라는 예외(Exception)이 발생한다.
    - 보호 비트(Protection Bit)
        - 페이지 보호 기능을 위해 존재하는 비트이다.
        - 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.
        - 읽기 전용 페이지에 쓰기를 시도하면 운영체제가 이를 막아주며, 이와 같은 방식으로 페이지들을 보호한다.
        - 세 개의 비트로 구성할 수 있다.
            - 읽기 : r / 쓰기 : w / 실행 : x
            - 예를 들어, 보호 비트가 100으로 설정되어 있으면, 해당 페이지는 읽기만 가능한 페이를 의미한다.
    - 참조 비트(Reference Bit)
        - CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타낸다.
        - 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지된다.
    - 수정 비트(Modified Bit)
        - 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
        - 더티 비트(Dirty Bit)라고도 부른다.
        - 이 비트가 1이면 변경된 적이 있는 페이지, 0이면 변경된 적이 없는 페이지임을 나타낸다.
        - 수정 비트가 필요한 이유
            - 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하가 위해서다.
            - CPU는 메모리를 읽기도 하지만 메모리에 값을 쓰기도 하기 때문이다.
            - 예를 들어, CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용은 서로 같은 값을 가지고 있을 것이므로, 페이지가 스왑 아웃될 경우 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 된다.
            - 하지만, 쓰기 작업을 수행한 페이지의 경우 보조기억장치와 메모리에 저장된 페이지의 내용은 서로 다른 값을 가지기 때문에 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 추가 작업이 필요하다.<br><br>

### 계층적 페이징(Hierarchical Paging)
1. 계층적 페이징이 생긴 이유
    - 페이지 테이블의 크기는 생각보다 작지 않다.
    - 프로세스의 크기가 커지면 프로세스 테이블의 크기도 커지므로, 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다.
    - 따라서, 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법으로 계층적 페이징 기법이 등장했다.<br><br>
2. 계층적 페이징이란?
    - 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식이다.
    - 여러 단계의 페이지를 둔다는 점에서 다단계 페이지 테이블(Multilevel Page Table)기법이라고도 한다.
    - 한 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지들을 가리키게 하는 방식이다.
        - 바깥쪽의 페이지 테이블을 Outer 페이지 테이블이라고 하며, CPU와 가장 가까이 위치한 페이지 테이블이므로 항상 메모리에 유지해야 한다.<br><br>
3. 계층적 페이징 장단점
    - 페이지 테이블을 이렇게 계층적으로 구성하면, 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없다.
    - 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재하면 된다.
    - 따라서, 막대한 크기의 페이지 테이블로 인해 낭비되는 공간을 줄일 수 있다.
    - 하지만, 페이지 테이블의 계층이 늘어날수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 반드시 좋다고 볼 수는 없다.<br><br>
4. 계층적 페이징 사용으로 인해 논리 주소 변경
    - 계층적 페이징 사용하지 않는 경우의 논리 주소 구성
        - 변위 + 페이지 번호
    - 계층적 페이징 사용하는 경우의 논리 주소 구성
        - 바깥 페이지 번호 + 안쪽 페이지 번호 + 변위
        - 바깥 페이지 번호 : CPU와 근접한 곳에 위치한(바깥에 위치한) 페이지 테이블 엔트리를 가리킨다.
        - 안쪽 페이지 번호 : 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킨다.
5. 계층적 페이징 논리 주소를 토대로 주소 변환 과정
    - 바깥 페이지 번호를 통해 페이지 테이블의 페이지를 찾는다.
    - 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소를 얻는다.

### 요구 페이징(Demand Paging)
1. 요구 페이징이란?
    - 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법이다.
    - 이름 그대로 실행에 요구되는 페이지만 잭재하는 기법이다.
    - 요구 페이징 시스템이 안정적으로 작동하려면, 필연적으로 페이지 교체와 프레임 할당을 해결해야 한다.<br><br>
2. 요구 페이징 기본적인 양상
    - CPU가 특정 페이지에 접근하는 명령어를 실행한다.
    - 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.
    - 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생한다.
    - 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정하고, 명령어를 재실행한다.<br><br>
3. 순수 요구 페이징(Pure Demand Paging)
    - 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행하여 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트를 계속 발생시키며, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어지게 하는 기법이다.

### 페이지 교체 알고리즘(Page Replacement Algorithm)
1. 페이지 교체 알고리즘이란?
    - 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 된다.
    - 이때, 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다.
    - 즉, 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보낼 지 결정하는 방법이 페이지 교체 알고리즘이다.<br><br>
2. 좋은 페이지 교체 알고리즘이란?
    - 페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려진다.
    - 즉, 어떤 알고리즘을 통해 고른 페이지를 스왑 아웃시켜도 페이지 폴트가 자주 발생하지 않는다면, 이는 컴퓨터의 성능 저하를 방지하는 좋은 알고리즘이다.<br><br>
3. 페이지 폴트 횟수와 페이지 참조열(Page Reference String)
    - 페이지 교체 알고리즘을 제대로 이해하기 위해서는 페이지 폴트 횟수와 페이지 참조열을 알아야 한다.
    - 페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있다.
    - 페이지 참조열이란?
        - CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다.
        - 예를 들어, CPU가 다음과 같은 순서로 페이지에 접근했다고 가정하자.
            - 2, 2, 2, 3, 5, 5, 5, 3, 3, 7
            - 여기서 연속된 페이지를 생략한 페이지열, 즉 아래 숫자열이 페이지 참조열이다.
            - 2, 3, 5, 7
        - 연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문이다.<br><br>
4. 페이지 교체 알고리즘 종류
    - FIFO 페이지 교체 알고리즘(First In First Out Page Replacement Algorithm)
        - 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식으로, 쉽게 말해 "오래 머물렀다면 나가라"는 알고리즘이다.
        - 아이디어와 구현은 간단하지만 마냥 좋은 알고리즘은 아니다.
            - 프로그램 실행 초기에 적재된 페이지 속에는 프로그램 실행 초기에 잠깐 실행되다가 이후에 사용되지 않은 페이지도 있지만, 프로그램 실행 내내 사용될 내용을 포함하고 있을 수 있기 때문이다.
            - 따라서, 메모리에 먼저 적재되었다고 해서 무조건 내쫓아서는 안된다.
    - 2차 기회 페이지 교체 알고리즘(Second Chance Page Replacement Algorithm)
        - FIFO 페이지 교체 알고리즘을 개선한 알고리즘으로, 이름 그대로 한 번 더 기회를 주는 알고리즘이다.
        - FIFO 페이지 교체 알고리즘과 같이 메모리에서 가장 오래 머물렀던 페이지를 대상으로 내보낼 페이지를 선별한다.
        - 만일 페이지의 참조 비트가 1일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정한다.
        - 메모리에 가장 오래 머물렀다고 할지라도 참조 비트가 1이라는 의미는 CPU가 접근한 적이 있다는 의미이므로 한 번의 기회를 더 주는 것이다.
        - 메모리에 가장 오래 머문 페이지의 참조 비트가 0일 경우, 이 페이지는 가장 오래된 페이지이면서 동시에 사용되지 않은 페이지라고 볼 수 있으므로 보조기억장치로 내보낸다.
    - 최적 페이지 교체 알고리즘(Optimal Page Replacement Algorithm)
        - 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.
        - 메모리에 오랫동안 남아야할 페이지는 자주 사용될 페이지이고, 반대로 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지가 내쫖기는 것 비합리적이다.
        - 따라서, 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지이므로, 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적이다.
        - 하지만, 앞으로 오랫동안 사용되지 않을 페이지를 예측하기가 현실적으로 어려워 실제 구현하는 데 어렵다.
        - 따라서, 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용된다.
    - LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement Algorithm)
        - 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어를 토대로 만들어진 알고리즘이다.
        - 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체한다.

### 스래싱(Thrashing)
1. 스래싱이란?
    - 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제를 의미한다.<br><br>
2. 멀티프로그래밍의 정도(Degree Of Multiprogramming)란?
    - 메모리에서 동시 실행되는 프로세스의 수를 의미한다.
    - 멀티프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이고, 낮다면 현재 메모리에는 적은 포로세스가 동시에 실행 중인 것이다.<br><br>
3. 스래싱이 발생하는 원인
    - 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다.
    - 예를 들어, 프로세스 A를 무리 없이 실행하기 위해서는 최소 열 개의 프레임이 필요한데도 불구하고 프로세스 A가 다섯 개의 프레임만 이용할 수 있다면 이 프로세스는 페이지 폴트가 자주 발생하여 스래싱 발생 위험이 높아진다.
    - 따라서, 운영체지는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고, 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다.

### 프레임 할당(Frame Allocation)
1. 프레임 할당 방식
    - 균등 할당(Equal Allocation)
        - 예를 들어, 세 개의 프로세스에 총 300개의 프레임을 할당할 수 있다면, 각 프로세스에 100개의 프로세스를 할당하는 방식이다.
        - 즉, 모든 프로세스에 동일한 프레임을 배분하는 방식이다.
        - 이는 그리 권장할 만한 방법이 아니다.
            - 실행되는 프로세스들의 크기는 각기 다른데, 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적이기 때문이다.
    - 비례 할당(Proportional Allocation)
        - 프로세스의 크기가 크면 프레임을 많이 할당하고, 작으면 적게 할당하는 방식이다.
        - 즉, 프로세스 크기에 따라 프레임을 배분하는 방식이다.
        - 하지만, 프로세스의 크기가 클지라도 막상 실행히 보니 많은 프레임을 필요로 하지 않는 경우도 있고, 프로세스의 크기가 작아도 실행히 보니 많은 프레임을 필요로 하는 경우도 있기 때문에 비례 할당 또한 완벽한 방식은 아니며, 결국 실행해 봐야 아는 경우가 많다.<br><br>
    - 균등 할당과 비례 할당 방식은 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려한 방식이라는 점에서 정적 할당 방식이라고도 한다.<br><br>
    - 작업 집합 모델(Working Set Model)
        - 프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식이다.
        - 작업 집합 모델 기반 프레임 할당 방식은 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 해당 페이지 개수만큼만 프레임을 할당하여 빈번한 페이지 교체를 방지한다.
        - 작업 집합(Working Set) : 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합이다.
    - 페이지 폴트 빈도(PFF, Page Fault Frequency)
        - 아래 두 가개의 가정에서 생겨난 아이디어이다.
            - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
            - 페이지 폴트율일 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다.
        - 페이지 폴트율 기반 프레임 할당은 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식이다.

### 페이지 폴트(Page Fault)
1. 페이지 폴트란?
    - 물리 메모리에 존재하지 않는 페이지를 접근하는 행위를 의미한다.
    - 페이지 폴트가 발생하면, 페이지 폴트를 처리하기 위해 운영체제로 제어권이 넘어가며, 페이지 폴트 핸들러가 실행된다.<br><br>
2. 페이지 폴트 처리 과정
    - 페이지 폴트가 발생하면, 운영체제는 페이지 폴트 핸들러가 실행된다.
    - 운영체제는 페이지 테이블 항목에서 해당 페이지의 디스크 상 위치를 파악하여, 메모리로 스왑해 온다.
    - 디스크 I/O가 완료되면, 운영체제는 해당 페이지 테이블 항목(PTE)의 페이지 프레임 번호(PFN) 값을 탑재된 페이지의 메모리 위치로 갱신한다.
    - 위 작업이 완료되면, 페이지 폴트를 발생시킨 명령어를 재실행한다.
    - 명령어 재실행으로 인해 TLB 미스가 발생될 수 있다.
    - TLB 미스 처리 과정에서 TLB 값이 갱신된다(이를 피하기 위해 페이지 폴트 처리 시, 함께 TLB를 갱신하도록 수행할 수도 있음).
    - 최종적으로, 마지막 재실행 시에 TLB에서 주소 변환 정보를 찾게 되고, 이를 이용하여 물리 주소에서 원하는 데이터나 명령어를 가져온다.<br><br>
3. 메모리에 빈 공간이 없는 경우
    - 스왑 공간으로부터 페이지를 가져올 때 여유 공간이 없을 수도 있다.
    - 탑재하고자 하는 새로운 페이지를 위한 공간을 확보하기 위해 하나 또는 그 이상의 페이지들을 먼저 페이지 아웃하려고 할 수도 있다.
    - 교체 페이지를 선택하는 것을 페이지 교체 정책(Page-Replacement Policy)라고 한다.

### 메모리 관리 장치(MMU, Mamory Management Unit)
1. MMU란?
    - CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 시스템의 하드웨어 구성 요소 중 하나로, 가상 메모리 주소를 실제 메모리 주소로 변환해주는 장치이다.
    - 메모리 보호, 캐시 관리, 버스 중재 등의 역할을 담당하며 간단한 8비트 아키택처에서는 뱅크 스위칭을 담당하기도 한다.<br><br>
2. MMU가 가상 메모리 주소를 실제 메모리 주소로 변환하는 과정  
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Page_table_actions.svg/880px-Page_table_actions.svg.png" style="background-color:white"></img>
    - CPU가 가상 메모리 주소를 MMU에게 넘겨준다.
    - MMU는 그 주소를 받아 실제 메모리 주소로 바꾼다.
    - 이때, 가상 메모리 주소와 실제 메모리 주소 사이의 변환을 위해 MMU는 변환 색인 버퍼(TLB, Translation Lookaside Buffer)라는 고속의 보조기억장치(캐시 메모리)를 사용한다.
    - TLB에서 전달받은 주소에 해당하는 주소가 있으면(TLB hit), 실제 물리 주소가 리턴되고 메모리에 접근한다.
    - TLB에 원하는 정보가 없을 경우(TLB miss), 페이지 테이블(Page Table)을 이용하여 페이지 변환 정보를 얻어온다.
    - 페이지 테이블에 정보가 존재하는 경우(page table hit), 해당 값은 TLB에 쓰이고 그 주소를 갖고 실제 물리 주소로 변환한 후에 메모리에 접근한다.
    - 페이지 테이블에서도 정보를 찾지 못할 경우(page not present), 디스크에서 찾아 그 값을 다시 페이지 테이블과 TLB 순으로 쓰이고 실제 물리 주소로 변환 후에 메모리에 정리한다.<br><br>
3. MMU의 장단점
    - 장점
        - 가상 메모리 관리 : MMU는 가상 메모리 관리를 가능하게 함으로써 프로세스가 동시에 실행될 때 메모리 사용을 최적화하고, 메모리 용량의 한계를 극복할 수 있다.
        - 메모리 보호 : MMU는 메모리 보호 기능을 통해 각 프로세스에게 할당된 메모리 영역을 보호하여 다른 프로세스가 비정상적인 접근을 못하도록 제한한다.
        - 주소 변환 : MMU는 가상 주소를 물리 주소로 변환함으로써 주소 변환을 효율적으로 처리하여 프로세스의 메모리 접근을 가능하게 한다.
        - 페이지 교체 : 페이지 교체 알고리즘을 사용하여 가상 페이지와 실제 페이지를 교체함으로써 메모리 사용의 효율성을 높일 수 있다.
        - 효율적인 메모리 관리 : 가상 메모리와 페이지 단위의 할당은 메모리 공간을 효율적으로 활용하고, 프로세스 간의 메모리 공간을 분리함으로써 충돌이나 간섭을 방지한다.<br><br>
    - 단점
        - 오버헤드 : MMU는 메모리 주소 변환과 페이지 교체 등의 작업을 수행하기 위해 추가적인 연산과 시간이 필요함으로, 프로세스의 실행 속도를 느리게 만들고, 잘못된 페이지 교체 정책이 선택된 경우 성능 저하가 발생할 수 있다.
        - 관리 비용 : 가상 메모리 시스템을 운영하기 위한 페이지 테이블과 같은 데이터 구조를 관리해야 하기 때문에 추가적인 관리 비용을 초래하며, 시스템의 복잡성을 증가시킬 수 있다.
        - 보안 취약성 : MMUS 자체에 결함이 있거나 잘못된 설정이 되었을 경우, 메모리 보호 기능이 제대로 작동하지 않을 수 있어 프로셋스 간의 비정상적인 메모리 접근이 가능해지거나 시스템의 안전성과 보안에 문제가 발생할 수 있다.
        - 프래그먼테이션 : 불연속적인 할당이 발생(프래그먼테이션)할 수 있어 주기억장치의 효율성을 감소시키고, 추가적인 페이지 교체를 유발할 수 있다.

### 세그멘테이션(Segmentation)
1. 세그멘테이션이란?
    - 가상 메모리 관리 기법 중 하나로 프로세스를 일정 크기인 페이지 단위로 잘라서 메모리를 할당하는 방법인 페이징과 다르게 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 나누어 메모리를 할당하는 기법이다.
    - 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서 처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다.<br><br>
2. 세그먼트란?
    - 세그먼트는 메모리의 거의 어느 곳에나 위치할 수 있고, 프로그램 실행을 위해 필요한 공간과 데이터를 처리하는 명령어들을 위한 프로그램이나 메모리의 부분이다.
    - 하나의 프로세스가 실행되기 위해서는 최소 코드, 데이터, 스택 세그먼트가 필요하다.
    - 각각 다른 역할을 하는 내용들을 페이지처럼 일정한 단위로 쪼개는 것이 아니라 같은 역할을 하는 논리적인 단위로 쪼개기 때문에 세그먼트들의 크기는 일정하지 않다.<br><br>
3. 세그멘테이션에서의 메모리 할당 방법
    - 페이징 방법과 동일하며, MMU 내의 재배치 레지스터를 통해서 논리 주소를 물리 주소로 매핑해줌으로써 변경한다.
    - MMU는 세그먼트 테이블로 CPU에서 할당해준 논리 주소에 해당하는 물리 주소의 위치를 가지고 있고, 이 방법을 통해서 CPU는 프로세스가 연속된 메모리 공간에 위치해 있다고 착각을 일으킨다.<br><br>
4. 세그멘테이션에서의 주소 변환 방법
    - 세그멘테이션에서 가상 주소는 VA = (S, D)로 표현되며, S는 세그먼트 번호를 D는 세그먼트 시작 지점에서 해당 주소까지의 거리를 나타낸다.
    - 세그먼트 테이블에 가상 주소 값이 들어가면, 세그먼트 번호는 세그먼트 테이블의 인덱스 값으로 인식하게 된다.
    - 세그먼트 번호를 토대로 세그먼트 테이블에서 시작 위치 주소(Base)를 알아내고, 시작위치 주소와 거리를 더해 물리 주소 위치를 알아낸다.
    - 이때, 이 값이 세그먼트 크기인 시작 위치 주소(Base)와 세그먼트 길이(Limit)를 더한 값 보다 크다면, 메모리를 벗어나는 것이므로 메모리 오류를 출력하고 해당 프로세스를 강제 종료한다.
        - 발생한 오류를 트랩(Trap)이라고 하며, 트랩이 발생하면 운영체제는 사용자에게 세그멘테이션 오류(segmentation fault) 메시지를 보낸다.
    - 작다면 변환된 물리 주소를 반환하고, 물리 메모리에서 변환한 물리 주소에 있는 데이터를 읽거나 쓰는 작업을 할 수 있게 된다.<br><br>
5. 세그멘테이션 장점과 단점
    - 장점
        - 내부 단편화 문제 해결
            - 페이징 기법에서 발생하는 내부 단편화 문제를 해결할 수 있다.
        - 보호 기능
            - 페이징에서는 code, data, stack 영역이 있을 때 일정한 크기로만 나누기 때문에 여러 영역이 섞일 수 있다는 문제점이 있다.
            - 반면, 세그멘테이션에서는 모든 논리 주소들은 세그멘테이션 테이블을 경유하게 되므로 세그먼트 테이블에 r, w, x비트들을 추가해서 해당 세그먼트에 대한 접근 제어를 가능하게 해주는 것을 통해 보호에 대한 이점이 있다.
        - 공유 기능
            - 페이징은 프로세스를 같은 단위로 자르게 되므로 중요한 부분과 중요하지 않은 부분이 같은 페이지 안으로 잘릴 수 있다.
            - 반면, 세그멘테이션은 같은 프로그램을 사용하는 여러 개의 프로세스가 있다면 메모리에 하나만 적재한 뒤, 프로세서의 세그먼트 테이블 코드 영역이 같은 곳을 가리키게 해서 프로세스 간 동일한 세그먼트에 대한 공유가 쉬워진다.
    - 단점
        - 외부 단편화 문제 발생
            - 세그먼트는 크기가 고정되어 있지 않고 가변적이다.
            - 따라서, 크기가 각각 다른 세그먼트를 메모리에 두기 위해서는 동적 메모리를 할당해야 한다.
            - 이렇게 되면 메모리에 불규칙하게 빈 공간이 생기고, 외부 단편화가 발생할 수 있으며, 메모리를 낭비하게 된다.

### 세그멘테이션-페이징 혼용 기법
1. 메모리 접근 권한
    - 메모리 접근 권한은 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한으로 읽기(read), 쓰기(write), 실행(execute), 추가(append) 권한이 있다.
    - 이 네 가지 권한은 복합적으로 사용되는데, 예를 들면 일반적인 데이터에는 읽기 및 쓰기 권한이 적용되고, 상수나 읽기 전용 파일에는 읽기 권한이 적용되며, 일반적인 코드 영역에는 읽기 및 실행 권한이 적용된다.
    - 메모리 접근 권한 구성
        |  구분  | 읽기 | 쓰기 | 실행 |         비고         |
        |:------:|:----:|:----:|:----:|:--------------------:|
        | 모드 0 |   X  |   X  |   X  | 접근 불가            |
        | 모드 1 |   X  |   X  |   O  | 실행만 가능          |
        | 모드 2 |   X  |   O  |   X  | 실제로 사용하지 않음 |
        | 모드 3 |   X  |   O  |   O  | 실제로 사용하지 않음 |
        | 모드 4 |   O  |   X  |   X  | 읽기 전용            |
        | 모드 5 |   O  |   X  |   O  | 읽고 실행 가능       |
        | 모드 6 |   O  |   O  |   X  | 일고 쓰기 가능       |
        | 모드 7 |   O  |   O  |   O  | 제한 없음            |
        - 네 가지 메모리 접근 권한을 모두 조합하면 16(2^4)가지 메모리 제어 방식(access control modes)이 나온다.
        - 그러나, 추가 권한의 경우 해당 데이터의 마지막에 새로운 데이터를 추가하는 것이므로 항상 쓰기 권한이 동반되어야 한다.
        - 읽기 권한 없이 쓰기를 하는 경우는 거의 없기 때문에 실제로 모드 2와 3은 쓰이지 않는다.<br><br>
2. 세그멘테이션-페이징 혼용 기법이란?
    - 페이징 기법과 세그멘테이션 기법은 각각 장단점을 가지고 있다.
    - 페이징 기법은 메모리 관리가 수월한 반면 페이지 테이블의 크기가 크다는 단점이 있다.
    - 세그멘테이션 기법은 테이블 크기를 작게 유지할 수 있는 반면 외부 단편화로 인해 메모리 관리가 어렵다는 단점이 있다.
    - 세그멘테이션-페이징 혼용 기법은 이 둘의 장점을 취한 가상 메모리 관리 기법이다.<br><br>
3. 메모리 접근 권한이 포함된 세그멘테이션-페이징 페이지 테이블  
    <img src="https://media.vlpt.us/images/chappi/post/f6a4a144-4fd8-418d-8bbc-88c879960075/4.png" height="500"></img>
    - 페이지마다 접근 권한이 다르기 때문에 페이지 테이블의 모든 행에는 메모리 접근 권한과 관련된 권한 비트(right bit)가 추가된다.
    - 메모리 관리자는 주소 변환이 이루어질 때마다 페이지 테이블의 권한 비트를 이용하여 유용한 접근인지 아닌지 확인한다.
    - 하지만, 페이지 테이블에 권한 비트가 추가되면 페이지 테이블의 크기가 커진다.
    - 이는 인접한 페이지의 메모리 접근 권한이 같은 경우가 많은데도 불구하고 페이지마다 권한 비트를 설정하여 메모리를 낭비하는 요소가 된다.
    - 따라서, 아래 그림과 같이 세그멘테이션 테이블을 추가하여 반복되는 권한 비트를 줄여야 한다.  
    <img src="https://media.vlpt.us/images/chappi/post/abd42913-0deb-47de-8c2d-a985b3163cb8/5.png" height="400"></img>
    - 페이지로 분할된 가상 주소 공간에서 서로 관련 있는 영역을 하나의 세그먼트로 묶어 세그멘테이션 테이블로 관리하고, 각 세그먼트를 구성하는 페이지를 해당 페이지 테이블로 관리하는 방식이다.
    - 각 세그멘테이션 테이블은 자신과 연결된 페이지 테이블의 시작 주소를 가진다.
    - 이와 같이 페이징 기법에 세그멘테이션 테이블을 추가하고, 권한 비트와 같이 중복되는 데이터를 세그멘테이션 테이블로 옮겨 오면 테이블의 크기를 줄일 수 있다.<br><br>
4. 세그멘테이션-페이징 혼용 기법의 주소 변환  
    <img src="https://media.vlpt.us/images/chappi/post/88bc0925-27f3-45b9-a97d-690c8d3b150a/6.png" height="400"></img>
    - 위 그림은 세그멘테이션-페이징 혼용 기법을 이용한 가상 메모리 시스템의 전체 구조이다.
    - 왼쪽은 사용자 관점에서 본 메모리 구조이고, 오른쪽은 메모리 관리자 관점에서 본 메모리 구조이다.
    - 사용자 입장에서는 기본적으로 세그멘테이션 기법을 사용하고 메모리 관리자 입장에서는 페이징 기법을 사용한다.
    - 세그멘테이션-페이징 혼용 기법에서는 가상 주소를 VA = <S,P,D>로 표현한다.
    - S는 세그먼트 번호, P는 페이지 번호, D는 페이지 처음 위치에서 해당 주소까지의 거리를 의미한다.
    - 세그멘테이션-페이징 혼용 기법에서 가상 주소를 물리 주소로 변환하는 과정은 다음과 같다.
        - 사용자가 어떤 주소에 있는 데이터를 요청하면 해당 주소가 몇 번째 세그먼트의 몇 번째 페이지로 부터 얼마나 떨어져 있는지 계산하여 가상 주소 VA=<S,P,D>를 구한다.
        - 세그멘테이션 테이션 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는 불법 접근이 아닌지, 권한이 없는 페이지에 접근하는 것은 아닌지 등을 확인한다.
            - 만약 권한이 없는 페이지에 접근하거나, 자신에게 주어진 메모리 영역을 벗어나면 세그멘테이션 오류(트랩)을 발생시켜 프로세스를 강제 종료하고, 그렇지 않으면 연결된 페이지 테이블로 간다.
        - 페이지 테이블에 해당 페이지가 어느 프레임에 저장되어있는지 찾는다.
            - 만약 물리 메모리에 프레임이 있다면 메모리에 바로 접근하고, 없다면 스왑 영역에 가서 해당 페이지를 물리 메모리로 가져온다.
        - 물리 메모리에 있는 프레임의 처음 위치에서 D만큼 떨어진 곳에 접근하여 데이터를 읽거나 쓴다.

### 변환 색인 버퍼(TLB, Translation Lookaside Buffer)
1. 페이징의 한계
    - 페이징을 잘못 구현하면 큰 성능 저하를 유발할 수 있다.
    - 가상 주소 변환을 위해 주소 변환에 필요한 정보를 담고 있는 페이지 테이블을 접근(메모리 접근)해야 되기 때문에 성능저하가 발생할 수 있다.<br><br>
2. TLB란?
    - 페이징의 한계를 해결하기 위해 하드웨어의 도움을 받는다.
    - MMU의 일부로서 자주 참조되는 가상 주소의 변환 정보를 저장하는 하드웨어 캐시이며, 주소 변환 캐시(Address-Translation Cache)라고도 부른다.<br><be>
3. TLB의 기본 알고리즘
    ```C
    //하드웨어가 관리하는 TLB
    VPN = (VirtualAddress & VPN_MASK) >> SHIFT
    (Success, TlbEntry) = TLB_Lookup(VPN)
    if (Success == True)// TLB HIT
        if (CanAccess(TlbEntry.ProtectBits) == True)
            Offset = VirtualAddress & OFFSET_MASK
            PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
            AccessMemory(PhysAddr)
        else
            RaiseException(PROTECTION_FAULT)
    else// TLB MISS
        PTEAddr = PTBR + (VPN * sizeof(PTE))
        PTE = AccessMemory(PTEAddr)
        if (PTE.Valid == False)
            RaiseException(SEGMENTATION_FAULT)
        else if (CanAccess(PTE.ProtectBits) == False)
            RaiseException(PROTECTION_FAULT)
        else
            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
            RetryInstruction()
    ```
    - 가상 주소로부터 가상 페이지 번호(VPN, Virtual Page Number)을 추출한다.
    - 해당 가상 페이지 번호가 TLB에 들어있는지 확인한다.
    - 만약 TLB에 들어있다면(TLB 히트), 해당 TLB 항목에서 페이지 프레임 번호(PFN, Page Frame Number)를 추출한다.
    - 해당 페이지에 대한 접근 권한 검사가 성공하면, 그 정보를 원래 가상 주소의 오프셋과 합쳐 원하는 물리 주소(PA)를 구성하고, 메모리에 접근할 수 있다.
    - 만약 TLB에 들어있지 않다면(TLB 미스), 페이지 테이블에 접근하여 주소 변환에 필요한 정보를 TLB에 갱신하고, 해당 명령어를 재실행한다.

### 스와핑(Swapping)
1. 스와핑이란?
    - 메모리에 적재된 프로세스들 중에서 현재 실행되지 않는 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식이다.
    - 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리 주소와는 다른 주소에 적재될 수 있다.<br><br>
2. 스와핑 용어
    - 스왑 영역(Swap Space) : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역이다.
    - 스왑 아웃(Swap Out) : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것이다.
    - 스왑 인(Swap In) : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것이다.<br><br>
3. 스와핑 장점
    - 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

### 쓰기 시 복사(COW, Copy On Write)
1. 쓰기 시 복사란?
    - 부모 프로세스와 동일한 자식 프로세스가 생성되면, 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.
        - 굳이 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 기리킬 수 있다.
        - 만일 두 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 그저 읽기 작업만 이어 나간다면 이 상태가 지숙된다.
    - 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면, 그 순간 해당 페이지가 별도외 공간으로 복제된다.
        - 이때, 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키게 된다.<br><br>
2. 쓰기 시 복사 장점
    - 프로세스 생성 시간을 줄이는 것은 물로 메모리 공간 졀약이 가능하다.
        - 유닉스나 리눅스와 같은 운영체제에서 fork 시스템 호출을 하면, 부모 프로세스의 복사본이 자식 프로세로서 만들어진다.
        - 부모 프로세스의 메모리 영역이 다른 영역에 자식 프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다.
        - 하지만, 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기했다.

## 3. Memory Management : Supplemental Page Table구현
### 목표 🎯
현재 핀토스는 메모리의 가상 및 물리적 매핑을 관리하기 위한 page table(pml4)이 핀토스에 있지만, 이것만으로는 충분하지 않아 page fault 및 리소스 관리를 처리하기 위해 각 page에 대한 추가 정보를 저장할 수 있는 supplementary page table을 구현하는 것이다.

### 핀토스 메모리 개요
1. 현재 핀토스에서의 메모리
    - 현재 주소 공간은 4개의 세그먼트로 구성
        - Stack
        - Initialized Data
        - Uninitialized Data
        - Code
        - Heap은 현재 없는 상태<br><br>
    - 프로세스의 메모리 탑재 과정
        - 각 세그먼트(Stack, Data, BSS, Code)가 물리페이징에 탑재
        - 페이지 테이블 초기화<br><br>
    - 한계
        - Swap 사용 불가
        - Demand Paging 사용 불가
        - Virtual Memory 구현되어 있지 않음
        - 즉, 우리는 현재 핀토스에서 위 기능을 구현해야 함

1. 현재 핀토스 메모리 레이아웃  
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclBFKm%2FbtriBBhzeXm%2FJV138AnUsejuCa5S1UYvik%2Fimg.png"></img>
    - 현재 핀토스에서의 메모리 레이아웃은 위 그림과 같다.
    - 핀토스의 가상 주소 공간은 디스크로부터 ELF 이미지의 세그먼트를 물리 메모리로 읽는다.
    - 이 방법은 물리 메모리를 낭비하는 문제가 발생하기 때문에 물리 메모리 할당 대신 가상 페이지마다 supplemental page table을 통해 적재할 정보들만 관리하도록 구현해야 한다.<br><br>
2. Supplemental Page Table 구현 후, 핀토스 메모리 레이아웃  
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FptTW2%2FbtrhUYSOR96%2FTboSeCocUcEt3XPEakEpL1%2Fimg.png" height="500"></img>
    - 위 그림을 보면, 헤시 테이블을 사용하는 것을 볼 수 있다.
    - 그럼 왜 헤시 테이블을 사용하여 Supplemental Page Table를 구현했을까?🤔

### Supplemental Page Table에서 해시 테이블을 사용하는 이유
- GitBook의 Introduction에서 Choices of implementation(Performance perspective) 부분에 관련 내용이 간단하게 명시되어 있다.<br><br>
1. Choices of implementation(Performance perspective) 내용
    - 구현할 수 있는 선택 사항에는 배열, 리스트, 비트맵 및 해시 테이블이 있습니다. 배열은 종종 가장 간단한 접근 방식이지만, 드물게 채워진 배열은 메모리를 낭비합니다. 리스트도 간단하지만, 특정 위치를 찾기 위해 긴 리스트를 탐색하는 것은 시간 낭비입니다. 배열과 리스트 모두 크기를 조정할 수 있지만, 리스트는 중간에 삽입 및 삭제를 더 효율적으로 지원합니다.
    - 핀토스는 lib/kenel/bitmap.c와 include/lib/kenel/bitmap.h에 비트맵 데이터 구조를 포함하고 있습니다. 비트맵은 각각 참 또는 거짓이 될 수 있는 비트의 배열입니다. 비트맵은 일반적으로 (동일한) 리소스 집합에서 사용량을 추적하는 데 사용됩니다 : 리소스 n이 사용 중이면 비트맵의 비트 n이 참입니다. 핀토스 비트맵은 크기가 고정되어 있지만, 크기 조정을 지원하도록 구현을 확장할 수 있습니다.
    - 핀토스에는 해시 테이블 데이터 구조도 포함되어 있습니다. 핀토스 해시 테이블은 다양한 테이블 크기에 걸쳐 삽입과 삭제를 효율적으로 지원합니다.
    - 데이터 구조가 복잡할수록 더 나은 성능이나 기타 이점을 얻을 수 있지만, 구현이 불필요하게 복잡해질 수도 있습니다. 따라서, 설계의 일부로 고급 데이터 구조(예: 균형 잡힌 이진 트리)를 구현하는 것은 권장하지 않습니다.<br><br>
2. GitBook 내용만으로는 의문이 풀리지 않아서 생각을 좀 더 해봤다.
    - 해시는 key와 value로 데이터를 저장하는 자료구조이다.
    - 내부적으로 배열(bucket 또는 slot)을 이용하여 데이터를 저장하기 때문에 O(1)의 시간복잡도를 가져 데이터를 빠르게 검색할 수 있다.
    - 해시 테이블은 각각의 key값에 해시 함수를 적용하여 배열의 고유한 인덱스를 생성하고, 이 인덱스를 활용하여 값을 저장하고 검색할 수 있다.
    - 따라서, Supplemental Page Table 구현 후, 핀토스 메모리 레이아웃처럼 해시 테이블의 인덱스를 이용하여 실제 주소를 가지고 있는 배열을 찾아 데이터를 찾을 수 있다.
    - 위와 같이 데이터를 저장하고 빠르게 검색할 수 있다는 장점때문에 사용하는 것이 아닐까 생각이 든다(맞는겨???😒).<br><br>

### Supplemental Page Table에서 해시를 사용하기 위한 헤더 추가
```C
/* include/vm/vm.h */
#include "include/lib/kernel/hash.h" // 해시 구조체 사용을 위한 헤더 추가
```
- Supplemental Page Table에서 해시를 사용하기 위해 헤더를 추가한다.

### Supplemental Page Table 구조체 수정
```C
/* include/vm/vm.h */
struct supplemental_page_table {
    struct hash spt_hash; // 해시 구조체 추가
};
```
- Supplemental Page Table을 구현하기 위해 Supplemental Page Table 구조체에 해시 구조체를 추가한다.

### Page 구조체 수정
```C
/* include/vm/vm.h */
struct page {
    const struct page_operations *operations;
    void *va;              /* Address in terms of user space */
    struct frame *frame;   /* Back reference for frame */

    /* Your implementation */
    struct hash_elem hash_elem; // 해시 element 추가

    /* Per-type data are binded into the union.
    * Each function automatically detects the current union */
    union {
        struct uninit_page uninit;
        struct anon_page anon;
        struct file_page file;
#ifdef EFILESYS
        struct page_cache page_cache;
#endif
    };
};
```
- 페이지가 속해 있는 해시 테이블에 연결해주는 해시 테이블 요소인 hash_elem을 추가한다.

### supplementary page table을 초기화하기 위한 supplemental_page_table_init() 함수 구현
- supplemental_page_table_init() 함수를 구현하기 위해서는 hash_init() 함수를 사용해야 한다.
    ```C
    /* lib/kernel/hash.c */
    /* 보조 데이터 AUX를 사용하여 해시 테이블 H를 초기화하여 해시 값을 계산하고, 해시 요소를 비교하기 위해 LESS를 사용합니다. */
    bool hash_init (struct hash *h,
            hash_hash_func *hash, hash_less_func *less, void *aux) {
        h->elem_cnt = 0;
        h->bucket_cnt = 4;
        h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
        h->hash = hash;
        h->less = less;
        h->aux = aux;

        if (h->buckets != NULL) {
            hash_clear (h, NULL);
            return true;
        } else
            return false;
    }
    ```
    - hash_init() 함수는 보조 데이터 AUX를 사용하여 해시 테이블 H를 초기화하여 해시 값을 계산하고, 해시 요소를 비교하기 위해 LESS를 사용한다.
    - hash_init() 함수는 hash_hash_func *hash와 hash_less_func *less 두 함수를 인자로 받는다.
    - 즉, 우리는 보조 데이터 AUX를 사용하여 해시 테이블 H를 초기화하여 해시 값을 계산하는 page_hash() 함수와 해시 요소를 비교하는 page_less() 함수를 구현해야 한다.<br><br>
1. 보조 데이터 AUX를 사용하여 해시 테이블 H를 초기화하여 해시 값을 계산하는 page_hash() 함수 구현
    ```C
    /* vm/vm.c */
    /* 보조 데이터 AUX를 사용하여 해시 테이블 H를 초기화하여 해시 값을 계산하는 함수 */
    unsigned page_hash (const struct hash_elem *p_, void *aux UNUSED) {
        const struct page *p = hash_entry (p_, struct page, hash_elem); // 페이지 p에 들어있는 해시 테이블 시작 주소를 가져옴

        return hash_bytes (&p->va, sizeof p->va); // hash_bytes() 함수를 호출하여 페이지 p의 가상 주소에 대한 해시 값 반환
    }
    ```
    - 페이지 p에 들어있는 해시 테이블 시작 주소를 가져온다.
    - hash_bytes() 함수를 호출하여 페이지 p의 가상 주소에 대한 해시 값을 반환한다.<br><br>
3. 해시 요소를 비교하는 page_less() 함수 구현
    ```C
    /* vm/vm.c */
    /* 해시 요소를 비교하는 함수 */
    bool page_less (const struct hash_elem *a_, const struct hash_elem *b_, void *aux UNUSED) {
        const struct page *a = hash_entry (a_, struct page, hash_elem); // 페이지 a에 들어있는 해시 테이블 시작 주소를 가져옴
        const struct page *b = hash_entry (b_, struct page, hash_elem); // 페이지 b에 들어있는 해시 테이블 시작 주소를 가져옴

        return a->va < b->va; // 첫 번째 페이지의 가상 주소가 두 번째 페이지의 가상 주소보다 작으면 true, 크면 false 반환
    }
    ```
    - 페이지 a와 b에 들어있는 해시 테이블 시작 주소를 각각 가져온다.
    - 두 페이지의 가상 주소를 비교하여 a의 가상 주소가 더 작으면 true, 크면 false를 반환한다.<br><br>
4. supplemental_page_table_init() 함수 구현
    ```C
    /* vm/vm.c */
    /* supplemental page table을 초기화하는 함수 */
    void supplemental_page_table_init (struct supplemental_page_table *spt UNUSED) {
        hash_init (spt, page_hash, page_less, NULL); // 해시 테이블의 해시를 초기화하는 hash_init() 함수 호출하여 supplemental page table을 초기화
    }
    ```
    - supplemental_page_table_init() 함수는 supplemental page table을 초기화한다.
    - 이 함수는 새로운 프로세스가 시작될 때(userprog/process.c의 initd 함수)와 프로세스가 포크될 때(userprog/process.c의 __do_fork 함수) 호출된다.
    - 이 함수가 호출되면, 해시 테이블의 해시를 초기화하는 hash_init() 함수를 호출하도록 수정한다.

### supplementary page table에서 va에 해당하는 구조체 페이지를 찾아 반환하는 spt_find_page() 함수 구현
- supplementary page table을 초기화하기 위한 supplemental_page_table_init() 함수 구현을 완료했다.
- 다음으로는 supplementary page table에서 va에 해당하는 구조체 페이지를 찾아 반환하는 spt_find_page() 함수를 구현해보자.<br><br>
1. GitBook에서 해당 함수를 어떻게 구현해야 하는지 확인해보자.
    ```C
    struct page *spt_find_page (struct supplemental_page_table *spt, void *va);
    ```
    - 주어진 supplemental page table에서 va에 해당하는 struct page를 찾습니다. 실패한 경우 NULL을 반환합니다.<br><br>
2. 구조체 페이지를 찾아 반환하는 것 까지는 알았고, 한양대 핀토스 PPT를 통해 좀 더 자세하게 살펴보자(함수명이 다름).
    ```C
    struct vm_entry *find_vme (void *vaddr) {
        // pg_round_down()으로 vaddr의 페이지 번호를 얻음
        // hash_find() 함수를 사용해서 hash_elem 구조체 얻음
        // 만약 존재하지 않는다면 NULL 리턴
        // hash_entry()로 해당 hash_elem의 vm_entry 구조체 리턴
    }
    ```
    - GitBook과 카이스트 핀토스 PPT만 보고, 어떻게 구현해야 할지 몰랐는데 위 주석을 바탕으로 구현하면 될 것 같다.<br><br>
3. spt_find_page() 함수 구현
    ```C
    /* vm/vm.c */
    /* supplementary page table에서 va에 해당하는 구조체 페이지를 찾아 반환하는 함수(실패할 경우 NULL 반환) */
    struct page *spt_find_page (struct supplemental_page_table *spt UNUSED, void *va UNUSED) {
        struct page *page = NULL; // 페이지 구조체 포인터 변수 초기화

        page = (struct page*) malloc (sizeof (struct page)); // dummy page 생성
        struct hash_elem *e;

        page->va = pg_round_down (va); // va가 가리키는 가상 페이지의 시작 포인트 반환
        e = hash_find (&spt->spt_hash, &page->hash_elem); // hash에서 hash_elem과 같은 요소를 검색해서 발견한 element가 있으면 element를, 아니면 NULL 반환

        free (page); // dummy page 해제

        return e != NULL ? hash_entry (e, struct page, hash_elem) : NULL; // e가 NULL이 아니면 hash_entry() 함수로 hash_elem이 포함된 페이지를 찾아 반환하고, 아니면 NULL 반환
    }
    ```
    - Dummy page를 생성하여 dummy page에 있는 hash_elem를 통해 offset을 지운 va에 접근할 수 있도록 한다.
    - pg_round_down() 함수를 이용하여 va가 가리키는 가상 페이지의 시작 포인트를 반환한다.
    - hash_find() 함수를 이용하여 hash에서 hash_elem과 같은 요소를 검색해서 발견한 element가 있으면 element를, 아니면 NULL 반환한다.
    - 이때, dummy page는 free() 함수를 이용하여 해제한다.
    - 마지막으로 e가 NULL이 아니면 hash_entry() 함수로 hash_elem이 포함된 페이지를 찾아 반환하고, 아니면 NULL 반환한다.

### 페이지를 유효성 검사를 수행하여 supplemental page talbe에 삽입하는 spt_insert_page() 함수 구현
```C
/* vm/vm.c */
/* 페이지를 유효성 검사를 수행하여 spt에 삽입하는 함수 */
bool
spt_insert_page (struct supplemental_page_table *spt UNUSED,
		struct page *page UNUSED) {		
	return hash_insert(&spt->spt_hash, &page->hash_elem) == NULL ? true : false; // hash_insert() 함수 반환값이 NULL이면 true, 아니면 false 반환
}
```
- hash_insert() 함수 반환값이 NULL이면, 해시 테이블에 정상적으로 삽입된 것이기 때문에 true를 반환하고, 아니면 false를 반환한다.

## 4. Memory Management : Frame Table 구현
### 목표 🎯
- 모든 페이지는 생성될 때 메모리의 메타데이터만을 담고 있는 것이 아니기 때문에 물리 메모리를 관리하기 위해 다른 방식이 필요하다. 물리 메모리를 관리하기 위해 물리 메모리 내 각 프레임 정보를 갖고 있는 frame table을 구현하는 것이 목표이다.

### Frame 구조체에 프레임 리스트 추가
- Frame table을 구현하기 전, frame 구조체를 살펴보자.
    ```C
    /* include/vm/vm.h */
    /* The representation of "frame" */
    struct frame {
        void *kva;
        struct page *page;
        struct list_elem frame_elem; // frame_table을 위한 list_elem 추가
    };
    ```
    - 현재 struct frame은 두 개의 필드만을 가지고 있다.
    - 커널 가상 주소를 나타내는 kva와 매핑될 페이지 구조를 나타내는 page만 있는 상태이다.
    - 프레임을 리스트로 관리하기 위해 list_elem을 프레임 구조체에 새로 추가한다.

### user pool에서 새로운 physical page를 가져와서 새로운 frame 구조체에 할당해서 반환하는 vm_get_frame() 함수 구현
```C
/* vm/vm.c */
/* user pool에서 새로운 물리 페이지를 가져와서 새로운 frame 구조체에 할당해서 반환하는 함수 */
static struct frame * vm_get_frame (void) {
	struct frame *frame = NULL; // 프레임 구조체 포인터 변수 초기화
	/* TODO: Fill this function. */

	void *kva = palloc_get_page (PAL_USER); // 물리 페이지를 할당하고 해당 페이지의 커널 가상 주소를 반환하는 palloc_get_page() 함수를 호출하여 사용자 풀에서 새로운 물리적 페이지 가져옴

	// 페이지 할당에 실패한 경우(palloc_get_page() 함수에서 사용 가능한 페이지가 없어 NULL 포인터가 반환된 경우) 패닉 메시지 출력
	if (kva == NULL)
		PANIC ("todo");

	// 페이지 할당에 성공한 경우, 프레임을 할당하고 멤버 초기화
	frame = (struct frame *) malloc (sizeof (struct frame));
	frame->kva = kva;
	frame->page = NULL;

	ASSERT (frame != NULL);
	ASSERT (frame->page == NULL);
	return frame;
}
```
- 물리 페이지를 할당하고 해당 페이지의 커널 가상 주소를 반환하는 palloc_get_page() 함수를 호출하여 사용자 풀에서 새로운 물리적 페이지를 가져온다.
- 만약, 페이지 할당에 실패한 경우 패닉 메시지를 출력한다.
    - 페이지 할당에 실패한 경우란 palloc_get_page() 함수에서 사용 가능한 페이지가 없어 NULL 포인터가 반환된 경우이다.
    - 패닉 메시지는 OS를 중지시키고, 소스 파일명, 라인 번호, 함수명 등의 정보와 함께 사용자 지정 메시지를 출력해 준다.
- 페이지 할당에 성공한 경우, 프레임을 할당하고 멤버를 초기화 한다.

### 새 프레임을 가져와서 페이지와 매핑하는 vm_do_claim_page() 함수 구현
```C
/* vm/vm.c */
/* 새 프레임을 가져와서 페이지와 매핑하는 함수 */
static bool
vm_do_claim_page (struct page *page) {
	struct frame *frame = vm_get_frame (); // vm_get_frame()를 호출하여 프레임을 가져옴

	/* Set links */
	// 페이지와 프레임 링크 설정
	frame->page = page;
	page->frame = frame;

	/* TODO: Insert page table entry to map page's VA to frame's PA. */
	struct thread *curr = thread_current ();
	pml4_set_page (curr->pml4, page->va, frame->kva, page->writable); // pml4_set_page() 함수를 호출하여 프로세스의 pml4에 페이지 가상 주소와 프레임 물리 주소를 서로 매핑한 결과 저장

	return swap_in (page, frame->kva);
}
```
- vm_get_fram() 함수를 호출하여 프레임을 가져온다.
- 페이지와 프레임 링크를 설정해준다.
- pml4_set_page() 함수를 호출하여 프로세스의 pml4에 페이지 가상 주소와 프레임 물리 주소를 서로 매핑한 결과를 저장한다.
    - 성공한 경우 true를 반환하고, 메모리 할당에 실패한 경우 false를 반환합니다.

### Supplemental page table에서 va에 해당하는 페이지를 가져와 프레임과 매핑을 요청하는 vm_claim_page() 함수 구현
```C
/* vm/vm.c */
/* Supplemental page table에서 va에 해당하는 페이지를 가져와 프레임과 매핑을 요청하는 함수 */
bool
vm_claim_page (void *va UNUSED) {
	struct page *page = NULL; // 페이지 구조체 초기화
	/* TODO: Fill this function */

	page = spt_find_page (&thread_current ()->spt, va); // spt_find_page() 함수를 호출하여 va에 해당하는 페이지 가져옴

	// va에 해당하는 페이지가 없을 경우(=NULL) false 반환
	if (page == NULL)
		return false;

	return vm_do_claim_page (page); // va에 해당하는 페이지를 가져오는데 성공한 경우, 페이지와 프레임을 매핑하는 vm_do_claim_page() 함수 호출 
}
```
- spt_find_page() 함수를 호출하여 va에 해당하는 페이지를 가져온다.
    - 만약, va에 해당하는 페이지가 없을 경우에는 false를 반환하고, 성공하면 페이지와 프레임을 매핑하는 vm_do_claim_page() 함수를 호출한다.

## 5. Anonymous Page 구현
### 목표 🎯
- 디스크 기반이 아닌 익명 페이지라고 불리는 이미지를 구현하는 것이 목표이다.

### 전달된 vm_type에 따라 적합한 초기화 함수를 가져와서 uninit_new() 함수를 호출하는 vm_alloc_page_with_initializer() 함수 구현
- 깃북 내용을 먼저 확인해 보자.
    - 깃북을 보면 세 가지 종류의 페이지가 있으며, 각 페이지 유형에 따라 초기화 루틴이 다르다고 한다.
    - 커널이 새로운 페이지를 요청 받으면 vm_alloc_page_with_initializer() 함수가 호출된다.
    - 이 함수는 페이지 구조체를 할당하고, 페이지 유형에 따라 적절한 초기화 함수를 설정하여 새로운 페이지를 초기화한 다음, 제어를 사용자 프로그램에 반환한다.
    - 사용자 프로그램이 실행되는 동안 특정 시점에서 page fault가 발생하는데, 프로그램이 아직 내용이 없는 페이지에 접근하려고 했기 때문이다.
    - page fault 처리 절차 중에 uninit_initialize 함수가 호출된고, 이전에 설정한 initializer를 호출한다.
    - initializer는 익명 페이지에 대해 anon_initializer를 사용하고, 파일 기반 페이지에 대해서는 file_backed_initializer를 사용한다.<br><br>
- 깃북 내용을 바탕으로 m_alloc_page_with_initializer() 함수를 구현해 보자.
    ```C
    /* vm/vm.c */
    /* 전달된 vm_type에 따라 적합한 초기화 함수를 가져와서 uninit_new() 함수를 호출하는 함수 */
    bool vm_alloc_page_with_initializer (enum vm_type type, void *upage, bool writable,
            vm_initializer *init, void *aux) {

        ASSERT (VM_TYPE(type) != VM_UNINIT)

        struct supplemental_page_table *spt = &thread_current ()->spt;

        if (spt_find_page (spt, upage) == NULL) { // upage가 이미 사용 중인지 확인
            struct page *p = (struct page *) malloc (sizeof (struct page)); // 페이지 구조체를 할당
            bool (*page_initializer) (struct page *, enum vm_type, void *); // type에 따른 초기화 함수를 가져옴

            // VM_TYPE에 따라 서로 다른 initializer를 가져옴
            // anon 타입이면 anon_initializer를, file_backed 타입이면 file_backed_initializer
            switch (VM_TYPE (type)) {
                case VM_ANON:
                    page_initializer = anon_initializer;
                    break;
                case VM_FILE:
                    page_initializer = file_backed_initializer;
                    break;
            }

            uninit_new (p, upage, init, type, aux, page_initializer); // uninit 타입의 페이지로 초기화
            p->writable = writable; // 매개변수 writable을 페이지 구조체의 writable 필드에 할당

            return spt_insert_page (spt, p); // 생성한 페이지를 supplemental page table에 추가
        }
    err:
        return false;
    }
    ```
    - 전달된 vm_type에 따라 적합한 초기화 함수를 가져와서 uninit_new를 호출할 수 있도록 구현해야 한다.
    - spt_find_page() 함수를 이용하여 upage가 이미 사용 중인지 확인한다.
        - supplementary page table에서 va에 해당하는 구조체 페이지를 찾아 반환된 값이 NULL이 아니어야 한다.
    - 사용 가능한 페이지를 찾았다면, 해당 페이지에 페이지 구조체를 할당한다.
    - 페이지 타입에 따른 초기화 함수를 우선 가져온다.
    - VM_TYPE이 익명 페이지라면 anon_initializer를 사용하고, 파일 기반 페이지라면 file_backed_initializer를 사용할 수 있도록 switch 문을 이용하여 구현한다.
    - uinit_new() 함수를 이요하여 uninit 타입의 페이지로 초기화 한다.
        모든 페이지는 초기에 VM_UNINIT 페이지로 생성되기 때문이다.
    - 매개변수 writable을 페이지 구조체의 writable 필드에 할당한 후, 생성한 페이지를 supplemental page table에 추가한다.<br><br>

### lazy load 방식 구현
- 프로젝트 2까지 프로세스가 실행될 때 segment를 실제 물리 메모리에 직접 load하는 방식이었다.
- 따라서, page fault가 커널이나 유저 프로그램에서 나타나는 버그였다.
- 이제는 supplemental page table에 필요한 정보들만 넣어서 page fault가 발생했을 경우(즉, 페이지가 요청된 경우) 메모리에 로드하는 방식인 lazy load로 바꿔야 한다.
- 그러기 위해서는 process.c의 load_segment()와 lazy_load_segment() 함수를 수정해야 한다.<br><br>
1. 파일의 내용을 upage에 로드하는 load_segment() 함수 수정
    ```C
    /* userprog/process.c */
    /* 파일의 내용을 upage에 로드하는 함수 */
    static bool load_segment (struct file *file, off_t ofs, uint8_t *upage, uint32_t read_bytes, uint32_t zero_bytes, bool writable) {
        ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0); // read_bytes + zero_bytes가 페이지 크기(PGSIZE)의 배수인지 확인
        ASSERT (pg_ofs (upage) == 0); // upage가 페이지 정렬이 되어 있는지 확인
        ASSERT (ofs % PGSIZE == 0); // ofs가 페이지 정렬이 되어 있는지 확인

        while (read_bytes > 0 || zero_bytes > 0) { // read_bytes와 zero_bytes가 0보다 큰 동안 반복문 수행
            /* Do calculate how to fill this page.
            * We will read PAGE_READ_BYTES bytes from FILE
            * and zero the final PAGE_ZERO_BYTES bytes. */
            /* 이 페이지를 어떻게 채울지 계산해주세요.
            우리는 파일에서 PAGE_READ_BYTES 바이트를 읽고, 마지막 PAGE_ZERO_BYTES 바이트를 0으로 초기화할 것입니다. */
            size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE; // upage에서 읽어야 하는 바이트 수 계산(read_bytes가 PGSIZE보다 작으면 Read_bytes를, 아니면 PGSIZE를 반환)
            size_t page_zero_bytes = PGSIZE - page_read_bytes; // 0으로 채워야 하는 바이트 수 계산(PGSIZE에서 read_bytes를 뺀 값)

            /* TODO: Set up aux to pass information to the lazy_load_segment. */
            /* vm_alloc_page_with_initializer에 제공할 aux 인수로 필요한 보조 값들을 설정해야 한다. */
            // void *aux = NULL; // 주석 처리
            struct lazy_load_arg *lazy_load_arg = (struct lazy_load_arg *) malloc (sizeof (struct lazy_load_arg)); // 파일 내용을 로딩하기 위해 필요한 정보를 포함하는 구조체 생성
            // 파일의 내용을 로딩할 때 전달할 각 정보 할당
            lazy_load_arg->file = file;
            lazy_load_arg->ofs = ofs;
            lazy_load_arg->read_bytes = page_read_bytes;
            lazy_load_arg->zero_bytes = page_zero_bytes;

            if (!vm_alloc_page_with_initializer (VM_ANON, upage, writable, lazy_load_segment, lazy_load_arg)) // vm_alloc_page_with_initializer() 함수를 호출하여 대기 중인 객체 생성
                return false;

            /* Advance. */
            // 다음 반복을 위해 읽어들인 만큼 값 갱신
            read_bytes -= page_read_bytes;
            zero_bytes -= page_zero_bytes;
            upage += PGSIZE;
            ofs += page_read_bytes;
        }
        return true;
    }
    ```
    - 이 함수는 파일의 내용을 upage에 로드하는 함수로, 프로세스가 실행될 때 실행 파일을 현재 스레드로 로드하는 함수인 load 함수에서 호출된다.
    - 파일의 내용을 로드하기 위해 upage를 할당할 page가 필요한데, 위에서 구현한 vm_alloc_page_with_initializer() 함수를 호출하여 페이지를 생성한다.
    - 우리는 lazy loading을 사용해야 하므로 여기서 바로 파일의 내용을 로드하지 않아야 하며, page에 내용을 로드할 때 사용할 함수와 필요한 인자들을 넣어줘야 한다.
        - 내용을 로드할 때 사용할 함수로는 아래에서 수정할 lazy_load_segment() 함수를 사용하고, 인자는 아래와 같이 직접 구조체로 만들어서 vm_alloc_page_with_initializer() 함수의 마지막 인자로 넘겨줘야 한다.
            ```C
            /* userprog/process.c */
            /* 내용을 로드할 때 vm_alloc_page_with_initializer() 함수로 넘겨줘야 할 인자를 가지고 있는 구조체 */
            struct lazy_load_arg {
                struct file *file;
                off_t ofs;
                uint32_t read_bytes;
                uint32_t zero_bytes;
            };
            ```
            - file : 로드할 파일의 내용이 담긴 파일 객체
            - ofs : upage에서 읽기 시작할 위치
            - read_bytes : upage에서 읽어야 하는 바이트 수
            - zero_bytes : upage에서 read_bytes만큼 읽고 공간이 남아 0으로 채워야 하는 바이트 수<br><br>
2. 실행 파일의 내용을 페이지로 로딩하는 lazy_load_segment() 함수 수정
    ```C
    /* userprog/process.c */
    /* 실행 파일의 내용을 페이지로 지연 로딩하는 함수 */
    static bool lazy_load_segment (struct page *page, void *aux) {
        /* TODO: Load the segment from the file */
        /* TODO: This called when the first page fault occurs on address VA. */
        /* TODO: VA is available when calling this function. */
        struct lazy_load_arg *lazy_load_arg = (struct lazy_load_arg *)aux;

        file_seek (lazy_load_arg->file, lazy_load_arg->ofs); // 파일의 위치를 ofs로 설정

        // 파일을 read_bytes만큼 물리 프레임에 읽어들여 제대로 읽어오면 페이지를 free시키고 false를 반환
        if (file_read (lazy_load_arg->file, page->frame->kva, lazy_load_arg->read_bytes) != (int) (lazy_load_arg->read_bytes)) {
            palloc_free_page (page->frame->kva);
            return false;
        }

        // 다 읽은 지점부터 zero_bytes만큼 0으로 채움
        memset (page->frame->kva + lazy_load_arg->read_bytes, 0, lazy_load_arg->zero_bytes);
        
        return true;
    }
    ```
    - 이제 우리는 load_segment() 함수에서 vm_alloc_page_with_initializer() 함수의 네 번째 인자로 lazy_load_segment() 함수가 전달되는 것을 알 수 있다.
    - 이 함수는 실행 파일의 내용을 페이지로 로딩하는 함수이며, 첫 번째 page fault가 발생했을 때 호출된다.
    - 페이지 구조체와 aux를 인자로 받으며, aux에는 load_segment() 함수에서 설장한 정보가 포함되어 있다.
    - 이 정보를 이용하여 읽어들일 파일을 찾고, 메모리에 로드한다.
    - 성공하면 true를 반환하고, 메모리 할당 오류 및 disk 읽기 오류가 발생하면 false를 반환한다.

### 스택의 페이지를 생성하는 setup_stack() 함수 수정
```C
/* 스택의 페이지를 생성하는 함수 */
static bool
setup_stack (struct intr_frame *if_) {
	bool success = false;
	void *stack_bottom = (void *) (((uint8_t *) USER_STACK) - PGSIZE); // 스택은 아래로 성장하므로, USER_STACK에서 PGSIZE 만큼 아래로 내린 지점(stack_bottom)에서 페이지를 생성

	/* TODO: Map the stack on stack_bottom and claim the page immediately. -> tack_bottom에 스택을 매핑하고 페이지를 즉시 요청하세요.
	 * TODO: If success, set the rsp accordingly. -> 성공하면, rsp를 그에 맞게 설정하세요.
	 * TODO: You should mark the page is stack. -> 페이지가 스택임을 표시해야 합니다. */
	// 익명 페이지로 만들 UNINIT 페이지를 stack_bottom에서 위로 PGSIZE만큼(1 PAGE) 생성
	// TYPE에 VM_MARKER_0 flag를 추가함으로써 이 페이지가 STACK에 있다는 것을 표시
	if (vm_alloc_page_with_initializer(VM_ANON | VM_MARKER_0, stack_bottom, 1, NULL, NULL))
	{
		success = vm_claim_page(stack_bottom); // 할당 받은 페이지에 바로 물리 프레임을 매핑
		// 매핑에 성공하면, rsp를 USER_STACK으로 변경
		// argument_stack에서 이 위치(rsp)부터 인자를 push하게 됨
		if (success)
			if_->rsp = USER_STACK;
	}
	return success;
}
```
- 기존의 setup_stack() 함수를 supplemental page table이 추가된 상황에 맞게 수정시켜줘야 한다.
- 이 함수는 load() 함수 안에서 호출되며, 스택의 페이지를 할당하고, 바로 물리 메모리에 매핑시켜 준다.
    - 즉, page fault가 발생하기 전에 물리 메모리에 바로 할당하는 것이다.
    - 왜냐하면, 첫 번째 스택 페이지는 lazy loading을 할 펼요가 없기 때문이다.

### page_fault가 발생하면 제어권을 전달 받는 vm_try_handle_fault() 함수 수정
```C
/* page fault가 발생하면 제어권을 전달 받는 함수 */
bool vm_try_handle_fault (struct intr_frame *f UNUSED, void *addr UNUSED, bool user UNUSED, bool write UNUSED, bool not_present UNUSED) {
	struct supplemental_page_table *spt UNUSED = &thread_current ()->spt;
	struct page *page = NULL;
	// 인자로 받은 주소가 NULL인 경우 false 반환
	if (addr == NULL)
		return false;
	// 인자로 받은 주소가 커널 영역에 있는 주소인 경우 false 반환
	if (is_kernel_vaddr (addr))
        return false;
	// 접근한 메모리의 물리 페이지가 존재하지 않는 경우
	if (not_present) {
		page = spt_find_page (spt, addr); // supplemental page table에서 해당 주소에 해당하는 페이지가 있는지 확인
		// 페이지가 존재하지 않는 경우 false 반환
		if (page == NULL)
			return false;
		 // write 불가능한 페이지에 write 요청한 경우 false 반환
		if (write == 1 && page->writable == 0)
			return false;
		// 페이지가 존재하는 경우 vm_do_claim_page() 함수를 호출
		return vm_do_claim_page (page);
	}
	// not_present 값이 false인 경우 false 반환
	// 물리 프레임이 할당되어 있지만, page fault가 일어난 경우로 read only page에 write한 경우이므로 예외 처리 필요
	return false;
}
```
- spt_find_page() 함수를 통해 supplemental page table을 참조하여 faulted address에 해당하는 페이지 구조체를 해결하기 위해 vm_try_handle_fault() 함수를 수정해야 한다.

### Supplemental Page Table - Revisit 구현
- 현재는 프로젝트 2의 fork 관련 테스트가 실패하는데 자식 프로세스를 생성할 때 사용되는 함수를 구현하지 않았기 때문이다.
- 따라서, 우리는 자식 프로세스를 생성하거나 프로세스가 종료될 때 필요한 supplemental page table을 복사하는 함수와 정리하는 함수를 구현해야 한다.<br><br>
1. 자식 프로세스를 생성할 때 부모 프로세스의 supplemental page table을 자식에서 복사하는 supplemental_page_table_copy() 함수 구현
    ```C
    /* 자식 프로세스를 생성할 때 부모 프로세스의 supplemental page table을 자식에서 복사하는 함수 */
    bool supplemental_page_table_copy (struct supplemental_page_table *dst UNUSED, struct supplemental_page_table *src UNUSED) {
        // TODO: 보조 페이지 테이블을 src에서 dst로 복사합니다.
        // TODO: src의 각 페이지를 순회하고 dst에 해당 entry의 사본을 만듭니다.
        // TODO: uninit page를 할당하고 그것을 즉시 claim해야 합니다.
        struct hash_iterator i;
        hash_first (&i, &src->spt_hash);
        while (hash_next (&i))
        {
            // src_page 정보
            struct page *src_page = hash_entry (hash_cur (&i), struct page, hash_elem);
            enum vm_type type = src_page->operations->type;
            void *upage = src_page->va;
            bool writable = src_page->writable;

            // type이 VM_UNINIT인 경우
            if (type == VM_UNINIT) {
                // UNINIT 페이지 생성 및 초기화
                vm_initializer *init = src_page->uninit.init;
                void *aux = src_page->uninit.aux;
                vm_alloc_page_with_initializer (VM_ANON, upage, writable, init, aux);
                continue;
            }

            // type이 VM_UNINIT이 아닌 경우(file_backed page) false 반환
            if (!vm_alloc_page_with_initializer (type, upage, writable, NULL, NULL))
                return false;

            // vm_claim_page() 함수를 호출하여 매핑 및 페이지 타입에 맞게 초기화하고, 실패한 경우 false 반환
            if (!vm_claim_page (upage))
                return false;

            // 매핑된 프레임에 내용 로딩
            struct page *dst_page = spt_find_page (dst, upage);
            memcpy (dst_page->frame->kva, src_page->frame->kva, PGSIZE);
        }
        return true;
    }
    ```
    - 이 함수는 자식 프로세스를 생성할 때 부모 프로세스의 supplemental page table을 자식에서 복사하는 함수이다.
    - 부모 프로세스의 supplemental page talbe에 있는 모든 페이지를 각 타입에 맞게 할당 받고, UNINIT 상태가 아니라면 바로 해당 페이지를 매핑하여 내용을 복사한다.
    - file_backed page인 경우에는 추가로 예외 처리가 필요하다.<br><br>
2. supplemental page table의 리소스를 해제하는 supplemental_page_table_kill() 함수
    ```C
    /* supplemental page table의 리소스를 해제하는 함수 */
    void supplemental_page_table_kill (struct supplemental_page_table *spt UNUSED) {
        /* TODO: Destroy all the supplemental_page_table hold by thread and
        * TODO: writeback all the modified contents to the storage. */
        hash_clear (&spt->spt_hash, hash_page_destroy); // 해시 테이블의 모든 요소를 제거
    }
    ```
    - 이 함수는 supplemental page table의 리소스를 해제하는 함수로, 프로세스가 종료될 때와 실행될 때 process_cleanup() 함수에서 호출된다.
    - 페이지 항목들을 순회하면서 테이블 내의 페이지들의 타입에 맞는 destroy() 매크로를 호출하여 페이지 타입에 따른 destroy() 함수를 호출한다.
    - hash_clear() 함수를 이용하여 해시 테이블은 두고 테이블 안의 요소들만 지워준다.
    - 이때, hash_clear() 함수에서 해시 페이지를 가져와 페이지 타입에 따른 destroy() 함수를 호출하여 해당 페이지의 리소스를 해제하는 hash_page_destroy() 함수를 다음과 같이 구현해야 한다.
        ```C
        /* 해시 페이지를 가져와 페이지 타입에 따른 destroy() 함수를 호출하여 해당 페이지의 리소스를 해제하는 함수 */
        void hash_page_destroy (struct hash_elem *e, void *aux) {
            struct page *page = hash_entry (e, struct page, hash_elem); // hash element에 해당하는 페이지를 가져옴
            destroy (page); // 페이지 타입에 따른 destroy() 함수를 호출
            free (page); // 페이지 리소스 해제
        }
        ```

### syscall.c의 check_address() 함수 수정
- anonymous page 구현을 완료하고, 테스트를 진행했을 때 계속 실패하는 문제가 발생했다.
- 팀원에게 물어보니 프로젝트 2에서 구현한 syscall.c의 check_address() 함수를 수정해줘야 한다고 헀다.
- check_address() 함수는 주소 값이 유저 영역에서 사용하는 주소 값인지 확인 하는 함수이다.
- 즉, 포인터가 가리키는 주소가 사용자 영역(0x8048000~0xc0000000)인지 확인하며, 유저 영역을 벗어난 영역인 경우 프로세스 종료를 종료시킨다.
- 현재는 현재 접근하는 메모리 주소가 NULL이거나, 커널 영역에서 사용하는 주소이거나, 유저 영역에서 사용하는 주소이지만 페이지로 할당되지 않은 주소일 경우 프로세스를 종료하도록 구현되어 있다.
- page fault가 발생 했을 경우(즉, 페이지가 요청된 경우)는 페이지 안에 내용이 비어있을 경우인데, 현재 구현 상태대로라면 프로세스가 종료될 것이다.
- 따라서, 다음과 같이 주소가 NULL이거나 커널 영역에 있는 경우에만 프로세스를 종료하도록 수정해야 한다.
    ```C
    /* 주소 값이 유저 영역에서 사용하는 주소 값인지 확인 하는 함수 */
    /* 주소유효성 겸사 : 포인터가 가리키는 주소가 사용자 영역(0x8048000~0xc0000000)인지 확인 */
    /* 유저 영역을 벗어난 영역인 경우 프로세스 종료(exit(-1)) */
    void
    check_address (void *addr) {
        // 현재 접근하는 메모리 주소가 NULL이거나, 커널 영역에서 사용하는 주소이거나, 유저 영역에서 사용하는 주소이지만 페이지로 할당되지 않은 주소일 경우(=잘못된 접근)
        // if (addr == NULL || is_kernel_vaddr(addr) || pml4_get_page (thread_current ()->pml4, addr) == NULL) {
        // 	exit (-1); // 프로세스 종료
        // }
        if (addr == NULL || is_kernel_vaddr(addr)) {
            exit (-1); // 프로세스 종료
        }
    }
    ```

## 6. Stack Grouth 구현

### 목표 🎯
- 지금까지의 핀토스는 스택이 USER_STACK을 시작으로 한 페이지로 제한되고, 프로그램 실행도 이 크기로 제한되어 있었다. 이러한 스택을 Stack Growth 구현을 통해 스택이 현재 크기를 초과하면 추가 페이지를 할당할 수 있도록 하는 것이 이번 과제의 목표이다.

### 시스템 콜 인터페이스 메인 함수인 syscall_handler() 함수 수정
```C
/* userprog/syscall.c */
/* 시스템 콜 인터페이스 메인 함수 */
void syscall_handler (struct intr_frame *f UNUSED) {
	int system_call_number = f->R.rax; // 호출한 시스템 콜 번호를 저장하는 변수 선언
#ifdef VM
	thread_current ()->rsp = f->rsp; // 커널 모드로 전환 시, syscall_handler() 함수에서 유저 스택 포인터 저장
#endif

. . .

}
```
- 유저 프로그램에서 page fault가 발생하면, page_fault() 함수에 전달된 인터럽트 프레임의 rsp에서 유저 스택 포인터를 가져온다.
- 커널 모드에서 page fault가 발생한 경우, syscall_handler() 함수에 전달된 인터럽트 프레임의 rsp에서 유저 스택 포인터를 가져와야 한다.
- 하지만, vm_try_handle_fault로 전달되는 f에서 rsp에 접근했을 때 유저 스택 포인터가이 아닌 커널 스택 포인터를 가져온다.
- 따라서, 커널 모드로 전환 시, syscall_handler() 함수에서 유저 스택 포인터를 저장해야 한다.

### page fault가 발생하면 제어권을 전달 받는 vm_try_handle_fault() 함수 수정
```C
/* vm/vm.c */
/* page fault가 발생하면 제어권을 전달 받는 함수 */
bool vm_try_handle_fault (struct intr_frame *f UNUSED, void *addr UNUSED, bool user UNUSED, bool write UNUSED, bool not_present UNUSED) {
	. . .

	// 접근한 메모리의 물리 페이지가 존재하지 않는 경우
	if (not_present) {
		// 페이지 폴트가 스택 확장에 대한 유효한 경우인지 확인
		void *rsp = f->rsp; // user access인 경우 유저 스택을 가져옴
		// kernel access인 경우 스레드에서 유저 스택을 가져옴
		if (!user) 
			rsp = thread_current ()->rsp;

		// 스택 확장으로 처리할 수 있는 페이지 폴트인 경우, vm_stack_growth()함수 호출
		if (USER_STACK - (1 << 20) <= rsp - 8 && rsp - 8 == addr && addr <= USER_STACK)
			vm_stack_growth (addr);
		else if (USER_STACK - (1 << 20) <= rsp && rsp <= addr && addr <= USER_STACK)
			vm_stack_growth (addr);

		. . .
    }
    
    . . .

}
```
- page fault가 발생하면, 이 page fault가 stack growth에 관련된 것인지 먼저 확인하는 과정을 추가한다.
- 맞다면 vm_stack_growth() 함수를 호출하여 스택에 추가 페이지를 할당해 크기를 늘려줘야 한다.
- 접근한 주소가 유저 모드인 경우 유저 스택을, 커널 모드인 경우 스레드에서 유저 스택을 가져온다.
- 가져온 유저 스택을 가지고 stack growth로 처리할 수 있는 page fault인 경우, vm_stack_growth() 함수를 호출하여 page fault를 처리한다.

### 스택 크기를 증가시키는 vm_stack_growth() 함수 구현
```C
/* vm/vm.c */
/* Stack growth 함수 */
static void vm_stack_growth (void *addr UNUSED) {
	vm_alloc_page(VM_ANON | VM_MARKER_0, pg_round_down(addr), 1);
}
```
- vm_try_handle_fault() 함수에서 stack growth를 식별한 후, vm_stack_growth() 함수를 호출하여 스택을 추가 할당한다.
- 스택 크기를 증가시키기 위해 익명 페이지를 할당하여 주어진 addr가 더 이상 faulted address가 되지 않도록 한다.
- 따라서, 할당할 때 addr을 PGSIZE로 내림하여 처리한다.

## 7. Memory Mapped Files 구현

### 목표 🎯
- 익명 페이지와 달리 메모리에 매핑된 페이지를 구현하는 것이 목표이다.

### 매핑하는 이유
- 파일과 메모리를 매핑하면, 파일을 메모리처럼 접근할 수 있어 파일 입출력의 효율성을 향상시킬 수 있다.
- 파일과 매핑된 메모리 영역은 가상 주소 공간에서 접근 가능하며, 해당 영역에 대한 읽기와 쓰기 작업이 가능해진다.
- 쓰기 작업으로 인해 파일의 내용이 변경된 경우, 언매핑되거나 스왑될 때 디스크의 실제 파일에 변경된 내용을 반영한다.

### 인자로 받은 내용을 검사하고 적합한 접근이면 do_mmap() 함수를 호출하는 mmap() 시스템 콜 함수 구현
1. syscall_handler() 함수에 mmap() 시스템 콜 함수 추가
```C
/* userprog/syscall.c */
/* 시스템 콜 인터페이스 메인 함수 */
void syscall_handler (struct intr_frame *f UNUSED) {
    . . .

	switch(system_call_number) {
		. . .
		case SYS_MMAP:
			f->R.rax = mmap(f->R.rdi, f->R.rsi, f->R.rdx, f->R.r10, f->R.r8);
			break;
        . . .

	}
}
```
2. mmap() 시스템 콜 함수 구현
    ```C
    /* userprog/syscall.c */
    /* 인자로 받은 내용을 검사하고 적합한 접근이면 do_mmap() 함수를 호출하는 함수 */
    void *mmap (void *addr, size_t length, int writable, int fd, off_t offset) {
        if (!addr || addr != pg_round_down(addr))
            return NULL;

        if (offset != pg_round_down(offset))
            return NULL;

        if (!is_user_vaddr(addr) || !is_user_vaddr(addr + length))
            return NULL;

        if (spt_find_page(&thread_current()->spt, addr))
            return NULL;

        struct file *f = find_file_by_fd(fd);
        if (f == NULL)
            return NULL;

        if (file_length(f) == 0 || (int)length <= 0)
            return NULL;

        return do_mmap(addr, length, writable, f, offset);
    }
    ```
    - 파일과 메모리 매핑은 mmap() 시스템 콜 함수를 통해 호출되는 do_mmap() 함수를 이용하여 매핑을 수행하는데, mmap() 함수로 전달 받은 인자들을 검증하는 과정이 먼저 이루어져야 한다.
    - 매핑이 이루어질 수 없는 경우는 다음과 같다.
        - addr가 없는 경우
        - addr가 page-aligned 되지 않은 경우
        - offset이 page-aligned 되지 않은 경우
        - addr가 user 영역이 아닌 경우
        - addr + length가 user 영역이 아닌 경우
            - addr부터 파일의 내용을 매핑해나가면 마지막 주소는 addr+length가 되는데, 이 주소도 user 영역 안에 존재해야 한다.
        - addr에 할당된 페이지가 이미 존재하는 경우
        - fd에 해당하는 file이 없는 경우
        - file의 길이가 0 또는 0보다 작은 경우
    - 위 경우를 제외하고는 do_mmap() 함수를 호출하여 파일과 메모리 매핑을 수행해주면 된다.

### 파일과 메모리를 매핑하는 do_mmap() 함수 구현
```C
/* vm/file.c */
void *do_mmap (void *addr, size_t length, int writable, struct file *file, off_t offset) {
	struct file *f = file_reopen(file); // 파일에 대한 새로운 파일 디스크립터를 얻어 다른 매핑에 영향을 주거나 영향을 받지 않는 독립적은 매핑 가지도록 하기 위해 file_reopen() 함수 사용
    void *start_addr = addr; // 매핑 성공 시 파일이 매핑된 가상 주소 반환하는 데 사용
    
    // 이 매핑을 위해 사용한 총 페이지 수 계산
    int total_page_count = length <= PGSIZE ? 1 : length % PGSIZE ? length / PGSIZE + 1 : length / PGSIZE;

    // 주어진 파일 길이와 length를 비교해서 length보다 file 크기가 작으면 파일 통으로 싣고 파일 길이가 더 크면 주어진 length만큼만 load
    size_t read_bytes = file_length(f) < length ? file_length(f) : length;
    size_t zero_bytes = PGSIZE - read_bytes % PGSIZE;

    ASSERT((read_bytes + zero_bytes) % PGSIZE == 0); // read_bytes + zero_bytes한 값이 PGSIZE로 나누어 떨어지는지 확인
    ASSERT(pg_ofs(addr) == 0); // upage가 페이지 정렬되어 있는지 확인
    ASSERT(offset % PGSIZE == 0); // ofs가 페이지 정렬되어 있는지 확인

    // 파일을 페이지 단위로 잘라 해당 파일의 정보들을 lazy_load_arg 구조체에 저장
    while (read_bytes > 0 || zero_bytes > 0)
    {
        size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
        size_t page_zero_bytes = PGSIZE - page_read_bytes;

        struct lazy_load_arg *lazy_load_arg = (struct lazy_load_arg *)malloc(sizeof(struct lazy_load_arg));
        lazy_load_arg->file = f;
        lazy_load_arg->ofs = offset;
        lazy_load_arg->read_bytes = page_read_bytes;
        lazy_load_arg->zero_bytes = page_zero_bytes;

        // vm_alloc_page_with_initializer() 함수를 호출하여 대기 중인 객체를 생성
        if (!vm_alloc_page_with_initializer(VM_FILE, addr, writable, lazy_load_segment, lazy_load_arg))
            return NULL;

        struct page *p = spt_find_page(&thread_current()->spt, start_addr);
        p->mapped_page_count = total_page_count;

        /* Advance. */
        // 읽은 바이트와 0으로 채운 바이트를 추적하고 가상 주소 증가
        read_bytes -= page_read_bytes;
        zero_bytes -= page_zero_bytes;
        addr += PGSIZE;
        offset += page_read_bytes;
    }

    // 시작 주소 반환
    return start_addr;
}
```

### file-backed page를 초기화하는 file_backed_initializer() 함수 구현
```C
/* vm/file.c */
/* file-backed page를 초기화하는 함수 */
bool file_backed_initializer (struct page *page, enum vm_type type, void *kva) {
	/* Set up the handler */
	page->operations = &file_ops;

	struct file_page *file_page = &page->file;
    struct lazy_load_arg *lazy_load_arg = (struct lazy_load_arg *)page->uninit.aux;
    file_page->file = lazy_load_arg->file;
    file_page->ofs = lazy_load_arg->ofs;
    file_page->read_bytes = lazy_load_arg->read_bytes;
    file_page->zero_bytes = lazy_load_arg->zero_bytes;
}
```
- 파일로 백업된 페이지를 초기화한다.
- 이 함수는 먼저 페이지의 file-backed 페이지에 대한 핸들러를 설정한다.
- 수정사항을 파일에 다시 기록하기 위해서는 매핑을 해제하는 시점에 해당 페이지에 매핑된 파일의 정보를 알 수 있어야 한다.
- 따라서, file-backed page가 초기화될 때 호출되는 file_backed_initializer() 함수에서 파일에 대한 정보를 page 구조체에 추가한다.

### file-backed page를 삭제하는 file_backed_destroy() 함수 구현
```C
/* vm/file.c */
/* file-backed page를 삭제하는 함수 */
static void file_backed_destroy (struct page *page) {
	struct file_page *file_page UNUSED = &page->file;
	if (pml4_is_dirty(thread_current()->pml4, page->va))
    {
        file_write_at(file_page->file, page->va, file_page->read_bytes, file_page->ofs);
        pml4_set_dirty(thread_current()->pml4, page->va, 0);
    }
    pml4_clear_page(thread_current()->pml4, page->va);
}
```
- 프로세스가 종료될 때 매핑이 해제되어야 하기 때문에 수정사항을 파일에 반영하고 가상 페이지 목록에서 페이지를 제거한다.
- 이 함수에서는 페이지 구조체를 해제할 필요는 없다.
- file_backed_destroy의 호출자가 처리하도록 한다.

### 매핑을 해제하는 do_munmap() 함수를 호출하는 munmap() 함수 구현
1. syscall_handler() 함수에 munmap() 시스템 콜 함수 추가
```C
/* userprog/syscall.c */
/* 시스템 콜 인터페이스 메인 함수 */
void syscall_handler (struct intr_frame *f UNUSED) {
    . . .

	switch(system_call_number) {
		. . .
		case SYS_MUNMAP:
			munmap(f->R.rdi);
			break;
        . . .

	}
}
```
2. munmap() 시스템 콜 함수 구현
    ```C
    /* userprog/syscall.c */
    /* 매핑을 해제하는 do_munmap() 함수를 호출하는 함수 */
    void munmap (void *addr) {
        do_munmap(addr);
    }
    ```
    - 매핑을 해제하는 do_munmap() 함수를 호출한다.<br><br>
3. 매핑을 해제하는 do_munmap() 함수 구현
    ```C
    /* vm/file.c */
    /* 매핑을 해제하는 함수 */
    void do_munmap (void *addr) {
        struct supplemental_page_table *spt = &thread_current ()->spt;
        struct page *p = spt_find_page (spt, addr);
        int count = p->mapped_page_count; // 같은 파일이 매핑된 페이지가 모두 해제될 수 있도록, 매핑할 때 저장해 둔 매핑된 페이지 수를 이용
        for (int i = 0; i < count; i++) {
            if (p)
                destroy (p); // destroy 매크로에 연결되어 있는 file_backed_destroy() 함수에서 파일의 수정사항을 반영하고 가상 페이지 목록에서 페이지를 제거
                
            addr += PGSIZE;
            p = spt_find_page (spt, addr);
        }
    }
    ```
    - 이 함수는 이전에 동일한 프로세스에서 mmap 호출로 반환된 가상 주소 범위인 addr의 매핑을 해제한다.
    - 이 매핑은 아직 해제되지 않았어야 합니다.
    - 모든 매핑은 프로세스가 exit을 통해 종료되거나 다른 방법으로 종료될 때 암묵적으로 언매핑되기 때문이다.
    - 매핑이 언매핑되면, 암묵적이든 명시적이든 프로세스에 의해 쓰여진 모든 페이지는 파일로 기록되어야 하며, 쓰여지지 않은 페이지는 기록되지 않아야 한다.
    - 같은 파일이 매핑된 페이지가 모두 해제될 수 있도록, 매핑할 때 저장해 둔 매핑된 페이지 수를 이용한다.
    - destroy 매크로에 연결되어 있는 file_backed_destroy() 함수에서 파일의 수정사항을 반영하고 가상 페이지 목록에서 페이지를 제거한다.

## 8. Swap In/Out 구현

### 목표 🎯
- 현재 사용되지 않는 메모리 프레임을 디스크로 스왑아웃 하여, 메인 메모리에 프레임이 할당되면 더 이상 사용자 프로그램의 메모리 할당 요청을 처리할 수 없는 문제를 해결할 수 있도록 스와핑을 구현하는 것이 목표이다.

### Anonymous Page Swap In/Out 구현
1. 스왑 디스크에서 사용 가능한 영역과 사용된 영역을 관리하기 위한 자료구조인 swap table 구현
    ```C
    /* vm/anon.c */
    struct bitmap *swap_table; // 스왑 디스크에서 사용 가능한 영역과 사용된 영역을 관리하기 위한 자료구조인 swap table
    const size_t SECTORS_PER_PAGE = PGSIZE / DISK_SECTOR_SIZE; // 스왑 영역을 페이지 사이즈 단위로 관리하기 위한 값(페이지당 섹터 수)
    ```
    - 스왑 디스크에서 사용 가능한 영역과 사용된 영역을 관리하기 위한 자료구조로 비트맵을 사용한다.
    - 비트가 0이면 해당 페이지를 사용 가능한 영역으로 선정한 것이고, 1이면 해당 페이지가 스왑 아웃되었다는 의미이다.
    - SECTORS_PER_PAGE는 스왑 영역을 페이지 사이즈 단위로 관리하기 위한 값으로 페이지당 섹터 수이다.
    - PGSIZE는 4KB(4096바이트)이며, DISK_SECTOR_SIZE는 512바이트이므로 8개의 디스크 섹터가 페이지마다 있는 것이다.
    - 섹터란 하드 디스크의 가장 작은 전송 단위이며, 일반적으로 512바이트 정도의 크기를 가지고 있지만, 하드 디스크에 따라 차이가 있다.<br><br>
2. 익명 페이지 위해 디스크 내 스왑 공간을 생성해주는 vm_anon_init() 함수 구현
    ```C
    /* vm/anon.c */
    /* 익명 페이지 위해 디스크 내 스왑 공간을 생성해주는 함수 */
    void vm_anon_init (void) {
        /* TODO: Set up the swap_disk. */
        swap_disk = disk_get(1, 1); // 스왑 디스크 반환
        size_t swap_size = disk_size(swap_disk) / SECTORS_PER_PAGE; // 한 페이지 당 몇 개의 섹터가 들어가는지를 나눈 값 저장(스왑 디스크 공간 내의 총 스왑 슬롯 개수)
        swap_table = bitmap_create(swap_size); // swap_size 크기 만큼 swap_table을 비트맵으로 생성
    }
    ```
    - 인자에 맞는 디스크를 반환해주는 disk_get() 함수를 이용하여 스왑 디스크 저장한다.
    - 해당 함수로 들어가는 인자인 disk numbered DEV_NO와 channel numbered CHAN_NO를 통해 해당하는 디스크를 반환해준다.
    - 인자가 (0, 0)이면 부팅 로더/명령어 인수/운영 체제 커널 들어있는 디스크, (0, 1)이면 파일 시스템이 들어있는 디스크, (1, 0)이면 스크래치가 들어있는 디스크, (1, 1)이면 스왑이 들어있는 디스크가 반환된다.
    - disk_size() 함수를 이용하여 한 페이지 당 몇 개의 섹터가 들어가는지를 나눈 값 즉, 스왑 디스크 공간 내의 총 스왑 슬롯 개수를 저장한다.
    - bitmap_create() 함수를 이용하여 swap_size 크기 만큼 스왑 테이블을 비트맵으로 생성한다.<br><br>
3. 익명 페이지를 스왑 디스크에 스왑 아웃하는 anon_swap_out() 함수 구현
    ```C
    /* vm/anon.c */
    /* 익명 페이지를 스왑 디스크에 스왑 아웃하는 함수 */
    static bool anon_swap_out (struct page *page) {
        struct anon_page *anon_page = &page->anon;
        int page_no = bitmap_scan (swap_table, 0, 1, false); // 비트맵을 처음부터 확인하면서 false 값을 가진 비트를 탐색(스왑 아웃된 페이지를 할당할 수 있는 스왑 슬롯을 팀색)

        // false 값을 가진 비트가 없으면 비트맵 에러이므로 false 반환
        if (page_no == BITMAP_ERROR)
            return false;

        // 한 페이지를 디스크에 써 주기 위해 SECTORS_PER_PAGE개의 섹터에 저장
        // 이 때 디스크에 각 섹터의 크기 DISK_SECTOR_SIZE만큼 써줌
        for (int i = 0; i < SECTORS_PER_PAGE; ++i) {
            disk_write (swap_disk, page_no * SECTORS_PER_PAGE + i, page->va + DISK_SECTOR_SIZE * i);
        }

        // 스왑 테이블의 해당 페이지에 대한 스왑 슬롯의 비트와 PTE에서 present bit를 각각 true와 0으로 변경(프로세스가 이 페이지에 접근하면 Page Fault 발생)
        bitmap_set (swap_table, page_no, true);
        pml4_clear_page (thread_current ()->pml4, page->va);

        anon_page->swap_index = page_no; // 페이지의 swap_index 값을 이 페이지가 저장된 스왑 슬롯의 번호로 설정

        return true;
    }
    ```
    - 비트맵을 순회하면서 false 값을 갖는 비트를 찾는데, false 값을 갖는 비트가 없으면 비트맵 에러로 false를 반환한다.
    - 이 비트는 스왑 슬롯에 스왑 아웃된 페이지를 할당할 수 있는 것이다.
    - 그 후 해당 스왑 슬롯에 해당하는 디스크의 영역에 가상 주소 공간의 데이터를 페이지의 시작 주소부터 디스크 섹터 크기로 잘라서 저장한다.
    - 저장을 완료하면, 해당 스왑 슬롯에 대응되는 스왑 테이블의 비트를 true로 바꿔주고, 익명 페이지의 swap_index에 스왑 슬롯 번호를 저장해서 이 페이지가 디스크의 스왑 영역 중 어디에 스왑 되었는지를 확인할 수 있도록 한다.<br><br>
4. 익명 페이지를 스왑 디스크에 스왑 인하는 anon_swap_in() 함수 구현
    ```C
    /* vm/anon.c */
    /* 익명 페이지를 스왑 디스크에서 스왑 인하는 함수 */
    static bool anon_swap_in (struct page *page, void *kva) {
        struct anon_page *anon_page = &page->anon; // 해당 페이지를 anon_page로 변경
        int page_no = anon_page->swap_index; // 스왑 아웃된 페이지가 디스크 스왑 영역 어디에 저장되었는지는 anon_page 구조체 안에 저장되어 있는 swap_index를 가져옴

        // 스왑 테이블에서 해당 스왑 슬롯이 사용 중인지 확인
        if (bitmap_test (swap_table, page_no) == false) {
            return false;
        }

        // 해당 스왑 영역의 데이터를 가상 주소 공간 kva에 써줌
        for (int i = 0; i < SECTORS_PER_PAGE; ++i) {
            disk_read (swap_disk, page_no * SECTORS_PER_PAGE + i, kva + DISK_SECTOR_SIZE * i);
        }

        bitmap_set (swap_table, page_no, false); // 다시 해당 스왑 슬롯을 false로 설정

        return true;
    }
    ```
    - 스왑 아웃된 페이지에 저장된 swap_index 값으로 스왑 슬롯을 찾아 해당 슬롯에 저장된 데이터를 다시 페이지로 원복시킨다.

### File-backed Page Swap In/Out 구현
1. file-backed page를 초기화하는 file_backed_initializer() 함수 구현
    ```C
    /* vm/file.c */
    /* file-backed page를 초기화하는 함수 */
    bool file_backed_initializer (struct page *page, enum vm_type type, void *kva) {
        /* Set up the handler */
        page->operations = &file_ops;

        struct file_page *file_page = &page->file;
        struct lazy_load_arg *lazy_load_arg = (struct lazy_load_arg *)page->uninit.aux;
        file_page->file = lazy_load_arg->file;
        file_page->ofs = lazy_load_arg->ofs;
        file_page->read_bytes = lazy_load_arg->read_bytes;
        file_page->zero_bytes = lazy_load_arg->zero_bytes;
        return true;
    }
    ```
2. file-backed page를 Swap-In하는 file_backed_swap_in() 함수 구현
    ```C
    /* vm/file.c */
    /* file-backed page를 Swap-In하는 함수 */
    static bool file_backed_swap_in (struct page *page, void *kva) {
        struct file_page *file_page UNUSED = &page->file;
        return lazy_load_segment(page, file_page);
    }
    ```
3. file-backed page를 Swap-Out하는 file_backed_swap_out() 함수 구현
    ```C
    /* vm/file.c */
    /* file-backed page를 Swap-Out하는 함수 */
    static bool file_backed_swap_out (struct page *page) {
        struct file_page *file_page UNUSED = &page->file;
        if (pml4_is_dirty(thread_current()->pml4, page->va))
        {
            file_write_at(file_page->file, page->va, file_page->read_bytes, file_page->ofs);
            pml4_set_dirty(thread_current()->pml4, page->va, 0);
        }

        // 페이지와 프레임의 연결 끊기
        page->frame->page = NULL;
        page->frame = NULL;
        pml4_clear_page(thread_current()->pml4, page->va);
        return true;
    }
    ```
4. file-backed page를 삭제하는 file_backed_destroy() 함수 구현
    ```C
    /* vm/file.c */
    /* file-backed page를 삭제하는 함수 */
    static void file_backed_destroy (struct page *page) {
        struct file_page *file_page UNUSED = &page->file;
        if (pml4_is_dirty(thread_current()->pml4, page->va))
        {
            file_write_at(file_page->file, page->va, file_page->read_bytes, file_page->ofs);
            pml4_set_dirty(thread_current()->pml4, page->va, 0);
        }
        pml4_clear_page(thread_current()->pml4, page->va);
    }
    ```

## 9. 트러블 슈팅
### tests/vm/swap-fork 실패 트러블 슈팅
- 테스트 실행 시, swap-fork가 터지면서 아래 오류가 발생한다.
    - Kernel panic in run: PANIC at ../../threads/thread.c:330 in thread_yield(): assertion `!intr_context ()' failed.
- thread_yield() 함수에서의 ASSERT (!intr_context ()) 부분에서 문제가 발생하는 것 같다.
- intr_context() 함수는 외부 인터럽트를 처리 중일 때는 true를 반환하고, 아니면 false를 반환하는 함수다.
- 즉, 외부 인터럽트가 들어오면 테스트에서 FAIL이 발생하는 것이다.
- 따라서, 외부 인터럽트가 아닐 때만 thread_yield() 함수를 실행하도록 아래와 같이 코드를 수정했다.<br><br>
- 수정 전, 코드
```C
/* ready_list에서 우선순위가 가장 높은 스레드와 현재 스레드의 우선순위를 비교하는 함수 */
void test_max_priority (void) {
	// Ready_list가 비어있지 않고, ready_list에서 우선순위가 가장 높은 스레드보다 현재 스레드의 우선순위가 더 작은 경우
	if(!list_empty (&ready_list) && ((thread_current ()->priority) < (list_entry(list_front (&ready_list), struct thread, elem)->priority))) {
		thread_yield (); // thread_yield() 함수를 호출하여 현재 스레드의 CPU를 양보
	}
}
```
- 수정 후, 코드
```C
/* ready_list에서 우선순위가 가장 높은 스레드와 현재 스레드의 우선순위를 비교하는 함수 */
void test_max_priority (void) {
	// Ready_list가 비어있지 않고, ready_list에서 우선순위가 가장 높은 스레드보다 현재 스레드의 우선순위가 더 작은 경우
	if(!list_empty (&ready_list) && ((thread_current ()->priority) < (list_entry(list_front (&ready_list), struct thread, elem)->priority))) {
		if (!intr_context()) {
			thread_yield (); // thread_yield() 함수를 호출하여 현재 스레드의 CPU를 양보
		}
	}
}
```

## 10. PROJECT3(VIRTUAL MEMORY) 구현 결과
```
pass tests/userprog/args-none
pass tests/userprog/args-single
pass tests/userprog/args-multiple
pass tests/userprog/args-many
pass tests/userprog/args-dbl-space
pass tests/userprog/halt
pass tests/userprog/exit
pass tests/userprog/create-normal
pass tests/userprog/create-empty
pass tests/userprog/create-null
pass tests/userprog/create-bad-ptr
pass tests/userprog/create-long
pass tests/userprog/create-exists
pass tests/userprog/create-bound
pass tests/userprog/open-normal
pass tests/userprog/open-missing
pass tests/userprog/open-boundary
pass tests/userprog/open-empty
pass tests/userprog/open-null
pass tests/userprog/open-bad-ptr
pass tests/userprog/open-twice
pass tests/userprog/close-normal
pass tests/userprog/close-twice
pass tests/userprog/close-bad-fd
pass tests/userprog/read-normal
pass tests/userprog/read-bad-ptr
pass tests/userprog/read-boundary
pass tests/userprog/read-zero
pass tests/userprog/read-stdout
pass tests/userprog/read-bad-fd
pass tests/userprog/write-normal
pass tests/userprog/write-bad-ptr
pass tests/userprog/write-boundary
pass tests/userprog/write-zero
pass tests/userprog/write-stdin
pass tests/userprog/write-bad-fd
pass tests/userprog/fork-once
pass tests/userprog/fork-multiple
pass tests/userprog/fork-recursive
pass tests/userprog/fork-read
pass tests/userprog/fork-close
pass tests/userprog/fork-boundary
pass tests/userprog/exec-once
pass tests/userprog/exec-arg
pass tests/userprog/exec-boundary
pass tests/userprog/exec-missing
pass tests/userprog/exec-bad-ptr
pass tests/userprog/exec-read
pass tests/userprog/wait-simple
pass tests/userprog/wait-twice
pass tests/userprog/wait-killed
pass tests/userprog/wait-bad-pid
pass tests/userprog/multi-recurse
pass tests/userprog/multi-child-fd
pass tests/userprog/rox-simple
pass tests/userprog/rox-child
pass tests/userprog/rox-multichild
pass tests/userprog/bad-read
pass tests/userprog/bad-write
pass tests/userprog/bad-read2
pass tests/userprog/bad-write2
pass tests/userprog/bad-jump
pass tests/userprog/bad-jump2
pass tests/vm/pt-grow-stack
pass tests/vm/pt-grow-bad
pass tests/vm/pt-big-stk-obj
pass tests/vm/pt-bad-addr
pass tests/vm/pt-bad-read
pass tests/vm/pt-write-code
pass tests/vm/pt-write-code2
pass tests/vm/pt-grow-stk-sc
pass tests/vm/page-linear
pass tests/vm/page-parallel
pass tests/vm/page-merge-seq
FAIL tests/vm/page-merge-par
FAIL tests/vm/page-merge-stk
FAIL tests/vm/page-merge-mm
pass tests/vm/page-shuffle
pass tests/vm/mmap-read
pass tests/vm/mmap-close
pass tests/vm/mmap-unmap
pass tests/vm/mmap-overlap
pass tests/vm/mmap-twice
pass tests/vm/mmap-write
pass tests/vm/mmap-ro
pass tests/vm/mmap-exit
pass tests/vm/mmap-shuffle
pass tests/vm/mmap-bad-fd
pass tests/vm/mmap-clean
pass tests/vm/mmap-inherit
pass tests/vm/mmap-misalign
pass tests/vm/mmap-null
pass tests/vm/mmap-over-code
pass tests/vm/mmap-over-data
pass tests/vm/mmap-over-stk
pass tests/vm/mmap-remove
pass tests/vm/mmap-zero
pass tests/vm/mmap-bad-fd2
pass tests/vm/mmap-bad-fd3
pass tests/vm/mmap-zero-len
pass tests/vm/mmap-off
pass tests/vm/mmap-bad-off
pass tests/vm/mmap-kernel
pass tests/vm/lazy-file
pass tests/vm/lazy-anon
pass tests/vm/swap-file
pass tests/vm/swap-anon
pass tests/vm/swap-iter
pass tests/vm/swap-fork
pass tests/filesys/base/lg-create
pass tests/filesys/base/lg-full
pass tests/filesys/base/lg-random
pass tests/filesys/base/lg-seq-block
pass tests/filesys/base/lg-seq-random
pass tests/filesys/base/sm-create
pass tests/filesys/base/sm-full
pass tests/filesys/base/sm-random
pass tests/filesys/base/sm-seq-block
pass tests/filesys/base/sm-seq-random
pass tests/filesys/base/syn-read
pass tests/filesys/base/syn-remove
pass tests/filesys/base/syn-write
pass tests/threads/alarm-single
pass tests/threads/alarm-multiple
pass tests/threads/alarm-simultaneous
pass tests/threads/alarm-priority
pass tests/threads/alarm-zero
pass tests/threads/alarm-negative
pass tests/threads/priority-change
pass tests/threads/priority-donate-one
pass tests/threads/priority-donate-multiple
pass tests/threads/priority-donate-multiple2
pass tests/threads/priority-donate-nest
pass tests/threads/priority-donate-sema
pass tests/threads/priority-donate-lower
pass tests/threads/priority-fifo
pass tests/threads/priority-preempt
pass tests/threads/priority-sema
pass tests/threads/priority-condvar
pass tests/threads/priority-donate-chain
FAIL tests/vm/cow/cow-simple
4 of 141 tests failed.
```
- 아래 4개의 테스트 케이스는 간헐적으로 실패하는 케이스인데, 결국 원인을 알지 못해 해결하지 못해서 많이 아쉽다...
    ```
    FAIL tests/vm/page-merge-par  
    FAIL tests/vm/page-merge-stk  
    FAIL tests/vm/page-merge-mm  
    FAIL tests/filesys/base/syn-read
    ```