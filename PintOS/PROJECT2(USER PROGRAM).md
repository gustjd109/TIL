# PROJECT2 : USER PROGRAMS

## 1. PROJECT2(USER PROGRAMS) GitBook Contents
### Introduction
1. Project2: User Programs
    - 이제 핀토스를 사용해 보고 인프라와 스레드 패키지에 익숙해졌으므로 이제 사용자 프로그램을 실행할 수 있는 시스템 부분에 대한 작업을 시작할 차례입니다. 기본 코드는 이미 사용자 프로그램 로딩과 실행을 지원하지만 I/O 또는 상호 작용은 불가능합니다. 이 프로젝트에서는 시스템 호출을 통해 프로그램이 OS와 상호 작용할 수 있도록 합니다. 이 과제를 위해 userprog 디렉토리에서 작업하게 되지만, 핀토스의 거의 모든 다른 부분과도 상호작용하게 됩니다. 아래에서 관련 부분을 설명하겠습니다.
    - 프로젝트1 제출물 위에 프로젝트2를 빌드해야 합니다. 프로젝트 1의 코드가 프로젝트 2의 코드에 영향을 미치지는 않지만 증분 프로젝트이므로 프로젝트 1에 대한 테스트 케이스를 통과해야 합니다.
    - 또한, 프로젝트2에는 추가 챌린지가 있으며, 이것은 선택적 구현일 뿐입니다. 추가 챌린지의 경우 테스트 케이스 외에는 스켈레톤 코드가 제공되지 않습니다. 모든 디자인은 여러분의 몫입니다. 추가 요구 사항을 제출하고 테스트하려면 userprog/Make.vars를 편집해야 합니다.
    - 마지막으로, TODO가 없는 코드라고 해서 항상 해당 코드를 변경할 필요가 없는 것은 아니라는 점에 유의하세요. 테스트 코드를 제외한 프로젝트2의 모든 소스 코드를 자유롭게 수정할 수 있습니다.<br><br>
2. Background
    - 지금까지 핀토스에서 실행한 모든 코드는 운영 체제 커널의 일부였습니다. 예를 들어, 마지막 과제의 모든 테스트 코드는 커널의 일부로 실행되었으며, 시스템의 권한 있는 부분에 대한 전체 액세스 권한이 있었습니다. 운영 체제 위에서 사용자 프로그램을 실행하기 시작하면 더 이상 그렇지 않습니다. 이 프로젝트는 그 결과를 다룹니다.
    - 한 번에 하나 이상의 프로세스를 실행할 수 있습니다. 각 프로세스에는 하나의 스레드가 있습니다(멀티스레드 프로세스는 지원되지 않음). 사용자 프로그램은 마치 전체 시스템을 소유한 것처럼 착각하여 작성됩니다. 즉, 한 번에 여러 프로세스를 로드하고 실행할 때 이 착각을 유지하기 위해 메모리, 스케줄링 및 기타 상태를 올바르게 관리해야 합니다.
    - 이전 프로젝트에서는 테스트 코드를 커널에 직접 컴파일했기 때문에 커널 내 특정 기능 인터페이스가 필요했습니다. 이제부터는 사용자 프로그램을 실행하여 운영 체제를 테스트합니다. 이렇게 하면 훨씬 더 자유로워집니다. 사용자 프로그램 인터페이스가 여기에 설명된 사양을 충족하는지 확인해야 하지만, 이러한 제약이 있으므로 커널 코드를 원하는 대로 자유롭게 재구성하거나 재작성할 수 있습니다. 모든 코드는 #ifdef VM으로 둘러싸인 블록에 위치하지 않아야 합니다. 이 블록은 프로젝트 3에서 구현할 가상 메모리 서브시스템을 활성화한 후에 포함될 것입니다. 또한 코드가 #ifndef VM으로 둘러싸인 경우 해당 코드는 프로젝트 3에서 생략됩니다.
    - 시작하기 전에 동기화(https://casys-kaist.github.io/pintos-kaist/appendix/synchronization.html) 및 가상 주소(https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html)에 대해 읽어보실 것을 강력히 권장합니다.<br><br>
3. Source Files
    - 작업할 프로그래밍의 개요를 파악하는 가장 쉬운 방법은 작업할 각 부분을 간단히 살펴보는 것입니다. userprog에서는 적은 수의 파일을 찾을 수 있지만, 여기서 대부분의 작업을 수행할 수 있습니다:
        - process.c, process.h
            - ELF 바이너리를 로드하고 프로세스를 시작합니다.
        - **syscall.c, syscall.h**
            - 사용자 프로세스가 일부 커널 기능에 액세스하려고 할 때마다 시스템 호출을 호출합니다. 이것이 스켈레톤 시스템 호출 핸들러입니다. 현재는 메시지를 출력하고 사용자 프로세스를 종료하기만 합니다. **이 프로젝트의 파트 2에서는 시스템 호출에 필요한 다른 모든 작업을 수행하는 코드를 추가할 것입니다.**
        - syscall-entry.S
            - 시스템 호출 핸들러를 부트스트랩하는 작은 어셈블리 코드입니다. 이 코드를 이해할 필요는 없습니다.
        - **exception.c, exception.h**
            - 사용자 프로세스가 권한이 있거나 금지된 작업을 수행하면 예외 또는 오류로 커널에 트래핑됩니다. 이러한 파일은 예외를 처리합니다. 현재 모든 예외는 단순히 메시지를 출력하고 프로세스를 종료합니다. 프로젝트 2의 일부 솔루션(전부는 아님)은 **이 파일에서 page_fault()를 수정해야 합니다.**
        - gdt.c, gdt.h
            - x86-64는 세그먼트 아키텍처입니다. 글로벌 설명자 테이블(GDT, Global Descriptor Table)은 사용 중인 세그먼트를 설명하는 테이블입니다. 이 파일은 GDT를 설정합니다. 어떤 프로젝트에서도 이 파일을 수정할 필요가 없습니다. GDT의 작동 방식이 궁금하다면 코드를 읽어볼 수 있습니다.
        - tss.c, tss.h
            - 작업 상태 세그먼트(TSS, Task-State Segment)는 x86 아키텍처 작업 전환에 사용되었습니다. 그러나, x86-64에서는 태스크 스위칭이 더 이상 사용되지 않습니다. 그럼에도 불구하고 링 스위칭 중에 스택 포인터를 찾기 위해 TSS는 여전히 존재합니다.
            - 즉, 사용자 프로세스가 인터럽트 핸들러에 진입하면 하드웨어가 tss를 참조하여 커널의 스택 포인터를 조회합니다. 어떤 프로젝트에 대해서도 이러한 파일을 수정할 필요가 없습니다. TSS의 작동 방식이 궁금하다면 코드를 읽어볼 수 있습니다.<br><br>
4. Using the File System
    - 사용자 프로그램이 파일 시스템에서 로드되고 구현해야 하는 많은 시스템 호출이 파일 시스템을 다루기 때문에 이 프로젝트에서는 파일 시스템 코드에 인터페이스해야 합니다. 하지만, 이 프로젝트의 초점은 파일 시스템이 아니므로 filesys 디렉터리에 간단하지만 완전한 파일 시스템을 제공했습니다. 파일 시스템 사용 방법, 특히 파일 시스템의 여러 제한 사항을 이해하려면 filesys.h 및 file.h 인터페이스를 살펴보는 것이 좋습니다.
    - 이 프로젝트의 파일 시스템 코드를 수정할 필요는 없으므로 수정하지 않는 것이 좋습니다. 파일 시스템 작업은 이 프로젝트에 집중하는 데 방해가 될 수 있습니다.
    - 지금 파일 시스템 루틴을 적절히 사용하면 파일 시스템 구현을 개선할 때 프로젝트 4를 훨씬 쉽게 수행할 수 있습니다. 그때까지는 다음과 같은 제한 사항을 감수해야 합니다:
        - 내부 동기화가 없습니다. 동시 액세스는 서로 간섭을 일으킵니다. 동기화를 사용하여 한 번에 하나의 프로세스만 파일 시스템 코드를 실행하도록 해야 합니다.
        - 파일 크기는 생성 시 고정됩니다. 루트 디렉터리는 파일로 표시되므로 생성할 수 있는 파일 수 또한 제한됩니다.
        - 파일 데이터는 단일 범위로 할당되므로, 단일 파일의 데이터는 디스크의 연속된 섹터 범위를 차지해야 합니다. 따라서, 파일 시스템은 시간이 지남에 따라 사용되므로 외부 조각화(External fragmentation)는 심각한 문제가 될 수 있습니다.
        - 하위 디렉터리 없음
        - 파일 이름은 14자로 제한됩니다.
        - 작업 중 시스템 충돌이 발생하면 자동으로 복구할 수 없는 방식으로 디스크가 손상될 수 있습니다. 어쨌든 파일 시스템 복구 도구는 없습니다.
    - 한 가지 중요한 기능이 포함되어 있습니다:
        - filesys_remove()에 대한 유닉스와 유사한 시맨틱이 구현되었습니다. 즉, 파일이 제거될 때 열려 있는 경우 해당 블록은 할당 해제되지 않으며, 마지막 스레드가 파일을 닫을 때까지 열려 있는 모든 스레드에서 계속 액세스할 수 있습니다. 자세한 내용은 Removing an Open File(https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html)를 참조하세요.
    - 모든 테스트 프로그램이 커널 이미지에 이미 존재했던 프로젝트 1과 달리, **테스트 프로그램(사용자 공간에서 실행되는)을 핀토스 가상 머신에 넣어야 합니다.** 테스트 스크립트(예: make check)가 이 작업을 자동으로 처리하므로 대부분의 경우 이를 이해할 필요가 없습니다. 하지만 이를 알면 개별 테스트 케이스를 실행하는 데 큰 도움이 됩니다.
    - **핀토스 가상 머신에 파일을 넣으려면 먼저 파일 시스템 파티션이 있는 시뮬레이션 디스크를 생성할 수 있어야 합니다.** **pintos-mkdisk 프로그램이 이 기능을 제공**합니다. **userprog/build 디렉토리에서 pintos-mkdisk filesys.dsk 2를 실행**합니다. **이 명령은 2MB 핀토스 파일 시스템 파티션이 포함된 filesys.dsk라는 이름의 시뮬레이션 디스크를 생성**합니다. 그런 다음 **--fs-disk filesys.dsk 뒤에 --를 전달하여 디스크를 지정합니다(예: pintos --fs-disk filesys.disk -- KERNEL_COMMANDS...).** **fs-disk는 시뮬레이션된 커널이 아니라 핀토스 스크립트를 위한 것이므로 --가 필요**합니다. 그런 다음 커널의 명령줄에 **-f -q를 전달하여 파일 시스템 파티션을 포맷**합니다: **pintos SCRIPT_COMMANDS -- -f -q**. **f 옵션은 파일 시스템을 포맷하도록 하고, -q는 포맷이 완료되는 즉시 핀토스를 종료**하도록 합니다.
    - **시뮬레이션된 파일 시스템 안팎으로 파일을 복사할 수 있는 방법이 필요**합니다. **pintos -p("put") 및 -g("get") 옵션이 이 작업을 수행**합니다. **'file'을 핀토스 파일 시스템으로 복사하려면 pintos -p file -- -q 명령을 사용**합니다. **New name이라는 이름으로 핀토스 파일 시스템에 복사하려면 원본 파일 이름 뒤에 :new name을 추가**합니다: **pintos -p 파일:new name -- -q**. **VM에서 파일을 복사하는 명령은 비슷하지만 -p 대신 -g로 대체**합니다.
    - 참고로, 이러한 명령은 커널의 명령줄에 특수 명령 extract와 append를 전달하고 시뮬레이션된 특수 "스크래치" 파티션에 복사하는 방식으로 작동합니다. 궁금한 점이 많으시다면 핀토스 스크립트와 filesys/fsutil.c를 참조하여 구현 세부 사항을 알아보세요.
    - 다음은 **파일 시스템 파티션이 있는 디스크를 만들고, 파일 시스템을 포맷하고, 이 프로젝트의 두 번째 테스트 케이스인 단일 프로그램인 args를 새 디스크에 복사한 다음, 인자 'onearg'를 전달하여 실행하는 방법**을 요약한 것입니다. (인자 전달은 구현하기 전까지는 작동하지 않습니다.) 테스트 케이스를 이미 빌드했으며 현재 디렉터리가 userprog/build라고 가정합니다:
        ```C
        pintos-mkdisk filesys.dsk 10
        pintos --fs-disk filesys.dsk -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
    - 나중에 사용하거나 검사하기 위해 파일 시스템 디스크를 보관하고 싶지 않다면 네 단계를 모두 단일 명령으로 결합할 수도 있습니다. --filesys-size=n 옵션은 핀토스 실행 기간 동안만 약 n메가바이트 크기의 임시 파일 시스템 파티션을 생성합니다. 핀토스 자동 테스트 스위트는 이 구문을 광범위하게 사용합니다:
        ```C
        pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
5. How User Programs Work
    - 핀토스는 메모리에 맞고 사용자가 구현한 시스템 호출만 사용하는 한 일반 C 프로그램을 실행할 수 있습니다. 특히 이 프로젝트에 필요한 시스템 호출 중 메모리 할당을 허용하는 시스템 호출이 없기 때문에 malloc()을 구현할 수 없습니다. 또한 핀토스는 스레드를 전환할 때 커널이 프로세서의 부동 소수점 단위를 저장 및 복원하지 않기 때문에 부동 소수점 연산을 사용하는 프로그램을 실행할 수 없습니다.
    - 핀토스는 userprog/process.c에 제공된 로더를 사용하여 ELF 실행 파일을 로드할 수 있습니다. ELF는 Linux, Solaris 및 기타 여러 운영 체제에서 객체 파일, 공유 라이브러리 및 실행 파일에 사용하는 파일 형식입니다.
    - 실제로 x86-64 ELF 실행 파일을 출력하는 모든 컴파일러와 링커를 사용하여 핀토스용 프로그램을 생성할 수 있습니다. (저희가 제공한 컴파일러와 링커는 잘 작동합니다.) 테스트 프로그램을 시뮬레이션된 파일 시스템에 복사하기 전까지는 핀토스가 유용한 작업을 수행할 수 없다는 것을 즉시 깨달아야 합니다. 다양한 프로그램을 파일 시스템에 복사하기 전까지는 흥미로운 작업을 할 수 없습니다. 디버깅 중에 가끔 발생할 수 있는 파일을 유용한 상태가 아닌 파일 시스템 디스크를 휴지통에 버릴 때마다 깨끗한 참조 파일 시스템 디스크를 만들어 복사하는 것이 좋습니다.<br><br>
6. Virtual Memory Layout
    - 핀토스의 가상 메모리는 사용자 가상 메모리와 커널 가상 메모리의 두 영역으로 나뉩니다. 사용자 가상 메모리는 가상 주소 0에서 include/threads/vaddr.h에 정의된 KERN_BASE까지이며 기본값은 0x8004000000입니다. 커널 가상 메모리는 나머지 가상 주소 공간을 차지합니다.
    - 사용자 가상 메모리는 프로세스 단위(per-process)입니다. 커널이 한 프로세스에서 다른 프로세스로 전환할 때, 프로세서의 페이지 디렉터리 베이스 레지스터를 변경하여 사용자 가상 주소 공간도 전환합니다(thread/mmu.c의 pml4_activate() 참조). 구조체 thread는 프로세스의 페이지 테이블에 대한 포인터를 포함합니다.
    - 커널 가상 메모리는 전역적입니다. 실행 중인 사용자 프로세스나 커널 스레드에 관계없이 항상 동일한 방식으로 매핑됩니다. 핀토스에서 커널 가상 메모리는 KERN_BASE부터 시작하여 물리적 메모리에 일대일로 매핑됩니다. 즉, 가상 주소 KERN_BASE는 물리적 주소 0에 액세스하고, 가상 주소 KERN_BASE + 0x1234는 물리적 주소 0x1234에 액세스하는 식으로 머신의 물리적 메모리 크기까지 액세스합니다.
    - 사용자 프로그램은 자신의 사용자 가상 메모리에만 액세스할 수 있습니다. 커널 가상 메모리에 액세스하려고 시도하면 userprog/exception.c의 page_fault()가 처리하는 페이지 오류가 발생하고 프로세스가 종료됩니다. 커널 스레드는 커널 가상 메모리와 사용자 프로세스가 실행 중인 경우 실행 중인 프로세스의 사용자 가상 메모리에 모두 액세스할 수 있습니다. 그러나, 커널에서도 매핑되지 않은 사용자 가상 주소로 메모리에 액세스하려고 시도하면 페이지 오류가 발생합니다.<br><br>
7. Typical Memory Layout
    - 개념적으로 각 프로세스는 자체 사용자 가상 메모리를 원하는 대로 자유롭게 배치할 수 있습니다. 실제로 사용자 가상 메모리는 다음과 같이 배치됩니다:
        ```C
         USER_STACK +----------------------------------+
                    |             user stack           |
                    |                 |                |
                    |                 |                |
                    |                 V                |
                    |           grows downward         |
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                    |           grows upward           |
                    |                 ^                |
                    |                 |                |
                    |                 |                |
                    +----------------------------------+
                    | uninitialized data segment (BSS) |
                    +----------------------------------+
                    |     initialized data segment     |
                    +----------------------------------+
                    |            code segment          |
            0x400000  +----------------------------------+
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                0   +----------------------------------+
        ```
    - 이 프로젝트에서는 사용자 스택의 크기가 고정되어 있지만 프로젝트 3에서는 크기가 커질 수 있습니다. 기존에는 초기화되지 않은 데이터 세그먼트의 크기를 시스템 호출로 조정할 수 있었지만, 이 기능을 구현할 필요는 없습니다.
    - 핀토스의 코드 세그먼트는 사용자 가상 주소 0x400000에서 시작하며, 주소 공간의 맨 아래에서 약 128MB입니다. 이 값은 우분투의 일반적인 값으로 큰 의미는 없습니다.
    - 링커는 다양한 프로그램 세그먼트의 이름과 위치를 알려주는 "링커 스크립트"의 지시에 따라 메모리에서 사용자 프로그램의 레이아웃을 설정합니다.
    - 특정 실행 파일의 레이아웃을 보려면 -p 옵션과 함께 objdump를 실행하세요.<br><br>
8. Accessing User Memory
    - **시스템 호출의 일부로 커널은 종종 사용자 프로그램이 제공하는 포인터를 통해 메모리에 액세스해야 합니다. 사용자가 널 포인터, 매핑되지 않은 가상 메모리에 대한 포인터 또는 커널 가상 주소 공간(KERN_BASE 위)에 대한 포인터를 전달할 수 있으므로 커널은 이를 매우 신중하게 처리해야 합니다. 이러한 모든 유형의 잘못된 포인터는 커널이나 실행 중인 다른 프로세스에 해를 끼치지 않고 거부되어야 하며, 문제가 되는 프로세스를 종료하고 해당 리소스를 해제해야 합니다.**
    - **이 작업을 올바르게 수행하는 데는 최소한 두 가지 합리적인 방법**이 있습니다. 첫 번째 방법은 **사용자가 제공한 포인터의 유효성을 확인한 다음 포인터를 참조 해제하는 것**입니다. 이 방법을 선택하는 경우 thread/mmu.c와 include/threads/vaddr.h의 함수를 살펴볼 수 있습니다. 이 방법은 사용자 메모리 액세스를 처리하는 가장 간단한 방법입니다.
    - 두 번째 방법은 **사용자 포인터가 KERN_BASE 아래를 가리키는지만 확인한 다음 이를 참조 해제하는 것**입니다. **잘못된 사용자 포인터는 "페이지 오류"를 발생시키며, userprog/exception.c에서 page_fault()의 코드를 수정하여 처리할 수 있습니다.** 이 기술은 프로세서의 MMU를 활용하기 때문에 일반적으로 더 빠르므로 실제 커널(Linux 포함)에서 사용되는 경향이 있습니다.
    - **두 경우 모두 리소스가 '누수'되지 않도록 주의**해야 합니다. 예를 들어, 시스템 호출이 malloc()을 통해 lock을 획득하거나 메모리를 할당했다고 가정해 보겠습니다. 나중에 잘못된 사용자 포인터가 발생하더라도 반드시 잠금을 해제하거나 메모리 페이지를 해제해야 합니다. 사용자 포인터를 역참조하기 전에 확인하도록 선택했다면 이 과정은 간단합니다. 잘못된 포인터로 인해 페이지 오류가 발생하는 경우 메모리 액세스에서 오류 코드를 반환할 방법이 없으므로 처리하기가 더 어렵습니다. 따라서, **후자의 기법을 시도해보고 싶은 분들을 위해 약간의 유용한 코드를 제공**하겠습니다:
        ```C
        /* Reads a byte at user virtual address UADDR.
        * UADDR must be below KERN_BASE.
        * Returns the byte value if successful, -1 if a segfault
        * occurred. */
        static int64_t
        get_user (const uint8_t *uaddr) {
            int64_t result;
            __asm __volatile (
            "movabsq $done_get, %0\n"
            "movzbq %1, %0\n"
            "done_get:\n"
            : "=&a" (result) : "m" (*uaddr));
            return result;
        }

        /* Writes BYTE to user address UDST.
        * UDST must be below KERN_BASE.
        * Returns true if successful, false if a segfault occurred. */
        static bool
        put_user (uint8_t *udst, uint8_t byte) {
            int64_t error_code;
            __asm __volatile (
            "movabsq $done_put, %0\n"
            "movb %b2, %1\n"
            "done_put:\n"
            : "=&a" (error_code), "=m" (*udst) : "q" (byte));
            return error_code != -1;
        }
        ```
        - 이러한 각 함수는 사용자 주소가 이미 KERN_BASE 아래에 있는 것으로 확인되었다고 가정합니다. 또한 커널에서 페이지 오류가 발생하면 rax를 -1로 설정하고 이전 값을 %rip에 복사하도록 page_fault()를 수정했다고 가정합니다.

### 인수 전달(Argument Passing)
1. 인수 전달(Argument Passing)
    - process_exec()에서 사용자 프로그램에 대한 인수를 설정합니다.<br><br>
2. x86-64 호출 규칙(x86-64 Calling Convention)
    - 이 섹션에서는 **64비트 x86-64 유닉스 구현에서 일반 함수 호출에 사용되는 규약**의 중요한 사항을 요약합니다. 간결성을 위해 일부 세부 사항은 생략했습니다. 자세한 내용은 System V AMD64 ABI(https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)를 참조하십시오.
    - 호출 규칙은 다음과 같이 작동합니다:
        - **사용자 수준 애플리케이션은 %rdi, %rsi, %rdx, %rcx, %r8 및 %r9 시퀀스를 전달하기 위한 정수 레지스터로 사용**합니다.
        - **호출자는 스택에서 다음 명령어의 주소(반환 주소)를 푸시하고 피호출자의 첫 번째 명령어로 점프**합니다. **단일 x86-64 명령어인 CALL은 이 두 가지를 모두 수행**합니다.
        - **피호출자가 실행**됩니다.
        - **피호출자가 반환값을 가지고 있으면 레지스터 RAX에 저장**합니다.
        - **피호출자는 스택에서 반환 주소를 꺼내고 x86-64 RET 명령어를 사용하여 지정한 위치로 점프하여 반환**합니다.
    - 세 개의 int 인자를 받는 함수 f()를 생각해 봅시다. 이 다이어그램은 f()가 f(1, 2, 3)으로 호출된다고 가정할 때 위 3단계의 시작 부분에서 피호출자가 볼 수 있는 샘플 스택 프레임과 레지스터 상태를 보여줍니다. 초기 스택 주소는 임의입니다:
        ```C
                                     +----------------+
        stack pointer --> 0x4747fe70 | return address |
                                     +----------------+
        RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003
        ```
3. Program Startup Details
    - 사용자 프로그램용 핀토스 C 라이브러리는 lib/user/entry.c에 있는 _start()를 사용자 프로그램의 진입점으로 지정합니다. 이 함수는 main()을 감싸는 래퍼로, main()이 반환되면 exit()를 호출합니다:
        ```C
        void
        _start (int argc, char *argv[]) {
            exit (main (argc, argv));
        }
        ```
    - **커널은 사용자 프로그램이 실행을 시작하기 전에 초기 함수에 대한 인수를 레지스터에 넣어야 합니다.** **인자는 일반적인 호출 규칙과 동일한 방식으로 전달**됩니다.
    - 다음 예제 명령의 **인수를 처리하는 방법**을 살펴봅니다: **/bin/ls -l foo bar**.
        - **명령을 단어로 나눕니다: /bin/ls, -l, foo, bar**.
        - **스택의 맨 위에 단어를 배치**합니다. **포인터를 통해 참조되므로 순서는 중요하지 않습니다.**
        - **각 문자열의 주소와 널 포인터 센티널을 오른쪽에서 왼쪽 순서로 스택에 밀어 넣습니다.** **이것이 argv의 요소**입니다. **널 포인터 센티널은 C 표준에서 요구하는 대로 argv[argc]가 널 포인터인지 확인**합니다. **이 순서는 argv[0]이 가장 낮은 가상 주소에 있도록 보장**합니다. **단어 정렬 액세스는 정렬되지 않은 액세스보다 빠르므로 최상의 성능을 얻으려면 첫 번째 푸시 전에 스택 포인터를 8의 배수로 반올림**하세요.
        - **%rsi를 argv(argv[0]의 주소)로 가리키고 %rdi를 argc로 설정**합니다.
        - 마지막으로 **가짜 "반환 주소"를 푸시**합니다. **입력 함수는 반환되지 않지만 스택 프레임은 다른 함수와 동일한 구조를 가져야 합니다.**
    - 아래 표는 사용자 프로그램이 시작되기 직전의 스택 상태와 관련 레지스터를 보여줍니다. 스택이 아래로 내려가는 것을 확인할 수 있습니다.
        | Address    | Name           | Data        | Type        |
        |------------|----------------|-------------|-------------|
        | 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
        | 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
        | 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
        | 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
        | 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
        | 0x4747ffe0 | argv[4]        | 0           | char *      |
        | 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
        | 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
        | 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
        | 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
        | 0x4747ffb8 | return address | 0           | void (*) () |
        - RDI: 4 | RSI: 0x4747ffc0
        - 이 예제에서 스택 포인터는 0x4747ffb8로 초기화됩니다. 위와 같이 코드가 include/threads/vaddr.h에 정의된 USER_STACK에서 스택을 시작해야 합니다.
        - **<stdio.h>에 선언된 비표준 hex_dump() 함수는 인자 전달 코드를 디버깅하는 데 유용할 수 있습니다.**<br><br>
4. Implement the argument passing
    - **현재 process_exec()은 새 프로세스에 인수를 전달하는 기능을 지원하지 않습니다.** **이 기능을 구현하려면 process_exec()을 확장하여 단순히 프로그램 파일 이름을 인자로 받는 대신 공백으로 단어로 나누도록 하세요.** 첫 번째 단어는 프로그램 이름, 두 번째 단어는 첫 번째 인수가 되는 식으로 말이죠. **즉, process_exec("grep foo bar")는 두 개의 인자 foo와 bar를 전달하는 grep을 실행**해야 합니다.
    - 명령줄 내에서 여러 개의 공백은 하나의 공백에 해당하므로 process_exec("grep foo bar")는 원래 예제와 동일합니다. 명령줄 인수의 길이에 합리적인 제한을 둘 수 있습니다. 예를 들어 인수를 한 페이지(4KB)에 들어갈 수 있는 길이로 제한할 수 있습니다. (핀토스 유틸리티가 커널에 전달할 수 있는 명령줄 인수는 128바이트로 제한되어 있습니다).
    - 인자 문자열은 원하는 방식으로 구문 분석할 수 있습니다. 길을 잃었다면 include/lib/string.h에 프로토타입이 있고 lib/string.c에 철저한 주석과 함께 구현된 **strtok_r()을 참조**하세요. 자세한 내용은 man 페이지(프롬프트에서 man strtok_r 실행)에서 확인할 수 있습니다.

### 사용자 메모리(User Memory)
1. 사용자 메모리 액세스 구현(Implement user memory access)
    - **시스템 호출을 구현하려면, 사용자 가상 주소 공간에서 데이터를 읽고 쓰는 방법을 제공해야 합니다.** **인수를 받을 때는 이 기능이 필요하지 않습니다.** 그러나 **시스템 호출의 인수로 제공된 포인터에서 데이터를 읽을 때는 이 기능을 통해 프록시해야 합니다.** 사용자가 잘못된 포인터를 제공하거나 커널 메모리에 대한 포인터를 제공하거나 해당 영역 중 하나에 부분적으로 블록을 제공하면 어떻게 될까요? 이러한 경우 사용자 프로세스를 종료하여 처리해야 합니다.

### 시스템 호출(System Calls)
1. 시스템 호출 인프라 구현(Implement system call infrastructure)
    - **userprog/syscall.c에서 시스템 호출 핸들러를 구현**합니다. 우리가 제공하는 스켈레톤 구현은 프로세스를 종료함으로써 시스템 호출을 "처리"합니다. 시스템 호출 번호를 검색한 다음 시스템 호출 인수를 검색하고 적절한 작업을 수행해야 합니다.<br><br>
2. 시스템 호출 세부 정보(System Call Details)
    - 첫 번째 프로젝트에서는 이미 운영 체제가 사용자 프로그램으로부터 제어권을 되찾을 수 있는 한 가지 방법, 즉 타이머와 I/O 디바이스의 인터럽트를 다루었습니다. 이러한 인터럽트는 CPU 외부의 엔티티에 의해 발생하므로 "외부" 인터럽트입니다.
    - 운영체제는 프로그램 코드에서 발생하는 이벤트인 소프트웨어 예외도 처리합니다. 예외는 페이지 오류나 0으로 나눗셈과 같은 오류일 수 있습니다. 예외는 사용자 프로그램이 운영 체제에 서비스를 요청("시스템 호출")할 수 있는 수단이기도 합니다.
    - 기존 x86 아키텍처에서는 시스템 호출이 다른 소프트웨어 예외와 동일하게 처리되었습니다. 그러나 x86-64에서는 제조업체가 시스템 호출에 대한 특수 명령어인 syscall을 도입합니다. 이렇게 하면 시스템 호출 핸들러를 빠르게 호출할 수 있습니다.
    - 오늘날 syscall 명령은 x86-64에서 시스템 호출을 호출하는 데 가장 일반적으로 사용되는 수단입니다. 핀토스에서 사용자 프로그램은 시스템 호출을 위해 syscall을 호출합니다.
    - 시스템 호출 번호와 추가 인수는 두 점을 제외하고는 시스템 호출 명령을 호출하기 전에 일반적인 방식으로 레지스터에 설정되어야 합니다:
        - %rax는 시스템 호출 번호입니다.
        - 네 번째 인수는 %rcx가 아닌 %r10입니다.
    - 따라서, 시스템 호출 핸들러 syscall_handler()가 제어권을 얻으면 시스템 호출 번호는 rax에 있고 인수는 %rdi, %rsi, %rdx, %r10, %r8, %r9의 순서로 전달됩니다.
    - 호출자의 레지스터는 전달된 구조체 intr_frame에 액세스할 수 있습니다. (구조체 intr_frame은 커널 스택에 있습니다.)
    - 함수 반환 값에 대한 x86-64 규칙은 이 값을 RAX 레지스터에 배치하는 것입니다.
    - 시스템 호출은 구조체 intr_frame의 rax 멤버를 수정하여 값을 반환할 수 있습니다.<br><br>
3. 시스템 호출 구현(Implement the following system calls)
    - 나열된 프로토타입은 include/lib/user/syscall.h를 포함하는 사용자 프로그램에서 볼 수 있는 것입니다(이 헤더와 include/lib/user의 다른 모든 헤더는 사용자 프로그램에서만 사용할 수 있습니다). 각 시스템 호출에 대한 시스템 호출 번호는 include/lib/syscall-nr.h에 정의되어 있습니다:
        ```C
        void halt (void);
        ```
        - (src/include/threads/init.h에 선언된) power_off()를 호출하여 핀토스를 종료합니다. 교착 상태에 빠질 수 있는 상황 등에 대한 일부 정보를 잃게 되므로 거의 사용하지 않는 것이 좋습니다.
        ```C
        void exit (int status);
        ```
        - 현재 사용자 프로그램을 종료하여 상태를 커널로 되돌립니다. 프로세스의 부모가 wait하는 경우(아래 참조), 반환되는 status는 이 상태입니다. 일반적으로 0 status는 성공을 나타내고 0이 아닌 값은 오류를 나타냅니다.
        ```C
        pid_t fork (const char *thread_name);
        ```
        - 현재 프로세스의 복제본인 새 프로세스를 THREAD_NAME이라는 이름으로 생성합니다. callee-saved registers인 %RBX, %RSP, %RBP 및 %R12 - %R15를 제외한 레지스터의 값을 복제할 필요가 없습니다. 자식 프로세스의 pid를 반환해야 합니다. 그렇지 않으면 올바른 pid가 될 수 없습니다. 하위 프로세스에서 반환 값은 0이어야 합니다. 자식은 파일 디스크립터 및 가상 메모리 공간을 포함하여 복제된 리소스를 가지고 있어야 합니다. 부모 프로세스는 자식 프로세스가 성공적으로 복제되었는지 여부를 알기 전까지는 fork에서 복귀해서는 안 됩니다. 즉, 자식 프로세스가 리소스를 복제하는 데 실패하면 부모의 fork() 호출은 TID_ERROR를 반환해야 합니다.
        - 템플릿은 threads/mmu.c의 pml4_for_each()를 사용하여 해당 페이지 테이블 구조를 포함한 전체 사용자 메모리 공간을 복사하지만, 전달된 pte_for_each_func의 누락된 부분을 채워야 합니다. virtual address(https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html)참조.
        ```C
        int exec (const char *cmd_line);
        ```
        - 현재 프로세스를 cmd_line에서 지정된 실행 파일로 변경하고 지정된 인수를 전달합니다. 성공하면 반환되지 않습니다. 그렇지 않으면, 어떤 이유로든 프로그램을 로드하거나 실행할 수 없는 경우 프로세스가 종료 상태 -1로 종료됩니다. 이 함수는 exec를 호출한 스레드의 이름을 변경하지 않습니다. 파일 디스크립터는 exec 호출 내내 열려 있는 상태로 유지된다는 점에 유의하세요.
        ```C
        int wait (pid_t pid);
        ```
        - 자식 프로세스 pid를 기다렸다가 자식의 종료 상태를 검색합니다. pid가 아직 살아있으면 종료될 때까지 기다립니다. 그런 다음 종료하기 위해 전달한 pid의 상태를 반환합니다. pid가 exit()를 호출하지 않았지만 커널에 의해 종료된 경우(예: 예외로 인해 종료된 경우) wait(pid)는 -1을 반환해야 합니다. 부모 프로세스가 호출한 wait에 의해 이미 종료된 자식 프로세스를 부모 프로세스가 기다리는 것은 합법적이지만, 커널은 여전히 부모가 자식의 종료 상태를 검색하거나 자식이 커널에 의해 종료되었다는 사실을 알 수 있도록 허용해야 합니다.
        - wait는 다음 조건 중 하나라도 참이면 실패하고 즉시 -1을 반환해야 합니다:
            - pid는 호출 프로세스의 직접 자식을 참조하지 않습니다. pid가 호출 프로세스의 직접 자식이라면, 호출 프로세스가 성공적인 fork 호출의 반환 값으로 pid를 받습니다. 자녀는 상속되지 않는다는 점에 유의하세요: A가 자식 프로세스 B를 스폰하고 B가 자식 프로세스 C를 스폰하는 경우, A는 B가 죽었더라도 C를 기다릴 수 없습니다. 프로세스 A에 의한 wait(C) 호출이 실패해야 합니다. 마찬가지로 고아 프로세스는 부모 프로세스가 종료되기 전에 종료되는 경우 새 부모에 할당되지 않습니다.
            - wait을 호출하는 프로세스는 이미 pid에서 wait을 호출했습니다. 즉, 프로세스는 최대 한 번만 주어진 자식을 wait할 수 있습니다.
    - 프로세스는 자식을 얼마든지 생성할 수 있고, 어떤 순서로든 자식을 wait할 수 있으며, 심지어 일부 또는 모든 자식을 기다리지 않고 종료할 수도 있습니다. 설계에서는 대기 시간이 발생할 수 있는 모든 방법을 고려해야 합니다. struct thread를 포함한 프로세스의 모든 리소스는 부모가 기다리든 기다리지 않든, 자식이 부모보다 먼저 종료하든 나중에 종료하든 관계없이 해제되어야 합니다.
    - 초기 프로세스가 종료될 때까지 핀토스가 종료되지 않도록 해야 합니다. 제공된 핀토스 코드는 main()(threads/init.c)에서 process_wait()(userprog/process.c)를 호출하여 이 작업을 시도합니다. 함수 상단의 주석에 따라 process_wait()를 구현한 다음 process_wait()의 관점에서 대기 시스템 호출을 구현하는 것이 좋습니다.
    - 이 시스템 호출을 구현하려면 다른 어떤 것보다 훨씬 더 많은 작업이 필요합니다.
        ```C
        bool create (const char *file, unsigned initial_size);
        ```
        - initial_size bytes 크기로 초기화된 file이라는 새 파일을 생성한다. 성공하면 참을 반환하고, 그렇지 않으면 거짓을 반환합니다. 새 파일을 생성해도 파일이 열리지 않습니다: 새 파일을 여는 것은 open 시스템 호출이라는 별도의 작업이 필요합니다.
        ```C
        bool remove (const char *file);
        ```
        - file이라는 파일을 삭제합니다. 성공하면 참을 반환하고, 그렇지 않으면 거짓을 반환합니다. 파일은 열려 있는지 여부와 관계없이 제거할 수 있으며 열려 있는 파일을 제거해도 파일이 닫히지 않습니다. 자세한 내용은 FAQ(https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html)에서 Removing an Open File을 참조하세요.
        ```C
        int open (const char *file);
        ```
        - file이라는 파일을 엽니다. '파일 디스크립터'(fd)라는 음수가 아닌 정수 handle을 반환하거나 파일을 열 수 없는 경우 -1을 반환합니다. 0과 1로 번호가 매겨진 파일 디스크립터는 콘솔용으로 예약되어 있습니다: fd 0(STDIN_FILENO)은 표준 입력, fd 1(STDOUT_FILENO)은 표준 출력입니다. open 시스템 호출은 이러한 파일 디스크립터를 반환하지 않으며, 이들은 아래에 명시적으로 설명된 시스템 호출 인수로만 유효합니다. 각 프로세스에는 독립적인 파일 디스크립터 집합이 있습니다. 파일 디스크립터는 하위 프로세스에 의해 상속됩니다. 단일 프로세스에서든 다른 프로세스에서든 단일 파일을 두 번 이상 열면 열 때마다 새 파일 디스크립터가 반환됩니다. 단일 파일에 대한 서로 다른 파일 디스크립터는 별도의 close 호출을 통해 독립적으로 닫히며 파일 위치를 공유하지 않습니다. 추가 작업을 수행하려면 0부터 시작하는 정수를 반환하는 리눅스 스키마를 따라야 합니다.
        ```C
        int filesize (int fd);
        ```
        - fd로 열린 파일의 크기(바이트)를 반환합니다.
        ```C
        int read (int fd, void *buffer, unsigned size);
        ```
        - fd로 열린 파일에서 buffer로 size 바이트를 읽습니다. 실제로 읽은 바이트 수(파일 끝에서 0)를 반환하거나, 파일 끝이 아닌 다른 조건으로 인해 파일을 읽을 수 없는 경우 -1을 반환합니다. fd 0은 input_getc()를 사용하여 키보드에서 읽습니다.
        ```C
        int write (int fd, const void *buffer, unsigned size);
        ```
        - buffer에서 열린 파일 fd에 size 바이트를 씁니다. 실제로 기록된 바이트 수를 반환하며, 일부 바이트가 기록되지 않은 경우 size보다 작을 수 있습니다. 파일 끝을 지나서 쓰면 일반적으로 파일이 확장되지만 기본 파일 시스템에서는 파일 증가를 구현하지 않습니다. 예상되는 동작은 파일 끝 부분까지 가능한 한 많은 바이트를 쓰고 실제로 쓰여진 수를 반환하거나, 바이트가 전혀 쓰여지지 않으면 0을 반환하는 것입니다. fd 1은 콘솔에 씁니다. 콘솔에 쓰는 코드는 적어도 크기가 수백 바이트보다 크지 않은 한 putbuf() 호출 한 번으로 모든 버퍼를 써야 합니다(큰 버퍼는 분할하는 것이 합리적입니다). 그렇지 않으면, 서로 다른 프로세스에서 출력된 텍스트 줄이 콘솔에 끼어들어 채점 스크립트를 읽는 사람과 채점 스크립트 모두를 혼란스럽게 만들 수 있습니다.
        ```C
        void seek (int fd, unsigned position);
        ```
        - 열린 파일 fd에서 읽거나 쓸 다음 바이트를 파일 시작부터 바이트 단위로 표시되는 position으로 변경합니다(따라서 position이 0이면 파일의 시작입니다). 파일의 현재 끝을 지나서 찾는 것은 오류가 아닙니다. 나중에 read하면 파일 끝을 나타내는 0바이트를 얻습니다. 나중에 write하면 파일이 확장되어 기록되지 않은 공백이 0으로 채워집니다.(단, 핀토스에서는 프로젝트 4가 완료될 때까지 파일 길이가 고정되어 있으므로 파일 끝을 지나서 write하면 오류가 반환됩니다.) 이러한 시맨틱은 파일 시스템에서 구현되며, 시스템 호출 구현에 특별한 노력이 필요하지 않습니다.
        ```C
        unsigned tell (int fd);
        ```
        - 열린 파일 fd에서 읽거나 쓸 다음 바이트의 위치를 파일 시작부터 바이트 단위로 반환합니다.
        ```C
        void close (int fd);
        ```
        - 파일 디스크립터 fd를 닫습니다. 프로세스를 종료하거나 종료하면 마치 각 파일에 대해 이 함수를 호출하는 것처럼 열려 있는 모든 파일 디스크립터가 암시적으로 닫힙니다.
    - 이 파일은 다른 시스템 호출을 정의합니다. 지금은 그들을 무시하세요. 일부는 프로젝트 3에서 구현하고 나머지는 프로젝트 4에서 구현하므로 확장성을 염두에 두고 시스템을 설계해야 합니다.
    - 시스템 호출을 동기화하여 여러 사용자 프로세스가 동시에 호출할 수 있도록 해야 합니다. 특히 filesys 디렉토리에 제공된 파일 시스템 코드를 여러 스레드에서 한 번에 호출하는 것은 안전하지 않습니다. 시스템 호출 구현에서는 파일 시스템 코드를 중요 섹션으로 취급해야 합니다. process_exec()도 파일에 액세스한다는 사실을 잊지 마세요. 현재로서는 filesys 디렉토리의 코드를 수정하지 않는 것이 좋습니다.
    - 각 시스템 호출에 대한 사용자 수준 함수를 lib/user/syscall.c에 제공했습니다. 이는 사용자 프로세스가 C 프로그램에서 각 시스템 호출을 호출하는 방법을 제공합니다. 각각은 약간의 인라인 어셈블리 코드를 사용하여 시스템 호출을 호출하고 (적절한 경우) 시스템 호출의 반환값을 반환합니다.
    - 이 부분을 끝내고 나면, 영원히 핀토스는 완벽해야 합니다. 사용자 프로그램으로 인해 OS가 충돌, 패닉, 어설션 실패 또는 기타 오작동을 일으켜서는 안 됩니다. 이 점을 강조하는 것이 중요합니다: 테스트는 여러 가지 방법으로 시스템 호출을 중단하려고 시도합니다. 모든 코너 케이스를 생각하고 처리해야 합니다. 사용자 프로그램이 OS를 중지시킬 수 있는 유일한 방법은 중지 시스템 호출을 호출하는 것입니다.
    - 시스템 호출에 잘못된 인수가 전달되면 오류 값 반환(값을 반환하는 호출의 경우), 정의되지 않은 값 반환 또는 프로세스 종료가 허용됩니다.

### 프로세스 종료 메시지(Process Termination Messages)
1. 프로세스 종료 메시지 인쇄(Print out the process termination message)
    - 사용자 프로세스가 exit 호출 또는 기타 이유로 종료될 때마다 프로세스의 이름과 종료 코드를 다음과 같은 형식으로 인쇄합니다.
        ```C
        printf ("%s: exit(%d)\n", ...);
        ```
    - 인쇄되는 이름은 fork()에 전달된 전체 이름이어야 합니다. 사용자 프로세스가 아닌 커널 스레드가 종료되거나 중단 시스템 호출이 호출될 때는 이러한 메시지를 인쇄하지 마세요. 프로세스가 로드되지 않을 경우 메시지는 선택 사항입니다.
    - 이 메시지 외에 제공된 핀토스가 이미 인쇄하지 않는 다른 메시지는 인쇄하지 마세요. 디버깅 중에 추가 메시지가 유용할 수 있지만 채점 스크립트를 혼동하여 점수가 낮아질 수 있습니다. 

### 실행 파일에 대한 쓰기 거부(Denying Writes to Executables)
1. 실행 파일에 대한 쓰기 거부(Deny write on executables)
    - 실행 파일로 사용 중인 파일에 대한 쓰기를 거부하는 코드를 추가하세요. 프로세스가 디스크에서 변경 중인 코드를 실행하려고 할 때 예측할 수 없는 결과가 발생할 수 있기 때문에 많은 OS에서 이 기능을 사용합니다. 이는 프로젝트 3에서 가상 메모리를 구현한 후에 특히 중요하지만, 지금이라도 이 기능을 추가하는 것이 좋습니다.
    - 열린 파일에 대한 쓰기를 방지하기 위해 file_deny_write()를 사용할 수 있습니다. 파일에 대해 file_allow_write()를 호출하면 다시 사용할 수 있습니다(다른 오프너에서 파일 쓰기를 거부하지 않는 한). 파일을 닫으면 쓰기 기능도 다시 활성화됩니다. 따라서 프로세스의 실행 파일에 대한 쓰기를 거부하려면 프로세스가 계속 실행되는 동안 파일을 열어 두어야 합니다.

## 2. PROJECT2(USER PROGRAMS) 개념 학습
### Caller & Callee
1. Caller
    - 호출자 / 함수를 호출한 대상
    - main() 함수에서 func()이 호출되는 경우 main() 함수에 해당<br><br>
2. Callee
    - 피호출자 / 호출을 당한 함수
    - main() 함수에서 func()이 호출되는 경우 func() 함수에 해당<br><br>
3. Caller-saved-register(콜러가 저장하는 레지스터)
    - main() 함수는 실행하면서 레지스터를 사용 -> func() 함수가 return되면, 다시 func() 함수가 호출되기 전 레지스터의 값을 가지고 있어야 함 -> 이 때, caller가 저장하고 보존되도록 신경써야 하는 레지스터(callee는 이 레지스터를 자유롭게 사용 가능)
    - 사용하기 전 caller가 반드시 백업해야 하는 레지스터
    - callee가 사용 가능
    - 값이 보존되지 않아도 되는 경우에는 백업을 하지 않을 수 있음
    - 레지스터 종류
        - EAX(Extended Accumulator Register) : 논리 연산
        - ECX(Extended Counter Register) : 카운터 레지스터로, 반복 명령어 사용시 반복 카운터로 사용
        - EDX(Extended Data Register) : EAX와 같이 연산에 쓰이며, 부호 확장 명령 등에 쓰임<br><br>
4. Callee-saved-register(콜리가 저장하는 레지스터)
    - 사용하기 전 callee가 반드시 백업해야 하는 레지스터
    - caller가 사용 가능
    - 함수 복귀 전 다시 값을 복원해야 함
    - callee 입장에서는 caller가 백업을 필요로하는 레지스터가 무엇인지 모르기 때문에 무조건 백업
    - 레지스터 종류
        - EBX(Extended Base address Register) : 메모리 주소 저장을 위한 레지스터로, ESI나 EDI와 결합하여 사용 가능
        - ESI(Extended Source Index) : 데이터 조작 및 복사시 소스 데이터의 주소가 저장됨
        - EDI(Extended Destination Index) : 복사 시 목적지의 주소가 저장되며, ESI 레지스터와 비슷
        - EBP(Extended Base Pointer) : 스택 프레임의 시작 지점 주소(스택의 가장 윗 부분, 스택의 처음)가 저장되며, 현재 스택 프레임이 소멸되지 않는 이상 EBP 레지스터의 값은 변하지 않음

### 스택 프레임(Stack Frame)
1. 스택 프레임이란?
    - 함수의 호출 과정에서 호출되는 함수를 사용하기 위해 할당되는 스택의 공간을 의미
    - 스택 영역의 함수를 구분하기 위해 생성되는 공간으로서 매개변수(parameter), 복귀할 명령어의 주소(return address), 지역변수(local variables), 이전 스택 프레임의 EBP값을 포함하고 있음
    - 함수 호출 시 함수의 프롤로그(prolog) 과정을 통해 생성되고, 함수의 에필로그(epilog) 과정을 통해 함수가 종료되면서 소멸<br><br>
2. gdb를 통해 함수 호출 실행 과정
    - 예를 들어, 아래와 같은 코드가 있다고 가정
        ```C
        #include <stdio.h>
 
        void sum(int a, int b) {
            printf("sum : %d\n", a+b);
        }
        
        int main() {
            int num1, num2 ; 

            scanf("%d %d", &num1, &num2);   
            sum(num1, num2);
            
            return 0;
        }
        ```
        - 단순히 두 개의 정수 값을 입력 받아 sum 함수를 호출하여 입력받은 두 정수의 합을 구하는 프로그램
    - gdb를 통해 main() 함수를 살펴보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQcZHH%2Fbtrrum3xGML%2FYH9CaZcMK76PH5Ky8zfdxK%2Fimg.png" height="300"></img>
        - main() 함수를 확인해보면, 위와 같이 sum 함수를 호출하는 부분을 찾을 수 있음
        - 함수를 호출할 때는 call 명령어을 수행
            ```
            - push eip
            - jmp 함수의 주소
            ```
    - sum 함수가 호출되기 전에 break를 걸어 실행하여 위에서 설명한 방식대로 동작하는지 확인  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9hvca%2Fbtrro6OcrEB%2FZoG2F1PPKR91Gp3xttsgj0%2Fimg.png" height="390"></img>
        - si 명령을 통한 sum() 함수 내부 확인  
            <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4ZNeX%2FbtrrpnbyWsX%2FekcwGqxuwK9cp3DeKte1sk%2Fimg.png" height="80"></img>
            - esp를 확인해보면, 0x080484af(call 0x804846b의 다음 명령어) 주소가 스택에 push되어 있음
            - return address(0x80484af) 오른쪽을 보면 3, 5가 들어가 있으며, 이는 parameter 값<br><br>
3. 함수의 프롤로그(Prolog)
    - 함수의 프롤로그 부분에서는 스택 프레임을 형성하는 역할을 수행
    - 함수의 프롤로그 명령어  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUr5fN%2FbtrrunuC6ol%2FxJkSOByD4e852kxCzzuwb1%2Fimg.png" height="200"></img>
        - push ebp(base pointer)
            - 스택 상에서 한 데이터를 가리키는 포인터
            - 이전에 수행하던 함수의 데이터를 보존하기 위해 ebp를 push함으로써 caller 함수(현재 함수를 호출한 함수, main() 함수)의 ebp값을 스택에 저장  
                <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbbCJn%2FbtrrpT9dO9x%2FyGss7ekw5lFOnz75zB3RDk%2Fimg.png" height="300"></img>
                - push ebp가 수행된 후 스택의 상태를 살펴보면, 0xbfffefe8(main 함수의 ebp)이 push되어 있음
        - mov ebp, esp(stack pointer)
            - 스택 세그먼트의 맨 꼭대기를 가리키는 포인터
            - esp를 ebp에 복사함으로써 esp를 ebp 주소로 설정  
                <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqCyVF%2FbtrrxXhUdxd%2FUzEsdUCVGudpC9pdTVk0w1%2Fimg.png" height="120"></img>
                - mov ebp, esp가 수행된 후 스택의 상태를 살펴보면, esp가 가리키는 주소 값을 ebp에 복사함으로써 함수가 시작될 때 stack pointer와 base pointer가 새로 지정된 것을 확인할 수 있음<br><br>
4. 함수의 에필로그(Epilog)
    - 함수의 에필로그 부분에서는 스택 프레임을 소멸시키는 역할을 수행
    - 함수의 에필로그 명령어  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Flbnyv%2Fbtrrwec9g2h%2FCMDwvxkT6rdrvwkp0mnc91%2Fimg.png" height="200"></img>
        - leave 명령어
            ```
            - mov esp, ebp
            - pop ebp
            ```
            - stack pointer를 이전 base pointer로 저장해줌으로써 sum() 함수를 호출하면서 확장했던 스택 공간을 없애버리고, push해서 저장해두었던 이전 함수 main() 함수의 base pointer를 복원시키는 작업을 수행
            - 위 과정을 거치면, esp는 return address를 가리키고 있게 됨
        - ret 명령어
            ```
            - pop eip
            ```
            - call 명령어의 다음 명령어로 return 하라는 의미로서 EIP 레지스터에 return address를 pop하여 집어넣는 역할을 수행
            - 위 과정을 거치면, call 명령어의 다음 명령어로 돌아가게 됨