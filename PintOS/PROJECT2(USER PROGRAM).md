# PROJECT2 : USER PROGRAMS

## 1. PROJECT2(USER PROGRAMS) GitBook Contents
### Introduction
1. Project2: User Programs
    - 이제 핀토스를 사용해 보고 인프라와 스레드 패키지에 익숙해졌으므로 이제 사용자 프로그램을 실행할 수 있는 시스템 부분에 대한 작업을 시작할 차례입니다. 기본 코드는 이미 사용자 프로그램 로딩과 실행을 지원하지만 I/O 또는 상호 작용은 불가능합니다. 이 프로젝트에서는 시스템 호출을 통해 프로그램이 OS와 상호 작용할 수 있도록 합니다. 이 과제를 위해 userprog 디렉토리에서 작업하게 되지만, 핀토스의 거의 모든 다른 부분과도 상호작용하게 됩니다. 아래에서 관련 부분을 설명하겠습니다.
    - 프로젝트1 제출물 위에 프로젝트2를 빌드해야 합니다. 프로젝트 1의 코드가 프로젝트 2의 코드에 영향을 미치지는 않지만 증분 프로젝트이므로 프로젝트 1에 대한 테스트 케이스를 통과해야 합니다.
    - 또한, 프로젝트2에는 추가 챌린지가 있으며, 이것은 선택적 구현일 뿐입니다. 추가 챌린지의 경우 테스트 케이스 외에는 스켈레톤 코드가 제공되지 않습니다. 모든 디자인은 여러분의 몫입니다. 추가 요구 사항을 제출하고 테스트하려면 userprog/Make.vars를 편집해야 합니다.
    - 마지막으로, TODO가 없는 코드라고 해서 항상 해당 코드를 변경할 필요가 없는 것은 아니라는 점에 유의하세요. 테스트 코드를 제외한 프로젝트2의 모든 소스 코드를 자유롭게 수정할 수 있습니다.<br><br>
2. Background
    - 지금까지 핀토스에서 실행한 모든 코드는 운영 체제 커널의 일부였습니다. 예를 들어, 마지막 과제의 모든 테스트 코드는 커널의 일부로 실행되었으며, 시스템의 권한 있는 부분에 대한 전체 액세스 권한이 있었습니다. 운영 체제 위에서 사용자 프로그램을 실행하기 시작하면 더 이상 그렇지 않습니다. 이 프로젝트는 그 결과를 다룹니다.
    - 한 번에 하나 이상의 프로세스를 실행할 수 있습니다. 각 프로세스에는 하나의 스레드가 있습니다(멀티스레드 프로세스는 지원되지 않음). 사용자 프로그램은 마치 전체 시스템을 소유한 것처럼 착각하여 작성됩니다. 즉, 한 번에 여러 프로세스를 로드하고 실행할 때 이 착각을 유지하기 위해 메모리, 스케줄링 및 기타 상태를 올바르게 관리해야 합니다.
    - 이전 프로젝트에서는 테스트 코드를 커널에 직접 컴파일했기 때문에 커널 내 특정 기능 인터페이스가 필요했습니다. 이제부터는 사용자 프로그램을 실행하여 운영 체제를 테스트합니다. 이렇게 하면 훨씬 더 자유로워집니다. 사용자 프로그램 인터페이스가 여기에 설명된 사양을 충족하는지 확인해야 하지만, 이러한 제약이 있으므로 커널 코드를 원하는 대로 자유롭게 재구성하거나 재작성할 수 있습니다. 모든 코드는 #ifdef VM으로 둘러싸인 블록에 위치하지 않아야 합니다. 이 블록은 프로젝트 3에서 구현할 가상 메모리 서브시스템을 활성화한 후에 포함될 것입니다. 또한 코드가 #ifndef VM으로 둘러싸인 경우 해당 코드는 프로젝트 3에서 생략됩니다.
    - 시작하기 전에 동기화(https://casys-kaist.github.io/pintos-kaist/appendix/synchronization.html) 및 가상 주소(https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html)에 대해 읽어보실 것을 강력히 권장합니다.<br><br>
3. Source Files
    - 작업할 프로그래밍의 개요를 파악하는 가장 쉬운 방법은 작업할 각 부분을 간단히 살펴보는 것입니다. userprog에서는 적은 수의 파일을 찾을 수 있지만, 여기서 대부분의 작업을 수행할 수 있습니다:
        - process.c, process.h
            - ELF 바이너리를 로드하고 프로세스를 시작합니다.
        - **syscall.c, syscall.h**
            - 사용자 프로세스가 일부 커널 기능에 액세스하려고 할 때마다 시스템 호출을 호출합니다. 이것이 스켈레톤 시스템 호출 핸들러입니다. 현재는 메시지를 출력하고 사용자 프로세스를 종료하기만 합니다. **이 프로젝트의 파트 2에서는 시스템 호출에 필요한 다른 모든 작업을 수행하는 코드를 추가할 것입니다.**
        - syscall-entry.S
            - 시스템 호출 핸들러를 부트스트랩하는 작은 어셈블리 코드입니다. 이 코드를 이해할 필요는 없습니다.
        - **exception.c, exception.h**
            - 사용자 프로세스가 권한이 있거나 금지된 작업을 수행하면 예외 또는 오류로 커널에 트래핑됩니다. 이러한 파일은 예외를 처리합니다. 현재 모든 예외는 단순히 메시지를 출력하고 프로세스를 종료합니다. 프로젝트 2의 일부 솔루션(전부는 아님)은 **이 파일에서 page_fault()를 수정해야 합니다.**
        - gdt.c, gdt.h
            - x86-64는 세그먼트 아키텍처입니다. 글로벌 설명자 테이블(GDT, Global Descriptor Table)은 사용 중인 세그먼트를 설명하는 테이블입니다. 이 파일은 GDT를 설정합니다. 어떤 프로젝트에서도 이 파일을 수정할 필요가 없습니다. GDT의 작동 방식이 궁금하다면 코드를 읽어볼 수 있습니다.
        - tss.c, tss.h
            - 작업 상태 세그먼트(TSS, Task-State Segment)는 x86 아키텍처 작업 전환에 사용되었습니다. 그러나, x86-64에서는 태스크 스위칭이 더 이상 사용되지 않습니다. 그럼에도 불구하고 링 스위칭 중에 스택 포인터를 찾기 위해 TSS는 여전히 존재합니다.
            - 즉, 사용자 프로세스가 인터럽트 핸들러에 진입하면 하드웨어가 tss를 참조하여 커널의 스택 포인터를 조회합니다. 어떤 프로젝트에 대해서도 이러한 파일을 수정할 필요가 없습니다. TSS의 작동 방식이 궁금하다면 코드를 읽어볼 수 있습니다.<br><br>
4. Using the File System
    - 사용자 프로그램이 파일 시스템에서 로드되고 구현해야 하는 많은 시스템 호출이 파일 시스템을 다루기 때문에 이 프로젝트에서는 파일 시스템 코드에 인터페이스해야 합니다. 하지만, 이 프로젝트의 초점은 파일 시스템이 아니므로 filesys 디렉터리에 간단하지만 완전한 파일 시스템을 제공했습니다. 파일 시스템 사용 방법, 특히 파일 시스템의 여러 제한 사항을 이해하려면 filesys.h 및 file.h 인터페이스를 살펴보는 것이 좋습니다.
    - 이 프로젝트의 파일 시스템 코드를 수정할 필요는 없으므로 수정하지 않는 것이 좋습니다. 파일 시스템 작업은 이 프로젝트에 집중하는 데 방해가 될 수 있습니다.
    - 지금 파일 시스템 루틴을 적절히 사용하면 파일 시스템 구현을 개선할 때 프로젝트 4를 훨씬 쉽게 수행할 수 있습니다. 그때까지는 다음과 같은 제한 사항을 감수해야 합니다:
        - 내부 동기화가 없습니다. 동시 액세스는 서로 간섭을 일으킵니다. 동기화를 사용하여 한 번에 하나의 프로세스만 파일 시스템 코드를 실행하도록 해야 합니다.
        - 파일 크기는 생성 시 고정됩니다. 루트 디렉터리는 파일로 표시되므로 생성할 수 있는 파일 수 또한 제한됩니다.
        - 파일 데이터는 단일 범위로 할당되므로, 단일 파일의 데이터는 디스크의 연속된 섹터 범위를 차지해야 합니다. 따라서, 파일 시스템은 시간이 지남에 따라 사용되므로 외부 조각화(External fragmentation)는 심각한 문제가 될 수 있습니다.
        - 하위 디렉터리 없음
        - 파일 이름은 14자로 제한됩니다.
        - 작업 중 시스템 충돌이 발생하면 자동으로 복구할 수 없는 방식으로 디스크가 손상될 수 있습니다. 어쨌든 파일 시스템 복구 도구는 없습니다.
    - 한 가지 중요한 기능이 포함되어 있습니다:
        - filesys_remove()에 대한 유닉스와 유사한 시맨틱이 구현되었습니다. 즉, 파일이 제거될 때 열려 있는 경우 해당 블록은 할당 해제되지 않으며, 마지막 스레드가 파일을 닫을 때까지 열려 있는 모든 스레드에서 계속 액세스할 수 있습니다. 자세한 내용은 Removing an Open File(https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html)를 참조하세요.
    - 모든 테스트 프로그램이 커널 이미지에 이미 존재했던 프로젝트 1과 달리, **테스트 프로그램(사용자 공간에서 실행되는)을 핀토스 가상 머신에 넣어야 합니다.** 테스트 스크립트(예: make check)가 이 작업을 자동으로 처리하므로 대부분의 경우 이를 이해할 필요가 없습니다. 하지만 이를 알면 개별 테스트 케이스를 실행하는 데 큰 도움이 됩니다.
    - **핀토스 가상 머신에 파일을 넣으려면 먼저 파일 시스템 파티션이 있는 시뮬레이션 디스크를 생성할 수 있어야 합니다.** **pintos-mkdisk 프로그램이 이 기능을 제공**합니다. **userprog/build 디렉토리에서 pintos-mkdisk filesys.dsk 2를 실행**합니다. **이 명령은 2MB 핀토스 파일 시스템 파티션이 포함된 filesys.dsk라는 이름의 시뮬레이션 디스크를 생성**합니다. 그런 다음 **--fs-disk filesys.dsk 뒤에 --를 전달하여 디스크를 지정합니다(예: pintos --fs-disk filesys.disk -- KERNEL_COMMANDS...).** **fs-disk는 시뮬레이션된 커널이 아니라 핀토스 스크립트를 위한 것이므로 --가 필요**합니다. 그런 다음 커널의 명령줄에 **-f -q를 전달하여 파일 시스템 파티션을 포맷**합니다: **pintos SCRIPT_COMMANDS -- -f -q**. **f 옵션은 파일 시스템을 포맷하도록 하고, -q는 포맷이 완료되는 즉시 핀토스를 종료**하도록 합니다.
    - **시뮬레이션된 파일 시스템 안팎으로 파일을 복사할 수 있는 방법이 필요**합니다. **pintos -p("put") 및 -g("get") 옵션이 이 작업을 수행**합니다. **'file'을 핀토스 파일 시스템으로 복사하려면 pintos -p file -- -q 명령을 사용**합니다. **New name이라는 이름으로 핀토스 파일 시스템에 복사하려면 원본 파일 이름 뒤에 :new name을 추가**합니다: **pintos -p 파일:new name -- -q**. **VM에서 파일을 복사하는 명령은 비슷하지만 -p 대신 -g로 대체**합니다.
    - 참고로, 이러한 명령은 커널의 명령줄에 특수 명령 extract와 append를 전달하고 시뮬레이션된 특수 "스크래치" 파티션에 복사하는 방식으로 작동합니다. 궁금한 점이 많으시다면 핀토스 스크립트와 filesys/fsutil.c를 참조하여 구현 세부 사항을 알아보세요.
    - 다음은 **파일 시스템 파티션이 있는 디스크를 만들고, 파일 시스템을 포맷하고, 이 프로젝트의 두 번째 테스트 케이스인 단일 프로그램인 args를 새 디스크에 복사한 다음, 인자 'onearg'를 전달하여 실행하는 방법**을 요약한 것입니다. (인자 전달은 구현하기 전까지는 작동하지 않습니다.) 테스트 케이스를 이미 빌드했으며 현재 디렉터리가 userprog/build라고 가정합니다:
        ```C
        pintos-mkdisk filesys.dsk 10
        pintos --fs-disk filesys.dsk -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
    - 나중에 사용하거나 검사하기 위해 파일 시스템 디스크를 보관하고 싶지 않다면 네 단계를 모두 단일 명령으로 결합할 수도 있습니다. --filesys-size=n 옵션은 핀토스 실행 기간 동안만 약 n메가바이트 크기의 임시 파일 시스템 파티션을 생성합니다. 핀토스 자동 테스트 스위트는 이 구문을 광범위하게 사용합니다:
        ```C
        pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
5. How User Programs Work
    - 핀토스는 메모리에 맞고 사용자가 구현한 시스템 호출만 사용하는 한 일반 C 프로그램을 실행할 수 있습니다. 특히 이 프로젝트에 필요한 시스템 호출 중 메모리 할당을 허용하는 시스템 호출이 없기 때문에 malloc()을 구현할 수 없습니다. 또한 핀토스는 스레드를 전환할 때 커널이 프로세서의 부동 소수점 단위를 저장 및 복원하지 않기 때문에 부동 소수점 연산을 사용하는 프로그램을 실행할 수 없습니다.
    - 핀토스는 userprog/process.c에 제공된 로더를 사용하여 ELF 실행 파일을 로드할 수 있습니다. ELF는 Linux, Solaris 및 기타 여러 운영 체제에서 객체 파일, 공유 라이브러리 및 실행 파일에 사용하는 파일 형식입니다.
    - 실제로 x86-64 ELF 실행 파일을 출력하는 모든 컴파일러와 링커를 사용하여 핀토스용 프로그램을 생성할 수 있습니다. (저희가 제공한 컴파일러와 링커는 잘 작동합니다.) 테스트 프로그램을 시뮬레이션된 파일 시스템에 복사하기 전까지는 핀토스가 유용한 작업을 수행할 수 없다는 것을 즉시 깨달아야 합니다. 다양한 프로그램을 파일 시스템에 복사하기 전까지는 흥미로운 작업을 할 수 없습니다. 디버깅 중에 가끔 발생할 수 있는 파일을 유용한 상태가 아닌 파일 시스템 디스크를 휴지통에 버릴 때마다 깨끗한 참조 파일 시스템 디스크를 만들어 복사하는 것이 좋습니다.<br><br>
6. Virtual Memory Layout
    - 핀토스의 가상 메모리는 사용자 가상 메모리와 커널 가상 메모리의 두 영역으로 나뉩니다. 사용자 가상 메모리는 가상 주소 0에서 include/threads/vaddr.h에 정의된 KERN_BASE까지이며 기본값은 0x8004000000입니다. 커널 가상 메모리는 나머지 가상 주소 공간을 차지합니다.
    - 사용자 가상 메모리는 프로세스 단위(per-process)입니다. 커널이 한 프로세스에서 다른 프로세스로 전환할 때, 프로세서의 페이지 디렉터리 베이스 레지스터를 변경하여 사용자 가상 주소 공간도 전환합니다(thread/mmu.c의 pml4_activate() 참조). 구조체 thread는 프로세스의 페이지 테이블에 대한 포인터를 포함합니다.
    - 커널 가상 메모리는 전역적입니다. 실행 중인 사용자 프로세스나 커널 스레드에 관계없이 항상 동일한 방식으로 매핑됩니다. 핀토스에서 커널 가상 메모리는 KERN_BASE부터 시작하여 물리적 메모리에 일대일로 매핑됩니다. 즉, 가상 주소 KERN_BASE는 물리적 주소 0에 액세스하고, 가상 주소 KERN_BASE + 0x1234는 물리적 주소 0x1234에 액세스하는 식으로 머신의 물리적 메모리 크기까지 액세스합니다.
    - 사용자 프로그램은 자신의 사용자 가상 메모리에만 액세스할 수 있습니다. 커널 가상 메모리에 액세스하려고 시도하면 userprog/exception.c의 page_fault()가 처리하는 페이지 오류가 발생하고 프로세스가 종료됩니다. 커널 스레드는 커널 가상 메모리와 사용자 프로세스가 실행 중인 경우 실행 중인 프로세스의 사용자 가상 메모리에 모두 액세스할 수 있습니다. 그러나, 커널에서도 매핑되지 않은 사용자 가상 주소로 메모리에 액세스하려고 시도하면 페이지 오류가 발생합니다.<br><br>
7. Typical Memory Layout
    - 개념적으로 각 프로세스는 자체 사용자 가상 메모리를 원하는 대로 자유롭게 배치할 수 있습니다. 실제로 사용자 가상 메모리는 다음과 같이 배치됩니다:
        ```C
         USER_STACK +----------------------------------+
                    |             user stack           |
                    |                 |                |
                    |                 |                |
                    |                 V                |
                    |           grows downward         |
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                    |           grows upward           |
                    |                 ^                |
                    |                 |                |
                    |                 |                |
                    +----------------------------------+
                    | uninitialized data segment (BSS) |
                    +----------------------------------+
                    |     initialized data segment     |
                    +----------------------------------+
                    |            code segment          |
          0x400000  +----------------------------------+
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                    |                                  |
                0   +----------------------------------+
        ```
    - 이 프로젝트에서는 사용자 스택의 크기가 고정되어 있지만 프로젝트 3에서는 크기가 커질 수 있습니다. 기존에는 초기화되지 않은 데이터 세그먼트의 크기를 시스템 호출로 조정할 수 있었지만, 이 기능을 구현할 필요는 없습니다.
    - 핀토스의 코드 세그먼트는 사용자 가상 주소 0x400000에서 시작하며, 주소 공간의 맨 아래에서 약 128MB입니다. 이 값은 우분투의 일반적인 값으로 큰 의미는 없습니다.
    - 링커는 다양한 프로그램 세그먼트의 이름과 위치를 알려주는 "링커 스크립트"의 지시에 따라 메모리에서 사용자 프로그램의 레이아웃을 설정합니다.
    - 특정 실행 파일의 레이아웃을 보려면 -p 옵션과 함께 objdump를 실행하세요.<br><br>
8. Accessing User Memory
    - **시스템 호출의 일부로 커널은 종종 사용자 프로그램이 제공하는 포인터를 통해 메모리에 액세스해야 합니다. 사용자가 널 포인터, 매핑되지 않은 가상 메모리에 대한 포인터 또는 커널 가상 주소 공간(KERN_BASE 위)에 대한 포인터를 전달할 수 있으므로 커널은 이를 매우 신중하게 처리해야 합니다. 이러한 모든 유형의 잘못된 포인터는 커널이나 실행 중인 다른 프로세스에 해를 끼치지 않고 거부되어야 하며, 문제가 되는 프로세스를 종료하고 해당 리소스를 해제해야 합니다.**
    - **이 작업을 올바르게 수행하는 데는 최소한 두 가지 합리적인 방법**이 있습니다. 첫 번째 방법은 **사용자가 제공한 포인터의 유효성을 확인한 다음 포인터를 참조 해제하는 것**입니다. 이 방법을 선택하는 경우 thread/mmu.c와 include/threads/vaddr.h의 함수를 살펴볼 수 있습니다. 이 방법은 사용자 메모리 액세스를 처리하는 가장 간단한 방법입니다.
    - 두 번째 방법은 **사용자 포인터가 KERN_BASE 아래를 가리키는지만 확인한 다음 이를 참조 해제하는 것**입니다. **잘못된 사용자 포인터는 "페이지 오류"를 발생시키며, userprog/exception.c에서 page_fault()의 코드를 수정하여 처리할 수 있습니다.** 이 기술은 프로세서의 MMU를 활용하기 때문에 일반적으로 더 빠르므로 실제 커널(Linux 포함)에서 사용되는 경향이 있습니다.
    - **두 경우 모두 리소스가 '누수'되지 않도록 주의**해야 합니다. 예를 들어, 시스템 호출이 malloc()을 통해 lock을 획득하거나 메모리를 할당했다고 가정해 보겠습니다. 나중에 잘못된 사용자 포인터가 발생하더라도 반드시 잠금을 해제하거나 메모리 페이지를 해제해야 합니다. 사용자 포인터를 역참조하기 전에 확인하도록 선택했다면 이 과정은 간단합니다. 잘못된 포인터로 인해 페이지 오류가 발생하는 경우 메모리 액세스에서 오류 코드를 반환할 방법이 없으므로 처리하기가 더 어렵습니다. 따라서, **후자의 기법을 시도해보고 싶은 분들을 위해 약간의 유용한 코드를 제공**하겠습니다:
        ```C
        /* Reads a byte at user virtual address UADDR.
        * UADDR must be below KERN_BASE.
        * Returns the byte value if successful, -1 if a segfault
        * occurred. */
        static int64_t
        get_user (const uint8_t *uaddr) {
            int64_t result;
            __asm __volatile (
            "movabsq $done_get, %0\n"
            "movzbq %1, %0\n"
            "done_get:\n"
            : "=&a" (result) : "m" (*uaddr));
            return result;
        }

        /* Writes BYTE to user address UDST.
        * UDST must be below KERN_BASE.
        * Returns true if successful, false if a segfault occurred. */
        static bool
        put_user (uint8_t *udst, uint8_t byte) {
            int64_t error_code;
            __asm __volatile (
            "movabsq $done_put, %0\n"
            "movb %b2, %1\n"
            "done_put:\n"
            : "=&a" (error_code), "=m" (*udst) : "q" (byte));
            return error_code != -1;
        }
        ```
        - 이러한 각 함수는 사용자 주소가 이미 KERN_BASE 아래에 있는 것으로 확인되었다고 가정합니다. 또한 커널에서 페이지 오류가 발생하면 rax를 -1로 설정하고 이전 값을 %rip에 복사하도록 page_fault()를 수정했다고 가정합니다.

### 인수 전달(Argument Passing)
1. 인수 전달(Argument Passing)
    - process_exec()에서 사용자 프로그램에 대한 인수를 설정합니다.<br><br>
2. x86-64 호출 규칙(x86-64 Calling Convention)
    - 이 섹션에서는 **64비트 x86-64 유닉스 구현에서 일반 함수 호출에 사용되는 규약**의 중요한 사항을 요약합니다. 간결성을 위해 일부 세부 사항은 생략했습니다. 자세한 내용은 System V AMD64 ABI(https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)를 참조하십시오.
    - 호출 규칙은 다음과 같이 작동합니다:
        - **사용자 수준 애플리케이션은 %rdi, %rsi, %rdx, %rcx, %r8 및 %r9 시퀀스를 전달하기 위한 정수 레지스터로 사용**합니다.
        - **호출자는 스택에서 다음 명령어의 주소(반환 주소)를 푸시하고 피호출자의 첫 번째 명령어로 점프**합니다. **단일 x86-64 명령어인 CALL은 이 두 가지를 모두 수행**합니다.
        - **피호출자가 실행**됩니다.
        - **피호출자가 반환값을 가지고 있으면 레지스터 RAX에 저장**합니다.
        - **피호출자는 스택에서 반환 주소를 꺼내고 x86-64 RET 명령어를 사용하여 지정한 위치로 점프하여 반환**합니다.
    - 세 개의 int 인자를 받는 함수 f()를 생각해 봅시다. 이 다이어그램은 f()가 f(1, 2, 3)으로 호출된다고 가정할 때 위 3단계의 시작 부분에서 피호출자가 볼 수 있는 샘플 스택 프레임과 레지스터 상태를 보여줍니다. 초기 스택 주소는 임의입니다:
        ```C
                                     +----------------+
        stack pointer --> 0x4747fe70 | return address |
                                     +----------------+
        RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003
        ```
3. Program Startup Details
    - 사용자 프로그램용 핀토스 C 라이브러리는 lib/user/entry.c에 있는 _start()를 사용자 프로그램의 진입점으로 지정합니다. 이 함수는 main()을 감싸는 래퍼로, main()이 반환되면 exit()를 호출합니다:
        ```C
        void
        _start (int argc, char *argv[]) {
            exit (main (argc, argv));
        }
        ```
    - **커널은 사용자 프로그램이 실행을 시작하기 전에 초기 함수에 대한 인수를 레지스터에 넣어야 합니다.** **인자는 일반적인 호출 규칙과 동일한 방식으로 전달**됩니다.
    - 다음 예제 명령의 **인수를 처리하는 방법**을 살펴봅니다: **/bin/ls -l foo bar**.
        - **명령을 단어로 나눕니다: /bin/ls, -l, foo, bar**.
        - **스택의 맨 위에 단어를 배치**합니다. **포인터를 통해 참조되므로 순서는 중요하지 않습니다.**
        - **각 문자열의 주소와 널 포인터 센티널을 오른쪽에서 왼쪽 순서로 스택에 밀어 넣습니다.** **이것이 argv의 요소**입니다. **널 포인터 센티널은 C 표준에서 요구하는 대로 argv[argc]가 널 포인터인지 확인**합니다. **이 순서는 argv[0]이 가장 낮은 가상 주소에 있도록 보장**합니다. **단어 정렬 액세스는 정렬되지 않은 액세스보다 빠르므로 최상의 성능을 얻으려면 첫 번째 푸시 전에 스택 포인터를 8의 배수로 반올림**하세요.
        - **%rsi를 argv(argv[0]의 주소)로 가리키고 %rdi를 argc로 설정**합니다.
        - 마지막으로 **가짜 "반환 주소"를 푸시**합니다. **입력 함수는 반환되지 않지만 스택 프레임은 다른 함수와 동일한 구조를 가져야 합니다.**
    - 아래 표는 사용자 프로그램이 시작되기 직전의 스택 상태와 관련 레지스터를 보여줍니다. 스택이 아래로 내려가는 것을 확인할 수 있습니다.
        | Address    | Name           | Data        | Type        |
        |------------|----------------|-------------|-------------|
        | 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
        | 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
        | 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
        | 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
        | 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
        | 0x4747ffe0 | argv[4]        | 0           | char *      |
        | 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
        | 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
        | 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
        | 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
        | 0x4747ffb8 | return address | 0           | void (*) () |
        - RDI: 4 | RSI: 0x4747ffc0
        - 이 예제에서 스택 포인터는 0x4747ffb8로 초기화됩니다. 위와 같이 코드가 include/threads/vaddr.h에 정의된 USER_STACK에서 스택을 시작해야 합니다.
        - **<stdio.h>에 선언된 비표준 hex_dump() 함수는 인자 전달 코드를 디버깅하는 데 유용할 수 있습니다.**<br><br>
4. Implement the argument passing
    - **현재 process_exec()은 새 프로세스에 인수를 전달하는 기능을 지원하지 않습니다.** **이 기능을 구현하려면 process_exec()을 확장하여 단순히 프로그램 파일 이름을 인자로 받는 대신 공백으로 단어로 나누도록 하세요.** 첫 번째 단어는 프로그램 이름, 두 번째 단어는 첫 번째 인수가 되는 식으로 말이죠. **즉, process_exec("grep foo bar")는 두 개의 인자 foo와 bar를 전달하는 grep을 실행**해야 합니다.
    - 명령줄 내에서 여러 개의 공백은 하나의 공백에 해당하므로 process_exec("grep foo bar")는 원래 예제와 동일합니다. 명령줄 인수의 길이에 합리적인 제한을 둘 수 있습니다. 예를 들어 인수를 한 페이지(4KB)에 들어갈 수 있는 길이로 제한할 수 있습니다. (핀토스 유틸리티가 커널에 전달할 수 있는 명령줄 인수는 128바이트로 제한되어 있습니다).
    - 인자 문자열은 원하는 방식으로 구문 분석할 수 있습니다. 길을 잃었다면 include/lib/string.h에 프로토타입이 있고 lib/string.c에 철저한 주석과 함께 구현된 **strtok_r()을 참조**하세요. 자세한 내용은 man 페이지(프롬프트에서 man strtok_r 실행)에서 확인할 수 있습니다.

### 사용자 메모리(User Memory)
1. 사용자 메모리 액세스 구현(Implement user memory access)
    - **시스템 호출을 구현하려면, 사용자 가상 주소 공간에서 데이터를 읽고 쓰는 방법을 제공해야 합니다.** **인수를 받을 때는 이 기능이 필요하지 않습니다.** 그러나 **시스템 호출의 인수로 제공된 포인터에서 데이터를 읽을 때는 이 기능을 통해 프록시해야 합니다.** 사용자가 잘못된 포인터를 제공하거나 커널 메모리에 대한 포인터를 제공하거나 해당 영역 중 하나에 부분적으로 블록을 제공하면 어떻게 될까요? 이러한 경우 사용자 프로세스를 종료하여 처리해야 합니다.

### 시스템 호출(System Calls)
1. 시스템 호출 인프라 구현(Implement system call infrastructure)
    - **userprog/syscall.c에서 시스템 호출 핸들러를 구현**합니다. 우리가 제공하는 스켈레톤 구현은 프로세스를 종료함으로써 시스템 호출을 "처리"합니다. 시스템 호출 번호를 검색한 다음 시스템 호출 인수를 검색하고 적절한 작업을 수행해야 합니다.<br><br>
2. 시스템 호출 세부 정보(System Call Details)
    - 첫 번째 프로젝트에서는 이미 운영 체제가 사용자 프로그램으로부터 제어권을 되찾을 수 있는 한 가지 방법, 즉 타이머와 I/O 디바이스의 인터럽트를 다루었습니다. 이러한 인터럽트는 CPU 외부의 엔티티에 의해 발생하므로 "외부" 인터럽트입니다.
    - 운영체제는 프로그램 코드에서 발생하는 이벤트인 소프트웨어 예외도 처리합니다. 예외는 페이지 오류나 0으로 나눗셈과 같은 오류일 수 있습니다. 예외는 사용자 프로그램이 운영 체제에 서비스를 요청("시스템 호출")할 수 있는 수단이기도 합니다.
    - 기존 x86 아키텍처에서는 시스템 호출이 다른 소프트웨어 예외와 동일하게 처리되었습니다. 그러나 x86-64에서는 제조업체가 시스템 호출에 대한 특수 명령어인 syscall을 도입합니다. 이렇게 하면 시스템 호출 핸들러를 빠르게 호출할 수 있습니다.
    - 오늘날 syscall 명령은 x86-64에서 시스템 호출을 호출하는 데 가장 일반적으로 사용되는 수단입니다. 핀토스에서 사용자 프로그램은 시스템 호출을 위해 syscall을 호출합니다.
    - 시스템 호출 번호와 추가 인수는 두 점을 제외하고는 시스템 호출 명령을 호출하기 전에 일반적인 방식으로 레지스터에 설정되어야 합니다:
        - %rax는 시스템 호출 번호입니다.
        - 네 번째 인수는 %rcx가 아닌 %r10입니다.
    - 따라서, 시스템 호출 핸들러 syscall_handler()가 제어권을 얻으면 시스템 호출 번호는 rax에 있고 인수는 %rdi, %rsi, %rdx, %r10, %r8, %r9의 순서로 전달됩니다.
    - 호출자의 레지스터는 전달된 구조체 intr_frame에 액세스할 수 있습니다. (구조체 intr_frame은 커널 스택에 있습니다.)
    - 함수 반환 값에 대한 x86-64 규칙은 이 값을 RAX 레지스터에 배치하는 것입니다.
    - 시스템 호출은 구조체 intr_frame의 rax 멤버를 수정하여 값을 반환할 수 있습니다.<br><br>
3. 시스템 호출 구현(Implement the following system calls)
    - 나열된 프로토타입은 include/lib/user/syscall.h를 포함하는 사용자 프로그램에서 볼 수 있는 것입니다(이 헤더와 include/lib/user의 다른 모든 헤더는 사용자 프로그램에서만 사용할 수 있습니다). 각 시스템 호출에 대한 시스템 호출 번호는 include/lib/syscall-nr.h에 정의되어 있습니다:
        ```C
        void halt (void);
        ```
        - (src/include/threads/init.h에 선언된) power_off()를 호출하여 핀토스를 종료합니다. 교착 상태에 빠질 수 있는 상황 등에 대한 일부 정보를 잃게 되므로 거의 사용하지 않는 것이 좋습니다.
        ```C
        void exit (int status);
        ```
        - 현재 사용자 프로그램을 종료하여 상태를 커널로 되돌립니다. 프로세스의 부모가 wait하는 경우(아래 참조), 반환되는 status는 이 상태입니다. 일반적으로 0 status는 성공을 나타내고 0이 아닌 값은 오류를 나타냅니다.
        ```C
        pid_t fork (const char *thread_name);
        ```
        - 현재 프로세스의 복제본인 새 프로세스를 THREAD_NAME이라는 이름으로 생성합니다. callee-saved registers인 %RBX, %RSP, %RBP 및 %R12 - %R15를 제외한 레지스터의 값을 복제할 필요가 없습니다. 자식 프로세스의 pid를 반환해야 합니다. 그렇지 않으면 올바른 pid가 될 수 없습니다. 하위 프로세스에서 반환 값은 0이어야 합니다. 자식은 파일 디스크립터 및 가상 메모리 공간을 포함하여 복제된 리소스를 가지고 있어야 합니다. 부모 프로세스는 자식 프로세스가 성공적으로 복제되었는지 여부를 알기 전까지는 fork에서 복귀해서는 안 됩니다. 즉, 자식 프로세스가 리소스를 복제하는 데 실패하면 부모의 fork() 호출은 TID_ERROR를 반환해야 합니다.
        - 템플릿은 threads/mmu.c의 pml4_for_each()를 사용하여 해당 페이지 테이블 구조를 포함한 전체 사용자 메모리 공간을 복사하지만, 전달된 pte_for_each_func의 누락된 부분을 채워야 합니다. virtual address(https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html)참조.
        ```C
        int exec (const char *cmd_line);
        ```
        - 현재 프로세스를 cmd_line에서 지정된 실행 파일로 변경하고 지정된 인수를 전달합니다. 성공하면 반환되지 않습니다. 그렇지 않으면, 어떤 이유로든 프로그램을 로드하거나 실행할 수 없는 경우 프로세스가 종료 상태 -1로 종료됩니다. 이 함수는 exec를 호출한 스레드의 이름을 변경하지 않습니다. 파일 디스크립터는 exec 호출 내내 열려 있는 상태로 유지된다는 점에 유의하세요.
        ```C
        int wait (pid_t pid);
        ```
        - 자식 프로세스 pid를 기다렸다가 자식의 종료 상태를 검색합니다. pid가 아직 살아있으면 종료될 때까지 기다립니다. 그런 다음 종료하기 위해 전달한 pid의 상태를 반환합니다. pid가 exit()를 호출하지 않았지만 커널에 의해 종료된 경우(예: 예외로 인해 종료된 경우) wait(pid)는 -1을 반환해야 합니다. 부모 프로세스가 호출한 wait에 의해 이미 종료된 자식 프로세스를 부모 프로세스가 기다리는 것은 합법적이지만, 커널은 여전히 부모가 자식의 종료 상태를 검색하거나 자식이 커널에 의해 종료되었다는 사실을 알 수 있도록 허용해야 합니다.
        - wait는 다음 조건 중 하나라도 참이면 실패하고 즉시 -1을 반환해야 합니다:
            - pid는 호출 프로세스의 직접 자식을 참조하지 않습니다. pid가 호출 프로세스의 직접 자식이라면, 호출 프로세스가 성공적인 fork 호출의 반환 값으로 pid를 받습니다. 자녀는 상속되지 않는다는 점에 유의하세요: A가 자식 프로세스 B를 스폰하고 B가 자식 프로세스 C를 스폰하는 경우, A는 B가 죽었더라도 C를 기다릴 수 없습니다. 프로세스 A에 의한 wait(C) 호출이 실패해야 합니다. 마찬가지로 고아 프로세스는 부모 프로세스가 종료되기 전에 종료되는 경우 새 부모에 할당되지 않습니다.
            - wait을 호출하는 프로세스는 이미 pid에서 wait을 호출했습니다. 즉, 프로세스는 최대 한 번만 주어진 자식을 wait할 수 있습니다.
    - 프로세스는 자식을 얼마든지 생성할 수 있고, 어떤 순서로든 자식을 wait할 수 있으며, 심지어 일부 또는 모든 자식을 기다리지 않고 종료할 수도 있습니다. 설계에서는 대기 시간이 발생할 수 있는 모든 방법을 고려해야 합니다. struct thread를 포함한 프로세스의 모든 리소스는 부모가 기다리든 기다리지 않든, 자식이 부모보다 먼저 종료하든 나중에 종료하든 관계없이 해제되어야 합니다.
    - 초기 프로세스가 종료될 때까지 핀토스가 종료되지 않도록 해야 합니다. 제공된 핀토스 코드는 main()(threads/init.c)에서 process_wait()(userprog/process.c)를 호출하여 이 작업을 시도합니다. 함수 상단의 주석에 따라 process_wait()를 구현한 다음 process_wait()의 관점에서 대기 시스템 호출을 구현하는 것이 좋습니다.
    - 이 시스템 호출을 구현하려면 다른 어떤 것보다 훨씬 더 많은 작업이 필요합니다.
        ```C
        bool create (const char *file, unsigned initial_size);
        ```
        - initial_size bytes 크기로 초기화된 file이라는 새 파일을 생성한다. 성공하면 참을 반환하고, 그렇지 않으면 거짓을 반환합니다. 새 파일을 생성해도 파일이 열리지 않습니다: 새 파일을 여는 것은 open 시스템 호출이라는 별도의 작업이 필요합니다.
        ```C
        bool remove (const char *file);
        ```
        - file이라는 파일을 삭제합니다. 성공하면 참을 반환하고, 그렇지 않으면 거짓을 반환합니다. 파일은 열려 있는지 여부와 관계없이 제거할 수 있으며 열려 있는 파일을 제거해도 파일이 닫히지 않습니다. 자세한 내용은 FAQ(https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html)에서 Removing an Open File을 참조하세요.
        ```C
        int open (const char *file);
        ```
        - file이라는 파일을 엽니다. '파일 디스크립터'(fd)라는 음수가 아닌 정수 handle을 반환하거나 파일을 열 수 없는 경우 -1을 반환합니다. 0과 1로 번호가 매겨진 파일 디스크립터는 콘솔용으로 예약되어 있습니다: fd 0(STDIN_FILENO)은 표준 입력, fd 1(STDOUT_FILENO)은 표준 출력입니다. open 시스템 호출은 이러한 파일 디스크립터를 반환하지 않으며, 이들은 아래에 명시적으로 설명된 시스템 호출 인수로만 유효합니다. 각 프로세스에는 독립적인 파일 디스크립터 집합이 있습니다. 파일 디스크립터는 하위 프로세스에 의해 상속됩니다. 단일 프로세스에서든 다른 프로세스에서든 단일 파일을 두 번 이상 열면 열 때마다 새 파일 디스크립터가 반환됩니다. 단일 파일에 대한 서로 다른 파일 디스크립터는 별도의 close 호출을 통해 독립적으로 닫히며 파일 위치를 공유하지 않습니다. 추가 작업을 수행하려면 0부터 시작하는 정수를 반환하는 리눅스 스키마를 따라야 합니다.
        ```C
        int filesize (int fd);
        ```
        - fd로 열린 파일의 크기(바이트)를 반환합니다.
        ```C
        int read (int fd, void *buffer, unsigned size);
        ```
        - fd로 열린 파일에서 buffer로 size 바이트를 읽습니다. 실제로 읽은 바이트 수(파일 끝에서 0)를 반환하거나, 파일 끝이 아닌 다른 조건으로 인해 파일을 읽을 수 없는 경우 -1을 반환합니다. fd 0은 input_getc()를 사용하여 키보드에서 읽습니다.
        ```C
        int write (int fd, const void *buffer, unsigned size);
        ```
        - buffer에서 열린 파일 fd에 size 바이트를 씁니다. 실제로 기록된 바이트 수를 반환하며, 일부 바이트가 기록되지 않은 경우 size보다 작을 수 있습니다. 파일 끝을 지나서 쓰면 일반적으로 파일이 확장되지만 기본 파일 시스템에서는 파일 증가를 구현하지 않습니다. 예상되는 동작은 파일 끝 부분까지 가능한 한 많은 바이트를 쓰고 실제로 쓰여진 수를 반환하거나, 바이트가 전혀 쓰여지지 않으면 0을 반환하는 것입니다. fd 1은 콘솔에 씁니다. 콘솔에 쓰는 코드는 적어도 크기가 수백 바이트보다 크지 않은 한 putbuf() 호출 한 번으로 모든 버퍼를 써야 합니다(큰 버퍼는 분할하는 것이 합리적입니다). 그렇지 않으면, 서로 다른 프로세스에서 출력된 텍스트 줄이 콘솔에 끼어들어 채점 스크립트를 읽는 사람과 채점 스크립트 모두를 혼란스럽게 만들 수 있습니다.
        ```C
        void seek (int fd, unsigned position);
        ```
        - 열린 파일 fd에서 읽거나 쓸 다음 바이트를 파일 시작부터 바이트 단위로 표시되는 position으로 변경합니다(따라서 position이 0이면 파일의 시작입니다). 파일의 현재 끝을 지나서 찾는 것은 오류가 아닙니다. 나중에 read하면 파일 끝을 나타내는 0바이트를 얻습니다. 나중에 write하면 파일이 확장되어 기록되지 않은 공백이 0으로 채워집니다.(단, 핀토스에서는 프로젝트 4가 완료될 때까지 파일 길이가 고정되어 있으므로 파일 끝을 지나서 write하면 오류가 반환됩니다.) 이러한 시맨틱은 파일 시스템에서 구현되며, 시스템 호출 구현에 특별한 노력이 필요하지 않습니다.
        ```C
        unsigned tell (int fd);
        ```
        - 열린 파일 fd에서 읽거나 쓸 다음 바이트의 위치를 파일 시작부터 바이트 단위로 반환합니다.
        ```C
        void close (int fd);
        ```
        - 파일 디스크립터 fd를 닫습니다. 프로세스를 종료하거나 종료하면 마치 각 파일에 대해 이 함수를 호출하는 것처럼 열려 있는 모든 파일 디스크립터가 암시적으로 닫힙니다.
    - 이 파일은 다른 시스템 호출을 정의합니다. 지금은 그들을 무시하세요. 일부는 프로젝트 3에서 구현하고 나머지는 프로젝트 4에서 구현하므로 확장성을 염두에 두고 시스템을 설계해야 합니다.
    - 시스템 호출을 동기화하여 여러 사용자 프로세스가 동시에 호출할 수 있도록 해야 합니다. 특히 filesys 디렉토리에 제공된 파일 시스템 코드를 여러 스레드에서 한 번에 호출하는 것은 안전하지 않습니다. 시스템 호출 구현에서는 파일 시스템 코드를 중요 섹션으로 취급해야 합니다. process_exec()도 파일에 액세스한다는 사실을 잊지 마세요. 현재로서는 filesys 디렉토리의 코드를 수정하지 않는 것이 좋습니다.
    - 각 시스템 호출에 대한 사용자 수준 함수를 lib/user/syscall.c에 제공했습니다. 이는 사용자 프로세스가 C 프로그램에서 각 시스템 호출을 호출하는 방법을 제공합니다. 각각은 약간의 인라인 어셈블리 코드를 사용하여 시스템 호출을 호출하고 (적절한 경우) 시스템 호출의 반환값을 반환합니다.
    - 이 부분을 끝내고 나면, 영원히 핀토스는 완벽해야 합니다. 사용자 프로그램으로 인해 OS가 충돌, 패닉, 어설션 실패 또는 기타 오작동을 일으켜서는 안 됩니다. 이 점을 강조하는 것이 중요합니다: 테스트는 여러 가지 방법으로 시스템 호출을 중단하려고 시도합니다. 모든 코너 케이스를 생각하고 처리해야 합니다. 사용자 프로그램이 OS를 중지시킬 수 있는 유일한 방법은 중지 시스템 호출을 호출하는 것입니다.
    - 시스템 호출에 잘못된 인수가 전달되면 오류 값 반환(값을 반환하는 호출의 경우), 정의되지 않은 값 반환 또는 프로세스 종료가 허용됩니다.

### 프로세스 종료 메시지(Process Termination Messages)
1. 프로세스 종료 메시지 인쇄(Print out the process termination message)
    - 사용자 프로세스가 exit 호출 또는 기타 이유로 종료될 때마다 프로세스의 이름과 종료 코드를 다음과 같은 형식으로 인쇄합니다.
        ```C
        printf ("%s: exit(%d)\n", ...);
        ```
    - 인쇄되는 이름은 fork()에 전달된 전체 이름이어야 합니다. 사용자 프로세스가 아닌 커널 스레드가 종료되거나 중단 시스템 호출이 호출될 때는 이러한 메시지를 인쇄하지 마세요. 프로세스가 로드되지 않을 경우 메시지는 선택 사항입니다.
    - 이 메시지 외에 제공된 핀토스가 이미 인쇄하지 않는 다른 메시지는 인쇄하지 마세요. 디버깅 중에 추가 메시지가 유용할 수 있지만 채점 스크립트를 혼동하여 점수가 낮아질 수 있습니다. 

### 실행 파일에 대한 쓰기 거부(Denying Writes to Executables)
1. 실행 파일에 대한 쓰기 거부(Deny write on executables)
    - 실행 파일로 사용 중인 파일에 대한 쓰기를 거부하는 코드를 추가하세요. 프로세스가 디스크에서 변경 중인 코드를 실행하려고 할 때 예측할 수 없는 결과가 발생할 수 있기 때문에 많은 OS에서 이 기능을 사용합니다. 이는 프로젝트 3에서 가상 메모리를 구현한 후에 특히 중요하지만, 지금이라도 이 기능을 추가하는 것이 좋습니다.
    - 열린 파일에 대한 쓰기를 방지하기 위해 file_deny_write()를 사용할 수 있습니다. 파일에 대해 file_allow_write()를 호출하면 다시 사용할 수 있습니다(다른 오프너에서 파일 쓰기를 거부하지 않는 한). 파일을 닫으면 쓰기 기능도 다시 활성화됩니다. 따라서 프로세스의 실행 파일에 대한 쓰기를 거부하려면 프로세스가 계속 실행되는 동안 파일을 열어 두어야 합니다.

## 2. PROJECT2(USER PROGRAMS) 개념 학습
### Caller & Callee
1. Caller
    - 호출자 / 함수를 호출한 대상
    - main() 함수에서 func()이 호출되는 경우 main() 함수에 해당<br><br>
2. Callee
    - 피호출자 / 호출을 당한 함수
    - main() 함수에서 func()이 호출되는 경우 func() 함수에 해당<br><br>
3. Caller-saved-register(콜러가 저장하는 레지스터)
    - main() 함수는 실행하면서 레지스터를 사용한다. func() 함수가 return되면, 다시 func() 함수가 호출되기 전 레지스터의 값을 가지고 있어야 한다. 이 때, caller가 저장하고 보존되도록 신경써야 하는 레지스터(callee는 이 레지스터를 자유롭게 사용 가능)이다.
    - 사용하기 전 caller가 반드시 백업해야 하는 레지스터이다.
    - callee가 사용 가능하다.
    - 값이 보존되지 않아도 되는 경우에는 백업을 하지 않을 수 있다.
    - 레지스터 종류
        - EAX(Extended Accumulator Register) : 논리 연산
        - ECX(Extended Counter Register) : 카운터 레지스터로, 반복 명령어 사용시 반복 카운터로 사용한다.
        - EDX(Extended Data Register) : EAX와 같이 연산에 쓰이며, 부호 확장 명령 등에 쓰인다.<br><br>
4. Callee-saved-register(콜리가 저장하는 레지스터)
    - 사용하기 전 callee가 반드시 백업해야 하는 레지스터이다.
    - caller가 사용 가능하다.
    - 함수 복귀 전 다시 값을 복원해야 한다.
    - callee 입장에서는 caller가 백업을 필요로하는 레지스터가 무엇인지 모르기 때문에 무조건 백업해야 한다.
    - 레지스터 종류
        - EBX(Extended Base address Register) : 메모리 주소 저장을 위한 레지스터로, ESI나 EDI와 결합하여 사용 가능하다.
        - ESI(Extended Source Index) : 데이터 조작 및 복사시 소스 데이터의 주소가 저장된다.
        - EDI(Extended Destination Index) : 복사 시 목적지의 주소가 저장되며, ESI 레지스터와 비슷하다.
        - EBP(Extended Base Pointer) : 스택 프레임의 시작 지점 주소(스택의 가장 윗 부분, 스택의 처음)가 저장되며, 현재 스택 프레임이 소멸되지 않는 이상 EBP 레지스터의 값은 변하지 않는다.

### 스택 프레임(Stack Frame)
1. 스택 프레임이란?
    - 함수의 호출 과정에서 호출되는 함수를 사용하기 위해 할당되는 스택의 공간을 의미한다.
    - 스택 영역의 함수를 구분하기 위해 생성되는 공간으로서 매개변수(parameter), 복귀할 명령어의 주소(return address), 지역변수(local variables), 이전 스택 프레임의 EBP값 등을 포함하고 있다.
    - 함수 호출 시 함수의 프롤로그(prolog) 과정을 통해 생성되고, 함수의 에필로그(epilog) 과정을 통해 함수가 종료되면서 소멸된다.<br><br>
2. gdb를 통해 함수 호출 실행 과정
    - 예를 들어, 아래와 같은 코드가 있다고 가정하자.
        ```C
        #include <stdio.h>
 
        void sum(int a, int b) {
            printf("sum : %d\n", a+b);
        }
        
        int main() {
            int num1, num2 ; 

            scanf("%d %d", &num1, &num2);   
            sum(num1, num2);
            
            return 0;
        }
        ```
        - 단순히 두 개의 정수 값을 입력 받아 sum 함수를 호출하여 입력받은 두 정수의 합을 구하는 프로그램이다.
    - gdb를 통해 main() 함수를 살펴보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbQcZHH%2Fbtrrum3xGML%2FYH9CaZcMK76PH5Ky8zfdxK%2Fimg.png" height="300"></img>
        - main() 함수를 확인해보면, 위와 같이 sum 함수를 호출하는 부분을 찾을 수 있을 것이다.
        - 함수를 호출할 때는 call instruction을 수행한다.
            ```
            call instruction
            - push eip
            - jmp 함수의 주소
            ```
    - sum 함수가 호출되기 전에 break를 걸고 실행하여 위에서 설명한 방식대로 동작하는지 확인해보자.  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9hvca%2Fbtrro6OcrEB%2FZoG2F1PPKR91Gp3xttsgj0%2Fimg.png" height="390"></img>
        - si 명령을 통한 sum() 함수 내부로 들어간 상태이다.  
            <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4ZNeX%2FbtrrpnbyWsX%2FekcwGqxuwK9cp3DeKte1sk%2Fimg.png" height="80"></img>
            - esp를 확인해보면, 0x080484af(call 0x804846b의 다음 instruction) 주소가 스택에 push되어 있는 것을 확인 할 수 있다.
            - return address(0x80484af) 오른쪽을 보면 3, 5가 들어가 있으며, 이는 parameter 값이다.<br><br>
3. 함수의 프롤로그(Prolog)
    - 함수의 프롤로그는 함수 실행 준비과정으로, 자신이 이제 시작할거라고 알리는 과정이다.(=스택 프레임 형성)
    - 함수의 프롤로그 instruction  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUr5fN%2FbtrrunuC6ol%2FxJkSOByD4e852kxCzzuwb1%2Fimg.png" height="200"></img>
        - push ebp
            - EBP(base pointer) : 스택 상의 한 데이터의 주소가 저장되어 있는 레지스터로, 그 데이터 위부터 한 함수가 실행된 이후의 값들이 쌓인다.
                - 즉, 그 함수의 시작 지점이며, 함수가 종료되지 않는 한 EBP 값은 변하지 않는다.
            - push ebp : 함수가 종료된 후 ebp를 이전 함수의 ebp로 재설정하기 위해 스택에 이전 함수의 ebp를 push 한다.  
                <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbbCJn%2FbtrrpT9dO9x%2FyGss7ekw5lFOnz75zB3RDk%2Fimg.png" height="300"></img>
                - push ebp가 수행된 다음 스택의 상태를 살펴보면, 0xbfffefe8(main() 함수의 ebp)이 push되어 있는 것을 확인 할 수 있다.
        - mov ebp, esp
            - ESP(stack pointer) : 스택의 맨 꼭대기의 주소가 저장되어 있는 레지스터로, ESP 값에서 push 또는 pop이 일어난다.
            - mov ebp, esp : 호출된 함수의 시작을 알리기 위해 현재 esp 값을 ebp에 복사한다.  
                <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqCyVF%2FbtrrxXhUdxd%2FUzEsdUCVGudpC9pdTVk0w1%2Fimg.png" height="120"></img>
                - mov ebp, esp가 수행된 다음 스택의 상태를 살펴보면, esp가 가리키는 주소 값을 ebp에 복사함으로써 함수가 시작될 때 stack pointer와 base pointer가 새로 지정된 것을 확인할 수 있다.<br><br>
4. 함수의 에필로그(Epilog)
    - 함수의 에필로그는 함수 내에서의 수행을 마치고 처음 호출한 지점으로 돌아가기 위해 스택을 복원하는 과정이다.(=스택 프레임 소멸)
    - 함수의 에필로그 instruction  
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Flbnyv%2Fbtrrwec9g2h%2FCMDwvxkT6rdrvwkp0mnc91%2Fimg.png" height="200"></img>
        - leave instruction
            ```
            - mov esp, ebp
            - pop ebp
            ```
            - mov esp, ebp : esp에 ebp 값을 복사해줌으로써 함수를 종료해주고(함수를 호출하면서 확장했던 스택 공간 소멸)
            - pop ebp : 현재 esp 값이 가리키고 있는 sfp를 pop하여 ebp에 넣어줌으로써 이전 함수로 돌아가게(main() 함수의 ebp를 복원) 된다.
            - 함수가 종료되면, ebp를 이전 함수의 ebp로 재설정해주는 과정으로 프롤로그와 반대로 진행한다.
        - ret instruction
            ```
            - pop eip
            - jmp eip
            ```
            - EIP : CPU가 다음에 실행해야 할 명령어의 주소가 저장되어 있는 레지스터이다.
            - pop eip : 스택에 미리 저장해놓았던 return address(함수 종료 후 돌아갈 주소)를 eip에 넣어준다.
            - jmp eip : 넣어준 그 주소로 이동해주어 함수를 호출한 후의 명령을 계속 수행할 수 있도록 해준다.

### 함수 호출 규약(Calling Convention)
1. 함수 호출 규약이란?
    - 컴퓨터에서 함수를 호출하고, 함수를 구현하기 위해서 정한 표준 규약이다.
    - 함수 호츌 규약을 통해 컴파일러가 어떻게 서브루틴(호출된 함수)에 접근할지를 정한다.
    - 기본적으로 함수에 전달되는 인자를 어떻게 다룰지, 함수의 리턴 값을 어떻게 다룰지, 함수의 스택과 스택 프레임을 어떻게 관리할지를 정한다.
    - 함수 호출 규약은 C/C++에서 작성된 함수들이 어셈블리 언어로 변결될 때 사용된다.
    - C 언어에서 32bit x86 시스템의 함수 호출 규약은 STDCALL, CDECL, FASTCALL이 있으며, 64bit x64 시스템에는 FASTCALL이 있다.<br><br>
2. 32bit x86 함수 호출 규약
    - CDECL
        - C 언어에서 일반적으로 사용되는 함수 호출 규약으로, 리턴값은 EAX에 저장
        - 인자 전달 순서 : 가장 오른쪽 인자 -> 가장 왼쪽 인자 순서로 전달
        - 인자 전달 방법 : 스택 메모리를 사용
        - 스택 프레임 정리 : Caller가 스택 프레임을 정리
        - 가변 인자 함수 사용여부 : 사용 가능
            - 가변 인자 : printf 처럼 매개변수의 개수가 정해지지 않는 함수
    - STDCALL
        - WINAPI에서 일반적으로 사용되는 함수 호출 규약으로, 리턴값은 EAX에 저장
        - 인자 전달 순서 : 가장 오른쪽 인자 -> 가장 왼쪽 인자 순서로 전달
        - 인자 전달 방법 : 스택 메모리를 이용
        - 스택 프레임 정리 : Callee가 스택 프레임을 정리
        - 가변 인자 함수 사용여부 : 사용 불가능
            - callee가 스택프레임을 정리하면서 전달된 매개변수의 크기만큼 esp의 값을 더해야 하는데 callee는 전달된 매개변수의 크기를 알 수 없기 때문에 가변인자를 사용하는 것이 불가능
    - FASTCALL
        - 파라미터가 레지스터를 이용해서 전달되기 때문에 속도가 빠르다는 특징 이외에는 STDCALL의 특징과 동일
        - 인자 전달 순서 : 가장 오른쪽 인자 -> 가장 왼쪽 인자 순서로 전달
        - 인자 전달 방법 : EDX, ECX 레지스터를 이용하며 3개의 매개변수부터는 스택을 사용
        - 스택 프레임 정리 : Callee가 스택 프레임을 정리
        - 가변 인자 함수 사용여부 : 사용 불가능<br><br>
3. 64bit x64 함수 호출 규약
    - FASTCALL
        - 리눅스에서 파라미터 전달 방법
            - 정수 : RDI, RSI, RDX, RCX, R8, R9 레지스터를 이용하여 파라미터 전달
            - 실수 : XMM0부터 XMM7 레지스터를 이용하여 파라미터 전달
        - 윈도우에서 파라미터 전달 방법
            - 정수 : RCX, RDX, R8, R9 레지스터를 이용하여 파라미터 전달
            - 실수 : XMM0부터 XMM3 레지스터를 이용하여 파라미터 전달
        - 반환값
            - 정수 : RAX(하위 64비트), RDX(상위 64비트) 레지스터를 사용
            - 실수 : XMM0(하위 128비트), XMM1(상위 128비트) 레지스터를 사용

### 파일 디스크립터(FD, File Descriptor)
1. 파일 디스크립터란?
    - Unix OS에서 네트워크 소켓과 같은 파일이나 기타 입력/출력 리소스에 액세스하는 데 사용되는 추상표현이다.
    - 즉, 시스템으로부터 할당 받은 파일이나 소켓을 대표하는 음이 아닌 정수(Non-negative Integer)이다.
    - 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스이다.<br><br>
2. 유닉스 시스템에서의 파일 디스크립터
    - 유닉스 시스템에서 모든 것을 파일이라고 한다.
    - 일반적인 정규파일(regular File)에서부터 디렉토리, 소켓, 파이프, 블록 디바이스, 캐릭터 디바이스 등등 모든 객체들은 파일로써 관리된다.
    - 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터를 이용한다.<br><br>
3. 응용 프로세스에서의 파일 디스크립터
    - 응용 프로세스가 파일을 열거나 생성하면 정수로 된 파일 디스크립터를 얻게 되는데, 이 파일 디스크립터는 이후에 일어나는 모든 파일 동작 즉, 읽기(read()), 쓰기(write()), 파일 동작제어(fcntl()), 파일 닫기(close()) 등의 동작에서 그 파일을 가리키는데 사용된다.<br><br>
4. 기본적으로 할당되는 파일 디스크립터(unistd.h 헤더파일에 명시)
    - 표준 입력(Standard Input) : STDIN_FILENO / 0
    - 표준 출력(Standard Output) : STDOUT_FILENO / 1
    - 표준 에러(Standard Error) : STDERR_FILENO / 2
    - 즉, 파일 오픈 or 소켓생성 시 부여되는 파일 디스크립터는 3번부터 차례대로 할당받게 된다.<br><br>
5. 파일 디스크립터 확인
    - 파일 디스크립터를 확인하기 전에 필요한 함수를 확인해보자.
        ```C
        open(pathname, flags, mode) //return fd
        ```
        - open 함수는 pathname이 가리키는 파일을 열고 열린 파일을 이후 호출에서 참조할 때 사용하는 파일 디스크립터(사용하지 않는 가장 작은 값)를 리턴한다.
    - 파일 디스크립터 확인해보자
        - file.c 파일과 test.txt 파일을 생성한 후 프로세스가 파일을 열 때 얻는 파일 디스크립터를 출력해보자.
            ```C
            #include <stdio.h>
            #include <stdlib.h>
            #include <fcntl.h>
            #include <unistd.h>

            int main(void)
            {
                int fd;

                fd = open("test.txt", O_RDONLY);
                if (fd < 1)
                {
                    printf("open() error");
                    exit(1);
                }
                printf("FD : %d\n", fd);
                close(fd);
                return (0);
            }
            ```
        - 실행 결과
            ```
            >>> ./file
            >>> FD : 3
            ```
            - file.c 파일을 컴파일 한 후 실행해보니 파일 디스크립터가 3부터 부여되는 것을 확인할 수 있다.
            - 여기서 숫자 3은 어떤 의미일까?
                - 파일 디스크립터 값, 즉 FD는 프로세스가 유지하고 있는 FD Table의 Index이다.
                - 위의 예제에서 우리는 3이라는 파일 디스크립트 값을 받았고, 이 숫자 3을 이용해서 FD Table의 3번째 인덱스로 접근하여 해당 칸이 가리키는 파일로 가서 원하는 동작을 할 수 있는 것이다.
            - 각 Table 구성 요소
                - FD Table : 각 칸들은 FD Flag와 File Table Pointer를 가지고 있다.
                - File Table : 각 칸들은 mode와 inode Table Pointer의 Offset을 가지고 있다.
                - node Table : 소유자 그룹, 접근 모드(읽기, 쓰기, 실행 권한), 파일 형태, 아이노드 숫자(inode number, i-number) 등 해당 파일에 관한 정보를 가지고 있다.
                    - inode란?
                        - 파일을 기술하는 디스크 상의 데이터 구조로서 파일의 데이터 블록이 디스크 상의 어느 주소에 위치하고 있는가와 같은 파일에 대한 중요한 정보를 갖고 있다.
                        - 각각의 inode들은 고유번호(inode number)를 가지고 있어서 파일을 식별할때 사용한다.
                        - 터미널에서 ls -i 옵션으로 inode number를 확인할 수 있다.<br><br>
6. 기존 파일 디스크립터 복제
    - 파일 디스크립터 복제 코드
        ```C
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <unistd.h>

        int main(void)
        {
            int fd;
            int fd2;

            fd = open("test.txt", O_RDONLY);
            fd2 = open("test.txt", O_RDONLY);
            if (fd < 1 || fd2 < 1)
            {
                printf("open() error");
                exit(1);
            }
            printf("fd\t: %d\n", fd);
            printf("fd2\t: %d\n", fd2);

            printf("fd2 = dup(fd)\n");
            fd2 = dup(fd);

            printf("fd\t: %d\n", fd);
            printf("fd2\t: %d\n", fd2);

            close(fd);
            close(fd2);
            return (0);
        }
        ```
    - 실행 결과
        ```
        >>> ./file
        >>> fd  : 3
        >>> fd2 : 4
        >>> fd2 = dup(fd)
        >>> fd  : 3
        >>> fd2 : 5
        ```
        - 기존 fd는 3을, fd2는 4를 할당받았다.
        - 이후 dup()함수를 활용해서 fd를 복사해서 fd2에 넣었더니 fd2가 5가 되었다.
        - 이것은 3이 이미 사용중인 파일 디스크럽터이고, 4도 지금 현재 fd2에서 사용중이므로 5번이 새로 할당된 것이다.
        - 즉, dup()를 통해서 복제를 하면 새로운 파일 디스크립터를 생성한다고 생각하면 된다.

### User mode & Kernel mode
1. 커널(kenel)이란?
    - 컴퓨터 과학에서 커널은 운영체제의 핵심 부분으로서, 운영체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가지 서비스를 제공한다.(=마치 사람의 심장, 혹은 자동차의 엔진과도 같은 존재)
    - 보안, 자원관리, 추상화 역할을 수행한다.
    - 컴퓨터의 자원은 CPU, 메모리, 가상메모리, 키보드, 마우스 등과 추상적으로는 스레드, 패킷, 프로토콜, 테스크를 의미한다.
    - 커널은 이러한 자원을 효율적으로 관리하기 위해 CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등의 업무를 수행한다.<br><br>
2. 디바이스 드라이버(device driver)란?
    - 특정 하드웨어난 장치를 제어하기 위한 커널의 일부분으로 동작하는 프로그램이다.
    - 컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치 드라이버가 프로그램 커널에 통합되어 실행된다.
    - 쉽게 이야기 하면, 우리가 쓰는 모든 입출력 장치(키보드, 모니터, 마우스, 복합기 등)와 컴퓨터(OS)가 서로 알아들을 수 있게 통역해주는 역할을 수행한다.
    - 어렵게 이야기 하면, 컴퓨터의 버스나 통신 시스템을 이용하여 하드웨어와 커널 사이에서 명령어나 데이터를 전달해주는 역할을 수행한다.<br><br>
3. 유저 모드와 커널 모드의 필요성
    - 운영체제에서는 커널 모드와 유저 모드 두가지 프로세서 접근모드를 지원한다.
    - 그 이유는 유저 어플리케이션이 함부로 운영체제의 치명적인 데이터를 수정하거나 삭제하지 못하게 하기 위함이다.<br><br>
4. 유저 모드와 커널 모드(슈퍼바이저 모드)
    - 유저 모드
        - 운영체제 서비스를 제공받을 수 없는 실행 모드입니다.
        - 즉, 커널 영역의 코드를 실행할 수 없는 모드입니다.
        - 일반적인 응용 프로그램은 기본적으로 유저 모드로 실행됩니다.
        - 유저 모드로 실행 중인 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근하는 명령어를 실행할 수 없습니다.
        - 그래서 유저 모드로 실행되는 일반적인 응용 프로그램은 자원에 접근할 수 없습니다.
    - 커널 모드
        - 운영체제 서비스를 제공받을 수 있는 실행 모드입니다.
        - 즉, 커널 영역의 코드를 실행할 수 있는 모드입니다.
        - CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있습니다.
        - 운영체제는 커널 모드로 실행되기 때문에 자원에 접근할 수 있습니다.<br><br>
5. 하드웨어적으로 유저 모드와 커널 모드의 구분 방법
    - 커널 모드와 유저 모드를 구분하기 위해 하드웨어적으로 CPU 내부에 일부 제어 레지스터인 모드 비트(mode bit)를 제공한다.
    - 모드 비트가 0(유저 모드로 실행 중)으로 세팅되어 있으면 커널 모드로서 모든 명령을 수행할 수 있고, 모드 비트가 1(커널 모드로 실행 중)로 세팅되어 있으면 유저 모드로서 제한된 명령만을 수행할 수 있습니다.
    - 따라서, CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드 비트는 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행하게 됩니다.<br><br>
6. 유저 모드와 커널 모드의 전환
    - 프로세스가 실행되는 동안 프로세스는 수없이 유저 모드와 커널 모드를 반복하면서 실행된다.
    - 유저 모드 -> 커널 모드
        - 프로세스가 유저모드에서 실행되다가 특별한 요청이 필요할 때 시스템 콜을 이용해서 커널에 요청한다.
    - 커널 모드 -> 유저 모드
        - 시스템 콜의 요청을 받아 커널이 그 요청에 대한 작업을 수행하고 결과값을 시스템 콜의 리턴 값으로 전송한다.
    - 예를 들어, 프로세스가 유저 모드에서 작업을 수행하다 하드웨어 접근 등 보안에 필요한 중요한 명령을 수행해야 할 경우가 발생했다고 가정하자.
        - 유저 모드가 시스템 콜(소프트웨어 인터럽트)을 통해 운영체제에게 서비스를 대신해 줄 것을 요청하게 됩니다.
        - 그러면 유저 모드는 CPU의 제어권을 운영체제로 넘기고, 커널 모드는 프로그램의 현재 CPU 상태를 저장한다.
        - 인터럽트가 발생할 때에는 모드 비트가 자동적으로 0으로 세팅되어 필요한 작업을 수행한다.
        - 요청된 작업이 끝나게 되면 시스템 콜의 리턴 값을 유저 모드에 전송하고, 모드 비트는 다시 1로 만들어 사용자 프로그램에게 CPU를 넘겨주면서 CPU 상태를 다시 복원한다.
        - 유저 모드에서는 중단되었던 프로그램이 이어서 실행된다.

### CPU Protection Rings  
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSSKMM%2Fbtq2ryI2UYz%2FgfUf546cBogDd2wDK3MYNK%2Fimg.png" height="250"></img>
1. CPU도 권한 모드라는 것을 가지고 있다. 
    - 대표적으로 유저 모드와 커널 모드가 있다.
    - 대부분의 운영체제는 ring0과 ring3을 사용한다.
    - ring3을 유저 모드라고 지칭하고, ring0을 커널 모드라고 지칭한다.

### Interrupt(인터럽트)
1. 인터럽트란?
    - 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘이다.
    - 인터럽트가 발생하면 CPU에서는 즉각적으로(실행중이던 작업은 완료하고 나서 처리) 인터럽트를 처리하기 위해 커널 코드를 커널 모드에서 실행한다.<br><br>
2. 인터럽트 종류
    - 전원(power)에 문제가 생겼을 경우
    - I/O 작업이 완료됐을 경우
    - 시간이 다 됐을 경우(timer 관련)
    - 0 으로 나눴을 경우
    - 잘못된 메모리 공간에 접근을 시도할 경우
    - 위 경우 외에도 많은 종류의 인터럽트가 있다.

### System Call(시스템 콜)
1. 시스템 콜이란?
    - 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.
    - 보통 C나 C++과 같은 고급 언어로 작성된 프로글매들은 직접 시스템 콜을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.
    - 시스템 콜이 발생하면 해당 커널 코드가 커널 모드에서 실행된다.<br><br>
2. 시스템 콜을 사용하는 이유
    - 유저 어플리케이션이 운영체제의 치명적인 데이터를 수정/삭제하는 권한을 막기 위함이다.<br><br>
3. 시스템 콜의 종류  
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcA9in9%2Fbtqw9OAIYdZ%2FkKNVkBl0y9k9R3EjTNyNI0%2Fimg.png"></img>
    - 프로세스 제어(process control)
        - 끝내기(exit), 중지(abort)
        - 적재(load), 실행(execute)
        - 프로세스 생성(create process) : fork
        - 프로세스 속성 획득과 속성 설정
        - 시간 대기(wait time)
        - 사건 대기(wait event)
        - 사건을 알림(signal event)
        - 메모리 할당 및 해제
    - 파일 조작(file manipulation)
        - 파일 생성(create), 파일 삭제(delete)
        - 파일 열기(open), 파일 닫기(close), 파일 읽기(read), 파일 쓰기(write)
        - 위치 변경(reposition)
        - 파일 속성 획득 및 설정(get file attribute, set file attribute)
    - 장치 관리(device manipulation)
        - 하드웨어의 제어와 상태 정보 얻기(ioctl)
        - 장치 요구(request device), 장치 방출(release device)
        - 읽기(read), 쓰기(write), 위치 변경(reposition)
        - 장치 속성 획득 및 설정
        - 장치의 논리적 부착 및 분리
    - 정보 유지(information maintaenance)
        - getpid(), alarm(), sleep()
        - 시간과 날짜의 설정과 획득(time)
        - 시스템 데이터의 설정과 획득(date)
        - 프로세스 파일, 장치 속성의 획득 및 설정
    - 틍신(communication)
        - pipe(), shm_open(), mmap()
        - 통신 연결의 생성, 제거
        - 메시지의 송신, 수신
        - 상태 정보 전달
        - 원격 장치의 부착 및 분리
    - 보호(protection)
        - chmod()
        - umask()
        - chown()

```
추가 개념 학습 필요 항목
1. Process
    - Process Environment block (PEB)
    - Process identifier (PID)
2. Register vs. Memory
3. argument vector
4. Executable Linkable Format (ELF) & loader
```

## 3. Argument Passing 구현
### 목표 🎯
프로그램과 인자를 구분하지 못하는 구조인 현재 핀토스를 커맨드 라인의 문자열을 토근으로 분리하는 기능을 개발하고, 프로그램 이름과 인자를 구분하여 스택에 저장 및 프로그램에 전달할 수 있도록 구현하는 것이다.

### 전체적인 프로그램 실행 과정 파악
1. 현재 핀토스에서의 프로그램 실행 과정을 한 단계씩 살펴보자.
    - 1단계 : init.c의 main() 함수 실행
        - 핀토스가 시작되면, 이 함수를 통해 핀토스가 실행된다.
        - 여기서 처음 실행할 스레드, 콘솔, 메모리, 페이지, 인터럽트 핸들러, 타이머 등을 초기화 해주는 작업이 진행된다.
        - 우리는 USERPROG이므로, USERPROG 블록 안에 있는 init 함수들을 잘 살펴봐야 한다.<br><br>
    - 2단계 : init.c의 run_actions() 함수 실행
        - 이 함수는 Kernel command line에 정의된 action을 실행하며, argv를 인자로 받는다.
        - 이 과제에서의 kernel command line은 pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'이다.
        - argv는 read_command_line() 함수에서 커널 명령줄을 읽은 후, parse_options() 함수로 해당 멍령줄을 parsing하여 어떠한 action을 할지를 argv에 담아 인자로 넘긴다.
        - 위에서 명시한 명령줄이 parse_options()으로 들어가면, power_off_when_done(-q)와 format_filesys(-f) action을 수행할 수 있도록 true로 만들어주고, 다시 argv를 반환한다.
        - run_actions() 함수 안에는 action이라는 구조체가 정의되어 있다.
        - action 이름, action을 포함하여 command line에 있는 argument의 개수, action에 대응하는 정의된 function을 가진다.
        - 우리는 위에서 명시한 명령줄에 있는 "run"이라는 action만 신경쓰면 되고, 그에 따라 대응하는 run_task() 함수가 실행된다.
        - while 문을 통해 action 구조체를 탐색하면서 인자로 받은 argv와 action 구조체에 정의된 action name을 비교하여 똑같다면 정의된 function을 실행한다.<br><br>
    - 3단계 : init.c의 run_task() 함수 실행
        - 유저 프로세스가 생성되었다면, 커널은 프로세스 종료를 대기한다.
        - 인자로 받은 argv는 run 'args-single onearg'이므로, argv[1]은 'args-single onearg'이 된다.
        - 우리는 아까 USERPROG 블록 안에 있는 함수들을 잘 살펴봐야 한다고 했다.
        - 이 함수에서 thread_tests가 참이면, task를 인자로 받아 run_test() 함수가 실행된다.
        - thread_tests는 위에서 설명한 parse_options() 함수를 통해 thread_tests action을 수행할 수 있도록 true로 만들어줘야 하는데 위에서 명시한 명령줄에는 thread_tests action을 수행할 수 있도록 해주는 -threads-tests 명령어가 없다.
        - 따라서, 우리는 바로 process_wait() 함수가 실행되고, process_wait() 함수에서는 task(=args-single onearg)를 인자로 받는 process_create_initd() 함수를 실행한다.<br><br>
    - 4단계 : process.c의 process_create_initd() 함수 실행
        - page_get_page() 함수를 통해 page를 할당받고 해당 page에 file_name을 저장한 후, 현재 핀토스에서는 단일 스레드만 고려하기 때문에 thread_create() 함수로 새로운 스레드를 생성한 다음 tid를 반환한다.
        - tid는 thread의 고유한 id로, Allocate_tid() 함수에 의해 생성된다.
        - thread_create() 함수는 file_name을 이름으로 하고 PRI_DEFAULT(31)를 우선순위 값으로 가지는 새로운 스레드를 생성한다.
        - 이때, fn_copy를 인자로 받는 initd() 함수가 실행된다.<br><br>
    - 5단계 : process.c의 initd() 함수 실행
        - process_init() 함수로 프로세스를 초기화하고, process_exec() 함수를 실행한다.
        - process_exec() 함수를 실행된 후 반환된 값이 0보다 작은 즉, -1인 경우 PANIC("Fail to launch initd\n");과 PANIC ("executed an unreachable statement");이 발생한다.
        - 여기서 반환된 값이란 _if와 file_name을 현재 프로세스에 load하여 성공하면 0을, 실패하면 -1이 반환된 값을 의미한다.<br><br>
    - 6단계 : process.c process_exec() 함수 실행
        - process_cleanup() 함수를 통해 현재 실행 중인 스레드의 page directory와 switch information을 지워주고, load() 함수를 통해 파일을 load하여 성공하면, do-iret() 함수를 통해 생성된 프로세스로 context switching 한다.
        - 인자로 전달받은 f_name은 args-single onearg이다.
        - **우리는 load() 함수에서 인자로 전달받은 f_name을 parsing하고, user stack에 쌓는 작업을 구현해야 한다.**<br><br>
    - 7단계 : process.c의 thread_create() 함수 실행
        - 스레드를 생성하고, ready_list에 우선순위를 비교하여 적절한 위치에 추가한 다음 tid를 반환한다.<br><br>
    - 8단계 : process.c의 process_wait() 함수 실행
        - process_create_initd() 반환된 tid를 인자로 받아 프로세스가 종료되기까지 대기한다.
        - 현재 process_wait() 함수에는 return -1만 있어서 바로 프로세스가 종료될 것이다.
        - 우리는 argument passing을 구현하고 테스트를 위해 이 함수를 조금 바꿔줘야 한다.<br><br>
    - 9단계 : init.c의 run_task() 함수 실행
        - 프로세스가 종료되었으므로, "Execution of 'args-single onearg' complete." 문장을 출력하고 함수를 빠져나온다.<br><br>
    - 10단계 : init.c의 main() 함수 실행
        - main() 함수로 돌아와서 핀토스를 종료한다.

### 인자로 전달받은 kenel command line을 parsing하여 스레드를 새로 생성할 때 parsing한 파일 이름을 인자로 전달할 수 있도록 함수 수정
```C
tid_t process_create_initd (const char *file_name) {
	char *fn_copy;
	tid_t tid;

	/* Make a copy of FILE_NAME.
	 * Otherwise there's a race between the caller and load(). */
	fn_copy = palloc_get_page (0);
	if (fn_copy == NULL)
		return TID_ERROR;
	strlcpy (fn_copy, file_name, PGSIZE);

	char *save_ptr;
    strtok_r (file_name, " ", &save_ptr); // 인자로 받은 file_name parsing

	/* Create a new thread to execute FILE_NAME. */
	tid = thread_create (file_name, PRI_DEFAULT, initd, fn_copy); // 위에서 parsing한 파일 이름을 새로 생성할 스레드 이름으로 지정
	if (tid == TID_ERROR)
		palloc_free_page (fn_copy);
	return tid;
}
```
- 인자로 받은 kenel command line을 parsing하여, parsing한 파일 이름을 새로 생성할 스레드 이름으로 생성할 수 있도록 코드를 수정한다.

### 입력받은 kernel command line 파싱 기능 구현
```C
/* userprog/process.c */
/* 실행파일의 file_name을 적재해 실행하는 함수 */
static bool load (const char *file_name, struct intr_frame *if_) {
    . . .

    char *argv[LOADER_ARGS_LEN]; // argument 배열 포인터 변수 선언
	char *token, *save_ptr; // 토큰과 parsing하고 남은 문자열의 시작주소 포인터 변수 선언
	int argc = 0; // argument 개수 변수 선언 및 0으로 초기화

	token = strtok_r (file_name, " ", &save_ptr); // 토큰에 문자열을 parsing하고 나온 file_name 저장

	while (token) { // 트큰이 NULL일 때까지 문자열 parsing 수행
		argv[argc++] = token; // 0번째 argument부터 parsing하고 나온 인자 저장
		token = strtok_r (NULL, " ", &save_ptr); // 토큰에 위에서 parsing하고 남은 문자열을 다시 parsing하여 저장(두 번째 parsing부터는 첫 번째 인자를 NULL로 설정)
	}

    . . . 
}
```
- 우리는 인자로 전달받은 file_name인 'args-single onearg'을 파일 이름과 인자로 파싱하는 기능을 먼저 구현해야 한다.
- 아래 4개의 변수를 먼저 선언해야 한다.
    - char *argv[LOADER_ARGS_LEN] : file_name을 파싱하고 나온 문자열을 저장할 char형 포인터 변수
        - LOADER_ARGS_LEN : 이미 선언된 kernel command line 문자열 길이(핀토스에서는 128이 최대)
    - char *token, *save_ptr : file_name을 파싱하고 나온 문자열을 저장할 임시 변수와 파싱하고 남은 문자열의 시작주소를 저장할 포인터 변수
    - int argc = 0 : 인자 개수를 저장할 정수형 변수
- strtok_r() 함수를 이용하여 file_name을 파싱해서 token에 파일 이름 즉, args-single을 저장한다.
- token이 NULL이 될 때까지 문자열 파싱 작업을 계속 반복하면서 0번째 argv부터 파싱하고 나온 문자열이 저장된 token을 저장한다.

### Parsing한 argument를 user stack에 쌓는 함수 구현
```C
/* userprog/process.h */
void argument_stack (char **argv, int argc, struct intr_frame *_if);
```
- 제일 먼저 함수를 process.h에 선언해 주고, 함수 구현을 시작한다.<br><br>
```C
/* parsing한 arguments를 user stack에 넣어주는 함수 */
/* if_->rsp는 현재 user stack에서 현재 위치를 가리키는 스택 포인터로, 맨 처음 if_->rsp는 0x47480000(USER_STACK)이다. */
void argument_stack(char **argv, int argc, struct intr_frame *_if) {
	char *arg_address[128];

	// 1) 프로그램 이름, 인자 문자열 삽입
	// 스택은 아래 방향으로 성장하므로 스택에 인자를 추가할 때 문자열을 오른쪽에서 왼쪽 방향으로(역방향으로) 삽입해야 한다.
	for (int i = argc - 1; i >= 0; i--) { // 맨 끝 NULL 값(arg[4]) 제외하고, 가장 인덱스가 큰 argv부터 스택에 삽입
		int argv_len = strlen(argv[i]);  // 각 인자의 크기 저장
		_if->rsp -= (argv_len + 1); // 각 인자에서 인자 크기(argv_len)를 읽고, 그 크기만큼 rsp를 내림
		memcpy(_if->rsp, argv[i], argv_len + 1); // 그 다음 빈 공간만큼 memcpy() 함수를 이용하여 스택에 삽입(각 인자에 sentinel이 포함이므로, argv_len + 1)
		arg_address[i] = _if->rsp; // arg_address 배열에 현재 문자열 시작 주소 위치 저장
    }

	// 2) word-align 패딩 삽입
	// 각 문자열을 삽입하고, 8바이트 단위로 정렬하기 위해 필요한 만큼 패딩을 추가한다.
    while(_if->rsp % 8 != 0) { // _if->rsp 주소값을 8로 나눴을 때 나머지가 0일 때까지 반복문 수행
        _if->rsp--; // _if->rsp -1 이동
        *(uint8_t *)(_if->rsp) = 0; // _if.rsp가 가리키는 내용물을 0으로 채움(1바이트)
	}

	// 3) 각 인자 문자열의 주소 삽입
	// 인자 문자열 삽입하면서 argv에 담아둔 각 문자열의 주소를 삽입한다.
	for (int i = argc; i >= 0; i--) { // 
        _if->rsp -= 8; // _if->rsp를 8 내림
        if (i == argc) // i값이 argc값과 같으면
            memset(_if->rsp, 0, 8); // _if->rsp에 0을 추가(sentinel 같은 느낌?)
        else 
            memcpy(_if->rsp, &arg_address[i], 8); // 나머지에는 arg_address 안에 들어있는 각 문자열의 주소를 스택에 삽입
    }
    
	// 4) return address 삽입
	// 다음 인스트럭션의 주소를 삽입해야 하는데, 지금은 프로세스를 생성하는 거라서 반환 주소가 없기 때문에 fake return address로 0을 추가한다.
    _if->rsp -= 8; // _if->rsp를 8 내림
	memset(_if -> rsp, 0, 8); // _if->rsp를 return address로 0을 추가

	// 5) 인자의 개수와 argv 시작 주소를 각각 rdi와 rsi에 저장
	_if->R.rdi = argc; // rdi에 인자의 개수 저장
    _if->R.rsi = _if->rsp + 8; // 스택에 마지막에 추가한 fake address를 담기 직전의 주소가 argv에 시작 주소로 설정되어 있으므로, rsi에 현재 스택 포인터 rsp에 8만큼 더한 값 저장
}
```
- Parsing한 argument를 user stack에 쌓는 과정은 총 4단계로, 아래 표와 동일하게 쌓으면 된다.
    | Address    | Name           | Data        | Type        |
    |------------|----------------|-------------|-------------|
    | 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
    | 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
    | 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
    | 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
    | 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
    | 0x4747ffe0 | argv[4]        | 0           | char *      |
    | 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
    | 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
    | 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
    | 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
    | 0x4747ffb8 | return address | 0           | void (*) () |
    - RDI: 4 | RSI: 0x4747ffc0
    - 1단계 : 프로그램 이름, 인자 문자열 삽입
        - 스택은 아래 방향으로 성장하므로 스택에 인자를 추가할 때 문자열을 오른쪽에서 왼쪽 방향으로(역방향으로) 삽입해야 한다.
    - 2단계 : word-align 패딩 삽입
        - 각 문자열을 삽입하고, 8바이트 단위로 정렬하기 위해 필요한 만큼 패딩을 추가한다.
    - 3단계 : 각 인자 문자열의 주소 삽입
        - 인자 문자열 삽입하면서 argv에 담아둔 각 문자열의 주소를 삽입한다.
    - 4단계 : return address 삽입
        - 다음 인스트럭션의 주소를 삽입해야 하는데, 지금은 프로세스를 생성하는 거라서 반환 주소가 없기 때문에 fake return address로 0을 추가한다.
    - 5단계 : 인자의 개수와 argv 시작 주소를 각각 rdi와 rsi에 저장 -> 이 5단계를 나는 안해줘서 시스템 콜 구현하고 테스트할 때 처음부터 fail떠서 삽질 마이~ 했음...😑
        - rdi에 인자의 개수 저장하고, 스택에 마지막에 추가한 fake address를 담기 직전의 주소가 argv에 시작 주소로 설정되어 있으므로, rsi에 현재 스택 포인터 rsp에 8만큼 더한 값 저장한다.
```C
/* userprog/process.c */
/* 실행파일의 file_name을 적재해 실행하는 함수 */
static bool load (const char *file_name, struct intr_frame *if_) {
    . . . 

    success = true;

    argument_stack (argv, argc, if_);

    . . .
}
```
- parsing한 arguments를 user stack에 넣어주는 함수 구현을 완료하고, load() 함수에 추가해 준다.

### Argument passing 테스트를 위해 wait 기능을 흉내내기 위한 process_wait() 함수 수정
```C
int process_wait (tid_t child_tid UNUSED) {
	// argument passing 테스트를 위해 wait 기능을 흉내내기 위한 반복문 추가
	for (int i = 0; i < 1000000000; i++) {

	}

	return -1;
}
```
- 현재 핀토스에서는 프로세스가 종료될 때까지 대기하지 않고 바로 종료하기 때문에 반복문을 추가하여 프로세스가 종료될 때까지 대기하는 것 처럼 해줘야 한다.
- 시스템 콜 구현하고 테스트 할 경우에는 200000000로 변경해야 한다. 시간이 너무 짧으면, fail 뜨는데 왜그런지는 모르겠다...

### Argument passing 테스트를 위해 paring하여 argument를 넣은 user stack을 출력해주기 위한 load() 함수 수정
```C
/* 실행파일의 file_name을 적재해 실행하는 함수 */
static bool load (const char *file_name, struct intr_frame *if_) {
    . . .

    success = true;

	argument_stack (argv, argc, if_); // parsing한 arguments를 user stack에 넣어주는 argument_stack() 함수 호출
	hex_dump(if_->rsp, if_->rsp, USER_STACK - if_->rsp, true); // user stack을 16진수로 출력해주기 위한 hex_dump() 함수 호출

    . . .
}
```
- Argument passing 테스트를 위해 paring하여 argument를 넣은 user stack을 출력해주기 위한 hex_dump() 함수를 추가해 준다.
- hex_dump() 함수는 메모리의 내용을 16진수 형식으로 출력해줘서 스택에 저장된 값들을 확인할 수 있다.

### Argument Passing 구현 후 결과
```
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]
Kernel command line: -q -f put args-single run 'args-single onearg'
0 ~ 9fc00 1
100000 ~ ffe0000 1
Pintos booting with: 
        base_mem: 0x0 ~ 0x9fc00 (Usable: 639 kB)
        ext_mem: 0x100000 ~ 0xffe0000 (Usable: 260,992 kB)
Calibrating timer...  157,081,600 loops/s.
hd0:0: detected 313 sector (156 kB) disk, model "QEMU HARDDISK", serial "QM00001"
hd0:1: detected 20,160 sector (9 MB) disk, model "QEMU HARDDISK", serial "QM00002"
hd1:0: detected 102 sector (51 kB) disk, model "QEMU HARDDISK", serial "QM00003"
Formatting file system...done.
Boot complete.
Putting 'args-single' into the file system...
Executing 'args-single onearg':
000000004747ffc0                          00 00 00 00 00 00 00 00 |        ........|
000000004747ffd0  ed ff 47 47 00 00 00 00-f9 ff 47 47 00 00 00 00 |..GG......GG....|
000000004747ffe0  00 00 00 00 00 00 00 00-00 00 00 00 00 61 72 67 |.............arg|
000000004747fff0  73 2d 73 69 6e 67 6c 65-00 6f 6e 65 61 72 67 00 |s-single.onearg.|
system call!
Execution of 'args-single' complete.
Timer: 191 ticks
Thread: 30 idle ticks, 153 kernel ticks, 9 user ticks
hd0:0: 0 reads, 0 writes
hd0:1: 80 reads, 232 writes
hd1:0: 102 reads, 0 writes
Console: 1169 characters output
Keyboard: 0 keys pressed
Exception: 0 page faults
Powering off...
```

## 4. System Call 구현
### 목표 🎯
시스템 콜 핸들러가 구현되어 있지 않아 시스템 콜이 호출될 수 없으므로 응용 프로그램이 정상적으로 작동하지 않는 현재 핀토스에서 시스템 콜을 구현하여 응용 프로그램이 정상적으로 작동하도록 하는 것이다.

### 전체적인 시스템 콜 호출 과정 파악
1. 현재 핀토스에서의 시스템 콜 호출 과정을 한 단계씩 살펴보자.
    - 1단계 : 유저 프로그램에서 특정 작업을 수행하는 시스템 콜을 호출한다.<br><br>
    - 2단계 : 시스템 호출을 위해 호출한 시스템 콜 번호와 추가 인수에 해당하는 syscall을 호출한다.
        - syscall은 include/lib/user/syscall.c에 각 시스템 콜 번호와 추가 인수에 해당하는 syscall이 위와 같이 정의되어 있다.
            ```C
            /* Invokes syscall NUMBER, passing no arguments, and returns the
            return value as an `int'. */
            #define syscall0(NUMBER) ( \
                    syscall(((uint64_t) NUMBER), 0, 0, 0, 0, 0, 0))

            /* Invokes syscall NUMBER, passing argument ARG0, and returns the
            return value as an `int'. */
            #define syscall1(NUMBER, ARG0) ( \
                    syscall(((uint64_t) NUMBER), \
                        ((uint64_t) ARG0), 0, 0, 0, 0, 0))
            /* Invokes syscall NUMBER, passing arguments ARG0 and ARG1, and
            returns the return value as an `int'. */
            #define syscall2(NUMBER, ARG0, ARG1) ( \
                    syscall(((uint64_t) NUMBER), \
                        ((uint64_t) ARG0), \
                        ((uint64_t) ARG1), \
                        0, 0, 0, 0))

            #define syscall3(NUMBER, ARG0, ARG1, ARG2) ( \
                    syscall(((uint64_t) NUMBER), \
                        ((uint64_t) ARG0), \
                        ((uint64_t) ARG1), \
                        ((uint64_t) ARG2), 0, 0, 0))

            #define syscall4(NUMBER, ARG0, ARG1, ARG2, ARG3) ( \
                    syscall(((uint64_t *) NUMBER), \
                        ((uint64_t) ARG0), \
                        ((uint64_t) ARG1), \
                        ((uint64_t) ARG2), \
                        ((uint64_t) ARG3), 0, 0))

            #define syscall5(NUMBER, ARG0, ARG1, ARG2, ARG3, ARG4) ( \
                    syscall(((uint64_t) NUMBER), \
                        ((uint64_t) ARG0), \
                        ((uint64_t) ARG1), \
                        ((uint64_t) ARG2), \
                        ((uint64_t) ARG3), \
                        ((uint64_t) ARG4), \
                        0))
            ```
        - 각 시스템 콜은 서로 다른 시스템 번호와 인자를 사용하는 데 사용하는 syscall 형식 또한 다 다르며, 너무 많기 때문에 몇 가지만 어떻게 정의되어 있는지 아래 코드를 확인해보자.
            ```C
            void halt (void) {
                syscall0 (SYS_HALT);
                NOT_REACHED ();
            }

            void exit (int status) {
                syscall1 (SYS_EXIT, status);
                NOT_REACHED ();
            }

            pid_t fork (const char *thread_name){
                return (pid_t) syscall1 (SYS_FORK, thread_name);
            }

            int exec (const char *file) {
                return (pid_t) syscall1 (SYS_EXEC, file);
            }
            ```
            - 예를 들어, fork()는 syscall1 형식을 사용하고 호출하며, 인자로는 fork의 시스템 콜 번호와 스레드 이름을 받는다.
        - 여기서 추가로 알아야 할 것은 각 시스템 콜 번호이며, include/lib/syscall-nr.h에 아래와 같이 enum으로 정의되어 있다.
            ```C
            /* System call numbers. */
            enum {
                /* Projects 2 and later. */
                SYS_HALT,                   /* Halt the operating system. */
                SYS_EXIT,                   /* Terminate this process. */
                SYS_FORK,                   /* Clone current process. */
                SYS_EXEC,                   /* Switch current process. */
                SYS_WAIT,                   /* Wait for a child process to die. */
                SYS_CREATE,                 /* Create a file. */
                SYS_REMOVE,                 /* Delete a file. */
                SYS_OPEN,                   /* Open a file. */
                SYS_FILESIZE,               /* Obtain a file's size. */
                SYS_READ,                   /* Read from a file. */
                SYS_WRITE,                  /* Write to a file. */
                SYS_SEEK,                   /* Change position in a file. */
                SYS_TELL,                   /* Report current position in a file. */
                SYS_CLOSE,                  /* Close a file. */

                /* Project 3 and optionally project 4. */
                SYS_MMAP,                   /* Map a file into memory. */
                SYS_MUNMAP,                 /* Remove a memory mapping. */

                /* Project 4 only. */
                SYS_CHDIR,                  /* Change the current directory. */
                SYS_MKDIR,                  /* Create a directory. */
                SYS_READDIR,                /* Reads a directory entry. */
                SYS_ISDIR,                  /* Tests if a fd represents a directory. */
                SYS_INUMBER,                /* Returns the inode number for a fd. */
                SYS_SYMLINK,                /* Returns the inode number for a fd. */

                /* Extra for Project 2 */
                SYS_DUP2,                   /* Duplicate the file descriptor */

                SYS_MOUNT,
                SYS_UMOUNT,
            };
            ```
            - 여기서 fork() 시스템 콜 번호는 2인 것을 알 수 있다.<br><br>
    - 3단계 : 각 시스템 콜에 해당하는 syscall이 호출되면, 아래의 syscall() 함수를 호출하여 인자로 받은 값들을 레지스터에 순서대로 삽입하고 syscall을 실행한다.
        ```C
        __attribute__((always_inline))
        static __inline int64_t syscall (uint64_t num_, uint64_t a1_, uint64_t a2_,
                uint64_t a3_, uint64_t a4_, uint64_t a5_, uint64_t a6_) {
            int64_t ret;
            register uint64_t *num asm ("rax") = (uint64_t *) num_;
            register uint64_t *a1 asm ("rdi") = (uint64_t *) a1_;
            register uint64_t *a2 asm ("rsi") = (uint64_t *) a2_;
            register uint64_t *a3 asm ("rdx") = (uint64_t *) a3_;
            register uint64_t *a4 asm ("r10") = (uint64_t *) a4_;
            register uint64_t *a5 asm ("r8") = (uint64_t *) a5_;
            register uint64_t *a6 asm ("r9") = (uint64_t *) a6_;

            __asm __volatile(
                    "mov %1, %%rax\n"
                    "mov %2, %%rdi\n"
                    "mov %3, %%rsi\n"
                    "mov %4, %%rdx\n"
                    "mov %5, %%r10\n"
                    "mov %6, %%r8\n"
                    "mov %7, %%r9\n"
                    "syscall\n"
                    : "=a" (ret)
                    : "g" (num), "g" (a1), "g" (a2), "g" (a3), "g" (a4), "g" (a5), "g" (a6)
                    : "cc", "memory");
            return ret;
        }
        ```
        - fork() 시스템 콜 함수는 syscall1이며, 시스템 콜 번호와 스레드 이름을 인자로 가진 함수이다.
        - 따라서, syscall() 함수에서 레지스터에 시스템 콜 번호는 rax, 스레드 이름은 rdi에 넣고, 나머지 값은 모두 0으로 채운다.
        - 여기서, 레지스터에 각 인자를 넣는 순서에 대해 알아보자.
            - %rax는 시스템 호출 번호입니다.
            - 네 번째 인수는 %rcx가 아닌 %r10입니다.
            - 즉, 레지스터에 인자를 넣는 순서는 %rax, %rdi, %rsi, %rdx, %r10, %r8, %r9이다.
            - 따라서, 시스템 호출 핸들러 syscall_handler()가 제어권을 얻으면 시스템 호출 번호는 rax에 있고 인수는 %rdi, %rsi, %rdx, %r10, %r8, %r9의 순서로 전달됩니다.<br><br>
    - 4단계 : syscall이 실행되면, syscall-entry가 실행된다.
        - syscall이 실행되면, 아래와 같이 init.c의 main() 함수를 통해 핀토스가 실행되면서 syscall_init() 함수가 호출되고 syscall-entry() 함수가 실행된다.
            ```C
            /* Pintos main program. */
            int
            main (void) {
                . . .

                syscall_init ();

                . . .
            }
            ```
            ```C
            void
            syscall_init (void) {
                write_msr(MSR_STAR, ((uint64_t)SEL_UCSEG - 0x10) << 48  |
                        ((uint64_t)SEL_KCSEG) << 32);
                write_msr(MSR_LSTAR, (uint64_t) syscall_entry);

                /* The interrupt service rountine should not serve any interrupts
                * until the syscall_entry swaps the userland stack to the kernel
                * mode stack. Therefore, we masked the FLAG_FL. */
                write_msr(MSR_SYSCALL_MASK,
                        FLAG_IF | FLAG_TF | FLAG_DF | FLAG_IOPL | FLAG_AC | FLAG_NT);
            }
            ```
            - syscall_init() 함수가 호출되면, write_msr() 함수가 호출된다.
            - write_msr() 함수에서 MSR_LSTAR라는 레지스터에 syscall_entry() 함수의 주소값을 넣어주고 초기화를 시켜준다.
            - 유저가 시스템 콜을 요청하면, 어셈블리어로 구성된 syscall_entry.S 파일로 이동하여 syscall_entry() 함수가 실행된다.
            - 그 이유는 syscall_entry.S 파일에 아래와 같이 syscall_entry() 함수가 선언되어 있기 때문이다.
                ```
                .globl syscall_entry
                .type syscall_entry, @function
                ```
            - 그러면 MSR_LSTAR 레지스터는 어디서 접근하여 syscall_entry.S 파일로 이동하고 syscall_entry() 함수를 실행시키는 것일까???🧐🧐🧐
        - syscall-entry() 함수가 호출되면, 아래와 같이 어셈블리어로 구성된 userprog/syscall-entry.S로 이동한다.
            ```C
            #include "threads/loader.h"

            .text
            .globl syscall_entry
            .type syscall_entry, @function
            syscall_entry:
                movq %rbx, temp1(%rip)
                movq %r12, temp2(%rip)     /* callee saved registers */
                movq %rsp, %rbx            /* Store userland rsp    */
                movabs $tss, %r12
                movq (%r12), %r12
                movq 4(%r12), %rsp         /* Read ring0(커널 모드를 지칭하며, ring3은 유저 모드를 지칭) rsp from the tss */
                /* Now we are in the kernel stack */
                push $(SEL_UDSEG)      /* if->ss */
                push %rbx              /* if->rsp */
                push %r11              /* if->eflags */
                push $(SEL_UCSEG)      /* if->cs */
                push %rcx              /* if->rip */
                subq $16, %rsp         /* skip error_code, vec_no */
                push $(SEL_UDSEG)      /* if->ds */
                push $(SEL_UDSEG)      /* if->es */
                push %rax
                movq temp1(%rip), %rbx
                push %rbx
                pushq $0
                push %rdx
                push %rbp
                push %rdi
                push %rsi
                push %r8
                push %r9
                push %r10
                pushq $0 /* skip r11 */
                movq temp2(%rip), %r12
                push %r12
                push %r13
                push %r14
                push %r15
                movq %rsp, %rdi

            check_intr:
                btsq $9, %r11          /* Check whether we recover the interrupt */
                jnb no_sti
                sti                    /* restore interrupt */
            no_sti:
                movabs $syscall_handler, %r12
                call *%r12
                popq %r15
                popq %r14
                popq %r13
                popq %r12
                popq %r11
                popq %r10
                popq %r9
                popq %r8
                popq %rsi
                popq %rdi
                popq %rbp
                popq %rdx
                popq %rcx
                popq %rbx
                popq %rax
                addq $32, %rsp
                popq %rcx              /* if->rip */
                addq $8, %rsp
                popq %r11              /* if->eflags */
                popq %rsp              /* if->rsp */
                sysretq				   /* 유저 모드로 복귀 */

            .section .data
            .globl temp1
            temp1:
            .quad	0
            .globl temp2
            temp2:
            .quad	0
            ```
            - syscall-entry.S에서는 인터럽트 프레임 구조체에 있던 값을 레지스터에 옮기고 계산하는 작업을 수행한다.
            - 여기서 우리가 살펴봐야 할 부분은 아래와 같다.
                ```C
                movabs $tss, %r12
                movq (%r12), %r12
                movq 4(%r12), %rsp         /* Read ring0 rsp from the tss */
                ```
                - movq 명렁어는 데이터를 이동시키는 명령어로, 형식은 다음과 같다.
                    - movq Source, Dest : Source에 해당하는 값을 Dest가 나타내는 공간에 이동(저장)시킨다는 의미이다.
                - movabs $tss, %r12 명령어를 수행한다.
                    - 우리는 커널 스택 포인터를 찾아야 한다.
                    - 아래에서 할 작업이 커널을 호출하여 커널 스택에 push & pop을 수행하는데, 그러기 위해서 커널 스택을 가리키고 있는 포인터를 알아야 하기 때문이다.
                    - 이 명령어를 통해 우리는 커널 스택 포인터를 찾을 수 있다.
                - movq 4(%r12), %rsp 명령어를 수행한다.
                    - 이 명령어를 통해 tss에 있는 값인 커널 스텍 포인터 값을 %rsp에 넣는다.
                    - 이제 우리는 커널 스택 포인터로 이동할 수 있게 되었고, 이때부터 rsp는 유저 스택이 아닌 커널 스택을 가리키게 되면서 커널 모드를 시작할 수 있다.
                - 위 과정을 요약하면, CPU의 rsp 값에 tss에 저장된 커널 스택의 스택 포인터를 저장한다는 의미이다.
                - 위 명령어를 모두 실행한 후, CPU 레지스터 값들을 커널 스택에 push한다.
                    - push되는 순서는 마지막에 들어간 데이터부터 interrupt frame 구조체 순서가 되도록 push한다.
                - 다음으로는 movabs $syscall_handler, %r12 명령어를 실행하여 $syscall_handler값을 %r12에 저장하고, call *%r12 명령어를 사용하여 syscall_handler() 함수를 호출한다.<br><br>
    - 5단계 : syscall_handler(struct intr_frame *f) 함수가 호출되고, 시스템 콜을 수행하는 함수를 호출한다.
        - 인자로 들어온 f는 커널스택의 rsp이다.
        - rsp부터는 intr_frame 형태의 데이터들이 순차적으로 들어가 있으므로 이 자체를 인터럽트 프레임처럼 사용할 수 있는 것이다.
        - 즉, f의 rax(시스템 콜 번호) 값을 통해 필요한 시스템 콜을 수행하는 함수를 아래와 같이 호출한다.
            ```C
            void
            syscall_handler (struct intr_frame *f UNUSED) {
                switch() {
                    case SYS_HALT :
                        halt ();
                        break;
                    case SYS_EXIT :
                        exit ();
                        break;
                    case SYS_FORK :
                        fork ();
                        break;
                    case SYS_EXEC :
                        exec ();
                        break;
                    case SYS_WAIT :
                        wait ();
                        break;
                    case SYS_CREATE :
                        create ();
                        break;
                    case SYS_REMOVE :
                        remove ();
                        break;
                    case SYS_OPEN :
                        open ();
                        break;
                    case SYS_FILESIZE :
                        filesize ();
                        break;
                    case SYS_READ :
                        read ();
                        break;
                    case SYS_WRITE :
                        write ();
                        break;
                    case SYS_SEEK :
                        seek ();
                        break;
                    case SYS_TELL :
                        tell ();
                        break;
                    case SYS_CLOSE :
                        close ();
                        break;
                    default :
                        /* call thread_exit function; */
                }

                printf ("system call!\n");
                thread_exit ();
            }
            ```
            - 아직 구현하기 전이라 틀만 잡아 놓은 상태이다.
            - 모든 함수가 구현되면, 유저 프로그램에서 호출한 시스템 콜 함수가 호출되어 실행될 것이다.
            - 모든 작업이 완료되면, syscall-entry.S에서 sysretq 명령어가 실행되어 유저 모드로 복귀한다.<br><br>
    - 여기까지가 핀토스에서 유저 프로그램이 시스템 콜을 호출하는 전체적인 과정이다(휴... 힘들다😅).

### 현재 핀토스에서의 메모리 구성 파악
- 현재 핀토스에서의 메모리 구성을 살펴보자.
```C
^                     +----------------------------------+
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
KENEL VIRTUAL MEMORY  |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
v                     |                                  |
^                     +----------------------------------+ KERN_BASE(0x8004000000)
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  | -> file mapped page(PROJECT3에서 사용)
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     +----------------------------------+ USER_STACK(0x47480000)
|                     |             user stack           |
|                     |                 |                |
|                     |                 |                |
|                     |                 V                |
|                     |           grows downward         |
USER VIRTUAL MEMORY   |                                  |
|                     |           grows upward           |
|                     |                 ^                |
|                     |                 |                |
|                     |                 |                |
|                     +----------------------------------+
|                     | uninitialized data segment (BSS) |
|                     +----------------------------------+
|                     |     initialized data segment     |
|                     +----------------------------------+
|                     |            code segment          |
|            0x400000 +----------------------------------+
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
|                     |                                  |
v                0x00 +----------------------------------+
```

### 잘못된 메모리 액세스를 처리하는 함수 구현
- check_address() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 주소 값이 유저 영역에서 사용하는 주소 값인지 확인 하는 함수 */
    /* 주소유효성 겸사 : 포인터가 가리키는 주소가 사용자 영역(0x8048000~0xc0000000)인지 확인 */
    /* 유저 영역을 벗어난 영역인 경우 프로세스 종료(exit(-1)) */
    void check_address (void *addr) {
        // 현재 접근하는 메모리 주소가 NULL이거나, 커널 영역에서 사용하는 주소이거나, 유저 영역에서 사용하는 주소이지만 페이지로 할당되지 않은 주소일 경우(=잘못된 접근)
        if (addr == NULL || is_kernel_vaddr(addr) || pml4_get_page (thread_current ()->pml4, addr) == NULL) {
            exit(-1); // 프로세스 종료
        }
    }
    ```
    - 우리는 GitBook Accesing User Memory 부분의 내용과 같이 잘못된 메모리에 액세스 했을 때 처리해야 한다.
        - 처리하는 방법은 두 가지가 있으며, 지금은 첫 번째 방법을 사용할 것이다.
        - 첫 번째 방법은 사용자가 제공한 포인터의 유효성을 확인한 다음 잘못된 메모리에 액세스 했을 경우 포인터를 참조 해제하는 것이다.<br><br>
- 그러면 구현한 check_address() 함수를 살펴보자.
    - 여기서는 이미 정의된 두 개의 함수를 사용하여 구현할 수 있다.
    - is_kernel_vadder() 함수는 인자로 받아온 주소가 커널 가상 주소이면 true를 반환한다.
        ```C
        /* include/threads/vaddr.h*/
        /* Returns true if VADDR is a kernel virtual address. */
        #define is_kernel_vaddr(vaddr) ((uint64_t)(vaddr) >= KERN_BASE)
        ```
    - pml4_get_page() pml4에서 유저 가상 주소에 해당하는 물리적 주소를 찾으며, 해당 물리적 주소에 해당하는 커널 가상 주소가 매핑되지 않은 경우 널 포인터를 반환한다.
        ```C
        /* threads/mmu.c */
        /* pml4에서 사용자 가상 주소 UADDR에 해당하는 물리적 주소를 찾습니다. */
        /* 해당 물리적 ​​주소에 해당하는 커널 가상 주소 또는 UADDR이 매핑되지 않은 경우 널 포인터를 반환합니다. */
        void *
        pml4_get_page (uint64_t *pml4, const void *uaddr) {
            ASSERT (is_user_vaddr (uaddr));

            uint64_t *pte = pml4e_walk (pml4, (uint64_t) uaddr, 0);

            if (pte && (*pte & PTE_P))
                return ptov (PTE_ADDR (*pte)) + pg_ofs (uaddr);
            return NULL;
        }
        ```
- 위 두 함수를 이용하여 현재 접근하는 메모리 주소가 커널 영역에서 사용하는 주소이거나, 유저 영역에서 사용하는 주소이지만 페이지로 할당되지 않은 주소일 경우에는 잘못된 메모리 접근이므로 프로세스를 종료한다.

### 시스템 콜 핸들러 함수 수정
- 호출된 시스템 콜의 번호에 해당하는 각 시스템 콜 함수를 호출해줄 수 있도록 switch 문으로 시스템 콜 핸들러 함수를 다음과 같이 수정한다.
    ```C
    /* userprog/syscall.c */
    /* 시스템 콜 인터페이스 메인 함수 */
    void syscall_handler (struct intr_frame *f UNUSED) {
        int system_call_number = f->R.rax; // 호출한 시스템 콜 번호를 저장하는 변수 선언
        switch(system_call_number) {
            case SYS_HALT :
                halt ();
                break;
            case SYS_EXIT :
                exit (f->R.rdi);
                break;
            case SYS_FORK :
                f->R.rax = fork (f->R.rdi, f);
                break;
            case SYS_EXEC :
                f->R.rax = exec(f->R.rdi);
                break;
            case SYS_WAIT :
                f->R.rax = wait (f->R.rdi);
                break;
            case SYS_CREATE :
                f->R.rax = create (f->R.rdi, f->R.rsi);
                break;
            case SYS_REMOVE :
                f->R.rax = remove (f->R.rdi);
                break;
            case SYS_OPEN :
                f->R.rax = open (f->R.rdi);
                break;
            case SYS_FILESIZE :
                f->R.rax = filesize (f->R.rdi);
                break;
            case SYS_READ :
                f->R.rax = read (f->R.rdi, f->R.rsi, f->R.rdx);
                break;
            case SYS_WRITE :
                f->R.rax = write (f->R.rdi, f->R.rsi, f->R.rdx);
                break;
            case SYS_SEEK :
                seek (f->R.rdi, f->R.rsi);
                break;
            case SYS_TELL :
                f->R.rax = tell (f->R.rdi);
                break;
            case SYS_CLOSE :
                close (f->R.rdi);
                break;
            default :
                exit (-1);
                break;
        }

        // printf ("system call!\n");
        // thread_exit ();
    }
    ```
    - 구현한 시스템 콜 함수를 테스트하기 위해 지금은 pirntf 문과 thread_exit() 함수를 주석처리 해준다.

### 구현된 시스템 콜 함수를 테스트 하기 위한 WRITE 시스템 콜 함수 간단 구현
- write() 함수를 임시로 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일의 데이터를 기록하는 시스템 콜 함수 */
    int write (int fd, const void *buffer, unsigned size) {
        // fd가 1이면, putbuf() 함수를 이용하여 한 번 호출하여 가능한 모든 buffer 데이터를 한 번에 콘솔에 쓰기
        if (fd == 1) {
            putbuf (buffer, size); 
        }
        return size;
    }
    ```
    - 현재는 단순히 구현한 시스템 콜 함수를 테스트하기 위해 fd가 1이면, putbuf() 함수를 이용하여 한 번 호출하여 가능한 모든 buffer 데이터를 한 번에 콘솔에 쓰기 작업을 수행할 수 있도록만 코드를 추가한다.

### 핀토스를 종료시키는 HALT 시스템 콜 함수 구현
- halt() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 핀토스 종료 시스템 콜 함수 */
    void halt (void) {
        power_off (); // HALT 시스템 콜 호출 시, init.c의 power_off() 함수로 핀토스를 종료
    }
    ```
    - HALT 시스템 콜 호출 시, power_off() 함수를 호출하여 핀토스를 종료한다.

### 현재 프로세스를 종료시키는 EXIT 시스템 콜 함수 구현
- exit() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 현재 프로세스를 종료시키는 시스템 콜 함수 */
    void exit (int status) {
        struct thread *cur = thread_current (); // 실행중인 현재 스레드 구조체를 curr에 저장
        cur->exit_status = status; // 현재 스레드 종료 상태 저장(0이면 정상 종료)
        printf("%s: exit(%d)", thread_name (), status); // 프로세스 종료 메시지 출력
        thread_exit(); // 스레드 종료
    }
    ```
    - EXIT 시스템 콜 호출 시, 현재 실행중인 스레드의 구조체를 받아 해당 스레드 종료 상태를 저장한다.
        - 스레드 종료 상태를 저장하는 변수인 exit_status는 include/threads/thread.h에서 스레드 구조체에 int형으로 선언해 준다.
        - status 값이 0이면, 정상 종료 상태이다.
    - 스레드 종료 상태를 저장하고, 프로세스 종료 메시지를 출력해준 다음 thread_exit() 함수를 이용하여 스레드를 종료한다.

### 자식 프로세스를 생성하고 실행시키는 FORK 시스템 콜 함수 구현
- 우선, 현재 핀토스에서의 프로세스 구조체에는 부모와 자식 관계를 나타내는 코드가 없다.
    - 즉, 부모와 자식의 구분이 없고 자식 프로세스의 정보를 알지 못하므로, 자식의 시작 또는 종료되기 전에 부모 프로세스가 종료된다.
    - 이때, FORK 시스템 콜 함수를 이용하여, 부모 프로세스를 복제해서 자식 프로세스를 생성하고 실행시킬 수 있도록 구현해야 한다.<br><br>
- 근데 왜 부모 프로세스를 복제하여 자식 프로세스를 생성하는 이유는 무엇일까?🤔
    - 프로세스를 생성하는 과정이 간단하지 않아, 프로세스를 생성하고 관련된 많은 자료 구조들을 다 새로 만드는 것보다 기존에 생성된 프로세스의 자료 구조를 복사하는 것이 더 효율적이기 때문이다.
    - 새로 생성된 프로세스의 엔트리 포인트에 대한 것 때문이기도 하다.
        - 일반적으로 프로그램이 실행될 때 메인 함수를 엔트리 포인트로 하는데, 새로 프로세스가 셍성될 때마다 메인 함수부터 시작하는 것을 매우 비효율적이다.
        - 따라서, 부모 프로세스를 복제하면 부모 프로세스가 호출한 시점을 엔트리 포인트로 가지므로, 발생하는 여러 문제를 해결할 수 있다.<br><br>
```C
- fork() 함수를 다음과 같이 구현한다.
```C
/* userprog/syscall.c */
/* 자식 프로세스를 복제하고 실행시키는 시스템 콜 함수 */
tid_t
fork(const char *thread_name, struct intr_frame *f) {
	return process_fork(thread_name, f); // 현재 프로세스를 복제하는 process_fork() 함수 호출
}
```
- FORK 시스템 콜 함수가 호출되면, 현재 프로세스를 복제하는 process_fork() 함수를 호출한다.<br><br>
- process_fork() 함수를 구현하기 위해 몇 가지 작업이 필요하다.
    - 우선적으로 if_를 복사하기 위한 현재 스레드의 parent_if 구조체를 선언한다.
        ```C
        /* include/threads/thread.h */
        struct intr_frame parent_if; // 현재 스레드 if_ 선언
        ```
    - 새로 생성되는 스레드를 현재 실행중인 스레드의 자식으로 지정하기 위해 자식 리스트를 설정하기 위한 child_list와 child_elem를 선언하고 초기화한다.
        ```C
        /* include/threads/thread.h */
        struct list child_list; // 자식 리스트 선언
        struct list_elem child_elem; // 자식 리스트 element 선언
        ```
    - 자식이 로드될 때까지 대기하기 위해서 방금 생성한 자식 스레드를 자식 리스트에서 검색하는 get_child_process() 함수를 다음과 같이 구현한다.
        ```C
        /* userprog/process.c */
        /* 자식이 로드될 때까지 대기하기 위해서 방금 생성한 자식 스레드를 자식 리스트에서 검색하는 함수 */
        struct thread *get_child_process (int pid) {
            struct thread *cur = thread_current (); // 현재 스레드 저장
            struct list *child_list = &cur->child_list; // 현재 스레드가 있는 자식 리스트 저장

            // 자식 리스트에서 순차적으로 새로 생성한 스레드 검색
            for (struct list_elem *e = list_begin (child_list); e != list_end (child_list); e = list_next (e)) {
                struct thread *t = list_entry (e, struct thread, child_elem); // list_entry() 함수를 이용하여, 새로 생성된 정확한 스레드 검색

                // 검색한 스레드의 id가 새로 생성한 스레드의 id와 같은 경우 해당 스레드 반환(해당 스레드가 새로 생성한 스레드)
                if (t->tid == pid)
                    return t;
            }

            // 자식 리스트에 새로 생성한 스레드가 존재하지 않는 경우 NULL 반환
            return NULL;
        }
        ```
        - 자식이 로드될 때까지 대기하기 위해서 방금 생성한 자식 스레드를 자식 리스트에서 검색하는 get_child_process() 함수를 구현하기 위해 먼저 선언한다.
        - get_child_process() 함수에서 자식 리스트를 순차적으로 검색하면서 새로 생성한 스레드를 찾는다.
        - 검색한 스레드의 id가 새로 생성한 스레드의 id와 같은 경우 해당 스레드를 반환하고, 자식 리스트에 새로 생성한 스레드가 존재하지 않는 경우 NULL을 반환한다.
    - 부모와 자식이 작업 실행과 종료 등의 상태를 시그널을 서로 주고받을 수 있도록 세마포어를 선언하고 초기화한다.
        ```C
         /* include/threads/thread.h */
        struct semaphore load_sema; // 현재 스레드가 load되는 동안 부모를 대기시키기 위한 세마포어 선언
        struct semaphore exit_sema; // 자식 스레드가 종료되고 스케줄링이 이어질 수 있도록 부모에게 시그널 보내기 위한 세마포언 선언 
        struct semaphore wait_sema; // 자식 스레드가 종료될 때까지 대기하고 있는 부모에게 자식 스레드가 작업을 종료했다는 시그널을 보내기 위한 세마포어 선언
        ```
        - 주석은 참고만 하고, 상황에 따라 사용하는 용도가 다르므로 그때마다 해석하는게 좋다.
    - 이제 process_fork() 함수를 수정하기 위한 준비가 되었고, 구현을 시작해보자.<br><br>
- 현재 프로세스를 복제하는 process_fork() 함수를 살펴보자.
    ```C
    /* userprog/process.c */
    /* 현재 프로세스를 복제하여 name이라는 이름의 새로운 프로세스를 만들고, 그 프로세스의 스레드 id를 반환한다.
    만약, 스레드 생성에 실패하면 TID_ERROR를 반환한다. */
    /* 현재 프로세스를 복제하는 함수 */
    tid_t process_fork (const char *name, struct intr_frame *if_ UNUSED) {
        // 현재 스레드의 parent_if에 복제해야 하는 if_ 복사
        struct thread *cur = thread_current ();
        memcpy (&cur->parent_if, if_, sizeof(struct intr_frame));

        // __do_fork() 함수를 이용하여 현재 스레드를 복제한 새로운 스레드 생성하고, 생성된 스레드의 id인 tid를 반환
        tid_t tid = thread_create (name, PRI_DEFAULT, __do_fork, cur);
        
        // 반환된 tid가 TID_ERROR인 경우 TID_ERROR 반환(=스레드가 제대로 생성되지 않은 경우)
        if (tid == TID_ERROR)
            return TID_ERROR;

        // 자식이 로드될 때까지 대기하기 위해서 방금 생성한 자식 스레드 검색
        struct thread *child = get_child_process (tid);
        
        sema_down (&child->load_sema); // 자식이 로드가 완료될 때까지 부모는 대기

        // 자식이 로드되다가 오류로 exit한 경우
        if (child->exit_status == -2)
        {
            list_remove (&child->child_elem); // 자식이 종료되었으므로 자식 리스트에서 제거
            sema_up (&child->exit_sema); // 자식이 종료되고 스케줄링이 이어질 수 있도록 부모에게 시그널 전송
            return TID_ERROR; // TID_ERROR 반환
        }

        return tid; // 자식이 성공적으로 로드된 경우 자식의 tid 반환
    }
    ```
    - 현재 프로세스를 복제하기 위해 현재 스레드의 parent_if에 복제해야 하는 if_를 복사한다.
    - __do_fork() 함수를 이용하여 현재 스레드를 복제한 새로운 스레드 생성하고, 생성된 스레드의 id인 tid를 반환한다.
        - 이때, 새로운 스레드 생성에 실패하면 TID_ERROR를 반환한다.
    - 새로운 스레드가 정상적으로 생성되었다면, 새로 생성된 스레드(=자식)가 로드될 때까지 대기하기 위해 get_child_process() 함수를 통해 자식 리스트에서 해당 스레드를 찾는다.
    - 자식 스레드를 잘 찾았다는 가정하에, 자식이 로드가 완료될 때까지 부모를 대기시킨다.
    - 자식이 어떤 오류로 인해 load에 실패하면, 자식이 종료되었으므로 자식 리스트에서 제거하고, 다음 스케줄링이 이어질 수 있도록 부모에게 시그널을 전송한 후에 TID_ERROR를 반환한다.
    - 만약, 자식이 정상적으로 load에 성공하였다면, 자식 스레드의 id인 tid를 반환한다.<br><br>
- 현재 스레드를 복제하는 __do_fork() 함수를 살펴보자.
    ```C
    /* userprog/process.c */
    static void __do_fork (void *aux) {
        . . .

        parent_if = &parent->parent_if; // 인자로 전달 받은 부모 스레드의 parent_if 필드의 값을 parent_if에 할당
        
        . . .

        if_.R.rax = 0; // 자식 프로세스의 리턴값 0으로 초기화

        . . .

        // file_duplicate() 함수를 이용하여 파일 디스크립터 테이블 복사
        for (int i = 0; i < FD_COUNT_LIMIT; i++) {
            struct file *file = parent->fdt[i];
            if (file == NULL)
                continue;
            if (file > 2)
                file = file_duplicate (file);
            current->fdt[i] = file;
        }
        current->fd_idx = parent->fd_idx;

        // 자식이 로드가 완료될 때까지 기다리고 있던 부모 대기 해제
        sema_up (&current->load_sema);
        process_init ();

        /* Finally, switch to the newly created process. */
        if (succ)
            do_iret (&if_);
    error:
        sema_up (&current->load_sema);
        exit (-2);
    }
    ```
    - 인자로 전달 받은 부모 스레드의 parent_if 필드의 값을 parent_if에 할당해 준다.
    - 자식 프로세스의 리턴값을 0으로 초기화 한다.
    - file_duplicate() 함수를 이용하여 부모 파일 디스크립터 테이블을 복사한다.
    - 파일 디스크립터 테이블 복사가 완료되면, 자식이 로드가 완료될 때까지 기다리고 있는 부모를 대기 해제하고 프로세스를 초기화한다.
    - 만약, 실패하면 자식을 종료한다.<br><br>
- 페이지 테이블을 복제하는 데 사용하는 함수인 duplicate_pte() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/process.c */
    /* 페이지 테이블을 복제하는 데 사용되는 함수 */
    static bool
    duplicate_pte (uint64_t *pte, void *va, void *aux) {
        struct thread *current = thread_current ();
        struct thread *parent = (struct thread *) aux;
        void *parent_page;
        void *newpage;
        bool writable;

        /* 1. TODO: If the parent_page is kernel page, then return immediately. */
        if (is_kernel_vaddr(va))
            return true;

        /* 2. Resolve VA from the parent's page map level 4. */
        parent_page = pml4_get_page(parent->pml4, va);
        if (parent_page == NULL)
            return false;

        /* 3. TODO: Allocate new PAL_USER page for the child and set result to
        *    TODO: NEWPAGE. */
        newpage = palloc_get_page(PAL_USER | PAL_ZERO);
        if (newpage == NULL)
            return false;

        /* 4. TODO: Duplicate parent's page to the new page and
        *    TODO: check whether parent's page is writable or not (set WRITABLE
        *    TODO: according to the result). */
        memcpy(newpage, parent_page, PGSIZE);
        writable = is_writable(pte);

        /* 5. Add new page to child's page table at address VA with WRITABLE
        *    permission. */
        if (!pml4_set_page(current->pml4, va, newpage, writable))
        {
            /* 6. TODO: if fail to insert page, do error handling. */
            return false;
        }

        return true;
    }
    ```
- 마지막으로, 다음과 같이 부모를 복제한 새로운 스레드가 생성되었으면 부모 스레드의 자식 리스트에 추가해야 한다.
    ```C
    /* threads/thread.c */
    tid_t thread_create (const char *name, int priority, thread_func *function, void *aux) {
        . . .

        // 새로운 스레드를 생성하였으므로, 현재 스레드의 자식 리스트에 추가
        list_push_back (&thread_current ()->child_list, &t->child_elem);

        t->fdt = palloc_get_multiple (PAL_ZERO, FDT_PAGES);
        if (t->fdt == NULL)
            return TID_ERROR;

        . . .
    }
    ```

### 현재 프로세스를 새로운 프로세스로 덮어 씌워 실행하는 EXEC 시스템 콜 함수 구현
- exec() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    #include "include/threads/palloc.h" // EXEC 시스템 콜 함수에서 PAL_ZERO를 사용하기 위한 헤더 추가
    #include "include/userprog/process.h" // EXEC 시스템 콜 함수에서 process_exec() 함수를 호출하기 위한 헤더 추가
    ```
    ```C
    /* userprog/syscall.c */
    /* 현재 프로세스를 새로운 프로세스로 덮어 씌워 실행하는 시스템 콜 함수 */
    int exec (const char *file) {
        check_address (file); // 현재 가리키는 주소가 유저 영역의 주소인지 확인하여, 잘못된 주소이면 프로세스 종료
        char *fn_copy = palloc_get_page (PAL_ZERO); // 커널 풀에서 페이지를 가져와 페이지를 0으로 채우고, 사용 가능한 페이지가 없으면 NULL 포인터 반환

        // 메모리 할당 실패 시, 프로세스 종료
        if(fn_copy == NULL)
            exit (-1);
        
        strlcpy (fn_copy, file, PGSIZE); // 파일 이름 복사

        // 복사한 파일 이름을 인자로 process_exec() 함수를 호출하고, load에 실패한 경우 프로세스 종료
        if (process_exec (fn_copy) == -1)
            exit (-1);
    }
    ```
    - 인자로 받아온 command line의 주소가 유저 영역의 주소인지 check_address() 함수로 확인한다.
        - 잘못된 주소를 가르키면, 프로세스를 종료한다.
    - 커널 풀에서 페이지를 가져와 페이지를 0으로 채우고, 가능한 페이지가 없으면 NULL 포인터를 반환한다.
        - 이때, palloc_get_page() 함수에서 FLAG로 PAL_ZERO를 사용하기 위해 헤더를 추가해야 한다.
    - 페이지를 할당받은 후, 정상적으로 페이지를 할당받았으면 넘어가고, NULL이면 프로세스를 종료한다.
    - process_exec() 함수에서 command line을 파싱할 것이므로, command line을 복사해 둔다.
    - command line을 인자로 process_exec() 함수를 호출하고, load에 실패한 경우 프로세스를 종료한다.
        - 이때, process_exec() 함수를 호출하기 위해 헤더를 추가해야 한다.

### 자식 프로세스가 종료될 때까지 대기하고, 정상적으로 종료되었는지 상태를 확인하는 WAIT 시스템 콜 함수 구현
- wait() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 자식 프로세스가 종료될 때까지 대기하고, 정상적으로 종료되었는지 상태를 확인하는 시스템 콜 함수 */
    int wait (int pid) {
        return process_wait (pid); // 스레드 식별자 TID가 종료될 때까지 기다리고, exit status를 반환하는 process_wait() 함수 호출
    }
    ```
    - WAIT 시스템 콜 함수가 호출되면, 스레드 식별자 TID가 종료될 때까지 기다리고, exit status를 반환하는 process_wait() 함수를 호출한다.<br><br>
- wait() 함수에서 호출되는 process_wait() 함수를 다음과 같이 수정한다.
    ```C
    /* userprog/process.c */
    int process_wait (tid_t child_tid UNUSED) {
        /* XXX: Hint) The pintos exit if process_wait (initd), we recommend you
        * XXX:       to add infinite loop here before
        * XXX:       implementing the process_wait. */

        struct thread *child = get_child_process (child_tid); // 자식 스레드 검색
        
        // 자식 스레드를 찾는데 실패한 경우 -1을 반환
        if (child == NULL)
            return -1;

        sema_down (&child->wait_sema); // 자식이 종료될 때까지 부모는 대기
        list_remove (&child->child_elem); // 자식이 종료되었다는 wait_sema 시그널을 받으면 부모의 자식 리스트에서 자식을 삭제
        sema_up (&child->exit_sema); // 자식 스레드가 종료되고 스케줄링이 이어질 수 있도록 부모에게 시그널 전송

        return child->exit_status; // 자식의 exit_status 반환
    }
    ```
    - 제일 먼저 자식 스레드를 검색한다.
    - 자식 스레드를 찾는데 실패한 경우 -1을 반환한다.
    - 자식 스레드를 찾는데 성공하면, 자식이 종료될 때까지 부모를 대기시킨다.
    - 자식이 종료되었다는 wait_sema 시그널을 받으면 부모의 자식 리스트에서 자식을 삭제 한 후, 다음 스케줄링이 이어질 수 잇도록 부모에게 시그널을 전송한다.
    - 마지막으로, 자식의 종료 상태 값을 반환한다.<br><br>
- 자식이 작업이 종료될 때까지 대기하는 부모가 자식이 작업이 종료되면, 부모를 종료시키는 process_exit() 함수를 다음과 같이 수정한다.
    ```C
    /* userprog/process.c */
    void process_exit (void) {
        struct thread *curr = thread_current ();
        /* TODO: Your code goes here.
        * TODO: Implement process termination message (see
        * TODO: project2/process_termination.html).
        * TODO: We recommend you to implement process resource cleanup here. */

        // 파일 디스크립터 테이블의 모든 파일을 닫고 메모리를 반환
        for (int i = 2; i < FD_COUNT_LIMIT; i++) {
            if (curr->fdt[i] != NULL)
                close (i);
        }

        palloc_free_multiple (curr->fdt, FDT_PAGES);
        file_close (curr->running); // 현재 실행 중인 파일도 닫음

        process_cleanup (); // 프로세스를 클린업
        
        sema_up (&curr->wait_sema); // 자식이 종료될 때까지 대기하고 있는 부모에게 자식이 종료되었다는 시그널 전송
        sema_down (&curr->exit_sema); // 자식이 부모의 시그널을 기다렸다가, 대기가 풀리고 나면 다른 스레드가 실행
    }
    ```
    - 2부터 파일 디스크립터 테이블 인덱스 제한 값인 128까지 순차적으로 검색하면서 모든 파일을 닫고 메모리를 반환한다.
    - 현재 실행 중인 파일도 닫아줘야 한다.
    - 파일을 모두 닫고나면, 프로세스를 클린업한다.
    - 마지막으로 자식이 종료될 때까지 대기하고 있는 부모에게 자식이 종료되었다는 시그널을 전송하고, 부모의 대기가 풀리면 다른 스레드를 실행시킬 수 있도록 한다.

### 파일을 생성하는 CREATE 시스템 콜 함수 구현
- create() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 파일을 생성하는 시스템 콜 함수 */
    bool create (const char *file, unsigned initial_size) {
        check_address (file); // 현재 가리키는 주소가 유저 영역의 주소인지 확인하여, 잘못된 주소이면 프로세스 종료
        return filesys_create (file, initial_size); // 파일 이름(file)과 크기(initial_size)에 해당하는 파일 생성(성공하면 True, 실패하면 False 반환)
    }
    ```
    - CREATE 시스템 콜 함수가 호출되면, 현재 가리키는 주소가 유저 영역의 주소인지 check_address() 함수를 통해 확인한다.
    - 잘못된 주소이면 프로세스가 종료되고, 아니면 파일 이름(file)과 크기(initial_size)에 해당하는 파일을 생성하는 filesys_create() 함수를 호출한다.
    - 파일 생성을 성공하면, True, 실패하면 False를 반환한다.

### 파일을 삭제하는 REMOVE 시스템 콜 함수 구현
- remove() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 파일을 삭제하는 시스템 콜 함수 */
    bool remove (const char *file) {
        check_address (file); // 현재 가리키는 주소가 유저 영역의 주소인지 확인하여, 잘못된 주소이면 프로세스 종료
        return filesys_remove (file); // 파일 이름(file)에 해당하는 파일 삭제
    }
    ```
    - CREATE 시스템 콜 함수와 마찬가지로, check_address() 함수로 주소를 확인한다.
    - 주소가 확인되면, 파일 이름(file)에 해당하는 파일을 삭제하는 filesys_remove 함수를 호출한다.

### 파일을 오픈하는 OPEN 시스템 콜 함수 구현
- open() 함수를 구현하기 전 두 가지 작업을 수행해야 한다.
    - 현재 프로세스의 파일 디스크립터 테이블에 파일을 추가하는 함수를 구현해야 하고, 해당 함수를 구현하기 위한 변수를 추가해야 한다.
        - 추가 변수를 다음과 같이 선언한다.
            ```C
            /* include/threads/thread.h */
            #define FDT_PAGES 2        // 파일 디스크립터 테이블에 할당할 페이지 수
            #define FD_COUNT_LIMIT 128 // 파일 디스크립터 테이블 인덱스 값 제한(최대 128)
            struct file **fdt; // 파일 디스크립터 테이블 변수 선언
            int fd_idx; // 파일 디스크립터 테이블 인덱스 변수 선언
            ```
            - 파일 디스크립터 테이블, 파일 디스크립터 테이블 인덱스, 파일 디스크립터 테이블 페이지 수, 파일 디스크립터 테이블 최대 인덱스 값 변수를 추가 선언한다.<br><br>
        - 현재 프로세스의 파일 디스크립터 테이블에 파일을 추가하는 add_file_to_fdt 함수를 다음과 같이 구현한다.
            ```C
            /* userprog/syscall.c */
            /* 현재 프로세스의 파일 디스크립터 테이블에 파일을 추가하는 함수 */
            int add_file_to_fdt (struct file *file) {
                struct thread *cur = thread_current (); // 현재 스레드 저장
                struct file **fdt = cur->fdt; // 현재 스레드의 파일 디스크립터 테이블 저장

                // FD_COUNT_LIMIT 범위를 넘지 않는 범위 안에서 빈 자리 탐색
                while (cur->fd_idx < FD_COUNT_LIMIT && fdt[cur->fd_idx]) {
                    cur->fd_idx++;
                }

                // 파일 디스크립터 테이블이 가득차서 할당에 실패한 경우 -1 반환
                if (cur->fd_idx >= FD_COUNT_LIMIT)
                    return -1;

                // 할당 가능한 파일 디스크립터 테이블 인덱스 위치를 찾은 경우, 해당 자리에 파일을 할당하고 현재 스레드의 파일 디스크립터 테이블 인덱스 반환
                fdt[cur->fd_idx] = file;
                return cur->fd_idx;
            }
            ```
- open() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 파일을 오픈하는 시스템 콜 함수 */
    int open (const char *file) {
        check_address (file); // 현재 가리키는 주소가 유저 영역의 주소인지 확인하여, 잘못된 주소이면 프로세스 종료
        struct file *open_file = filesys_open (file); // filesys_open() 함수를 이용하여 파일 오픈

        // 파일을 찾지 못하거나 내부 메모리 할당에 실패하여 파일을 열 수 없는 경우 -1 반환
        if (open_file == NULL) {
            return -1;
        }

        int fd = add_file_to_fdt (open_file); // 파일 디스크립터 테이블에 file 추가(성공하면 fd, 실패하면 -1 반환)

        // 파일 디스크립터 테이블에 추가할 수 없는 경우 파일을 닫고 -1 반환
        if (fd == -1) {
            file_close (open_file);
        }

        return fd; // fd 반환
    }
    ```

### fd로 파일을 찾는 FILESIZE 시스템 콜 함수 구현
-  filesize() 함수를 구현하기 전, fd로 파일을 찾는 함수를 먼저 다음과 같이 구현해야 한다.
    ```C
    /* userprog/syscall.c */
    /* fd로 파일을 찾는 함수 */
    static struct file *find_file_by_fd (int fd) {
        struct thread *cur = thread_current (); // 현재 스레드 구조체 저장

        // fd가 0보다 작거나, FD_COUNT_LIMIT를 넘는 경우 NULL 반환
        if (fd < 0 || fd >= FD_COUNT_LIMIT) {
            return NULL;
        }

        return cur->fdt[fd]; // 현재 스레드에 해당하는 fd를 찾은 경우 해당 fd 반환
    }
    ```
- filesize() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 파일 크기를 알려주는 시스템 콜 함수 */
    int filesize (int fd) {
        struct file *open_file = find_file_by_fd (fd); // find_file_by_fd() 함수를 이용하여 파일 디스크립터 테이블에서 열려있는 파일 검색

        // 파일을 찾지 못하거나 내부 메모리 할당에 실패하여 파일을 열 수 없는 경우 -1 반환
        if (open_file == NULL) {
            return -1;
        }

        return file_length (open_file); // file_length() 함수를 이용하여 찾은 파일의 크기를 bytes 단위로 반환
    }
    ```

### 열린 파일의 데이터를 읽는 READ 시스템 콜 함수
- 열린 파일의 데이터를 읽고 버퍼에 저장하는 과정에서 다른 파일의 접근을 막기 위한 lock 선언 및 초기화 한다.
    ```C
    /* include/userprog/syscall.h */
    struct lock filesys_lock; // 열린 파일의 데이터를 읽고 버퍼에 저장하는 과정에서 다른 파일의 접근을 막기 위해 lock 선언
    ```
    ```C
    /* userprog/syscall.c */
    void syscall_init (void) {
        . . .

        lock_init(&filesys_lock); // 열린 파일의 데이터를 읽고 버퍼에 저장하는 과정에서 다른 파일의 접근을 막기 위해 lock 초기화
    }
    ```
- read() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일의 데이터를 읽는 시스템 콜 함수 */
    int read (int fd, void *buffer, unsigned size) {
        check_address (buffer); // 인자로 받은 버퍼 포인터 주소 확인

        off_t read_byte;
        uint8_t *read_buffer = buffer;

        // fd가 0인 경우(=STDIN) 키보드로부터 입력을 받아오는 input_getc 함수를 호출해 size만큼 값 read
        if (fd == 0) {
            char key;
            for (read_byte = 0; read_byte < size; read_byte++) {
                key = input_getc ();
                *read_buffer++ = key;
                if (key == '\0') {
                    break;
                }
            }
        }

        // fd가 1인 경우(=STDOUT) -1 반환
        else if (fd == 1)
        {
            return -1;
        }

        // fd가 2 이상인 경우(=정상 fd) find_file_by_fd() 함수를 호출해 fd에 해당하는 파일 검색
        else
        {
            struct file *read_file = find_file_by_fd (fd); // fd로 열린 파일 검색

            // 열린 파일을 찾지 못하면, -1 반환
            if (read_file == NULL)
            {
                return -1;
            }

            lock_acquire (&filesys_lock); // 열린 파일의 데이터를 읽고 버퍼에 저장하는 과정에서 다른 파일의 접근을 막기 위해 lock 획득
            read_byte = file_read (read_file, buffer, size); // 파일에서 현재 위치부터 size 바이트 만큼 데이터를 읽어서 버퍼에 저장하는 file_read() 함수 호출
            lock_release (&filesys_lock); // 열린 파일의 데이터를 읽고 버퍼에 저장을 완료하면 lock 해제
        }
        return read_byte;
    }
    ```

### 열린 파일의 데이터를 기록하는 WRITE 시스템 콜 함수
- 전에 임시로 구현했던, write() 함수를 다음과 같이 다시 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일의 데이터를 기록하는 시스템 콜 함수 */
    int write (int fd, const void *buffer, unsigned size) {
        check_address (buffer); // 인자로 받은 버퍼 포인터 주소 확인

        int bytes_write = 0;

        // fd가 1인 경우(=STDOUT) 버퍼에 저장된 데이터를 화면에 출력하는 putbuf() 함수를 호출
        if (fd == 1) {
            putbuf (buffer, size);
            bytes_write = size;
        }

        else {
            // fdrk 0인 경우(STDIN) -1 반환
            if (fd < 2) {
                return -1;
            }

            struct file *file = find_file_by_fd (fd); // fd로 열린 파일 검색

            // 열린 파일을 찾지 못 한 경우 -1 반환
            if (file == NULL) {
                return -1;
            }

            lock_acquire (&filesys_lock); // 열린 파일의 데이터를 기록하는 과정에서 다른 파일의 접근을 막기 위해 lock 획득
            bytes_write = file_write (file, buffer, size); // 파일에서 현재 위치부터 size 바이트 만큼 버퍼에 있는 데이터를 기록
            lock_release (&filesys_lock); // 열린 파일의 데이터 기록을 완료하면 lock 해제
        }
        return bytes_write;
    }
    ```

### 열린 파일의 위치(offset)를 이동하는 SEEK 시스템 콜 함수
- seek() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일의 위치(offset)를 이동하는 시스템 콜 함수 */
    void seek (int fd, unsigned position) {
        struct file *seek_file = find_file_by_fd (fd); // fd를 이용하여 열린 파일 검색

        // 찾은 파일의 fd값이 2보다 작은 경우 리턴
        if (seek_file <= 2) {
            return;
        }

        return file_seek (seek_file, position); // 열린 파일을 찾았다면, file_seek() 함수를 이용하여 열린 파일의 위치를 position만큼 이동
    }
    ```

### 열린 파일의 위치(offset)를 알려주는 TELL 시스템 콜 함수
- tell() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일의 위치(offset)를 알려주는 시스템 콜 함수 */
    unsigned tell (int fd) {
        struct file *tell_file = find_file_by_fd (fd); // fd를 이용하여 열린 파일 검색

        // 찾은 파일의 fd값이 2보다 작은 경우 리턴
        if (tell_file <= 2) {
            return;
        }

        return file_tell (tell_file); // 열린 파일을 찾았다면, file_tell() 함수를 이용하여 파일의 위치를 반환
    }
    ```

### 열린 파일을 닫는 CLOSE 시스템 콜 함수
- close() 함수를 구현하기 전에 파일 디스크립터 테이블에서 현재 스레드를 제거하는 remove_file_from_fdt() 함수를 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 파일 디스크립터 테이블에서 현재 스레드를 제거하는 함수 */
    void remove_file_from_fdt (int fd) {
        struct thread *cur = thread_current (); // 현재 스레드 저장

        // 파일 디스크립터 테이블에서 0보다 작지 않고, 인덱스 제한 값보다 같거나 큰 경우 리턴
        if (fd < 0 || fd >= FD_COUNT_LIMIT) {
            return;
        }

        cur->fdt[fd] = NULL; // 현재 스레드를 찾은 경우 현재 스레드 파일 디스크립터 테이블에 NULL 할당
    }
    ```
- close() 함수를 다음과 같이 구현한다.
    ```C
    /* userprog/syscall.c */
    /* 열린 파일을 닫는 시스템 콜 함수 */
    void close (int fd) {
        struct file *close_file = find_file_by_fd (fd); // fd를 이용하여 열린 파일 검색

        // 파일을 찾는데 실패한 경우 리턴
        if (close_file == NULL) {
            return;
        }

        file_close (close_file); // file_close()로 파일 닫기
        remove_file_from_fdt (fd); // remove_file_from_fdt() 함수를 이용하여 닫은 파일 삭제
    }
    ```

### 과제 ALL PASS를 통과하기 위한 추가 과정
1. 현재 실행 중인 파일을 수정하는 일이 발생하는 것을 방지하기 위해 실행 중인 파일에 대한 쓰기 작업을 거부하는 코드 추가
    ```C
    /* userprog/process.c */
    static bool load (const char *file_name, struct intr_frame *if_) {
        . . .

        t->running = file; // 현재 스레드의 실행중인 파일 저장
        file_deny_write(file); // 현재 실행 중인 파일을 수정하는 일이 발생하는 것을 방지하기 위해 실행 중인 파일에 대한 쓰기 작업을 거부하는 file_deny_write() 함수 호출

        . . .
    }
    ```  
2. file_close()를 호출하여 작업을 수행하면 파일이 닫히면서 lock이 풀리므로, 이를 방지하기 위해 주석 처리
    ```C
    /* userprog/process.c */
    static bool load (const char *file_name, struct intr_frame *if_) {
        . . .

        // file_close (file); // file_close()를 호출하여 작업을 수행하면 파일이 닫히면서 lock이 풀리므로, 이를 방지하기 위해 주석 처리

        . . .
    }
    ```  
3. Page fault 에러가 발생했을 때 -1을 반환하고 프로세스를 종료할 수 있도록 코드 추가
    ```C
    static void page_fault (struct intr_frame *f) {
        . . .

        exit(-1); // Page fault 에러가 발생했을 때 -1을 반환하고 프로세스를 종료

        . . .
    }
    ```

### System Call 구현 트러블 슈팅
1. HALT, EXIT 시스템 콜 함수 구현 후, 테스트 실패 발생
    - Argument Stack을 구현하는 과정에서 인자의 개수와 argv 시작 주소를 각각 rdi와 rsi에 저장

### System Call 구현 결과
```
All 95 tests passed.
```
```
TOTAL TESTING SCORE: 100.0%
ALL TESTED PASSED -- PERFECT SCORE

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

SUMMARY BY TEST SET

Test Set                                      Pts Max  % Ttl  % Max
--------------------------------------------- --- --- ------ ------
tests/threads/Rubric.alarm                      7/  7   2.0%/  2.0%
tests/threads/Rubric.priority                  25/ 25   3.0%/  3.0%
tests/userprog/Rubric.functionality            40/ 40  40.0%/ 40.0%
tests/userprog/Rubric.robustness               40/ 40  30.0%/ 30.0%
tests/userprog/no-vm/Rubric                     3/  3  10.0%/ 10.0%
tests/filesys/base/Rubric                      17/ 17  15.0%/ 15.0%
--------------------------------------------- --- --- ------ ------
Total                                                 100.0%/100.0%

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
```

핀토스 프로젝트2 끝!!!!!!!!!!!!!!!!🫡