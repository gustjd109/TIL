# 03 명령어

## 1. 소스 코드와 명령어
1. 고급 언어(high-level programming language)와 저급 언어(low-level programming language)
    - 고급 언어와 저급 언어
        - 고급 언어 : 컴퓨터가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어
        - 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
            - 저급 언어 종류
                - 기계어(machine code) : 0과 1의 명령어 비트로 이루어진 언어 = 0과 1로 이루어진 명령어 모음
                - 어셈블리어(assembly language) : 기계어를 읽기 편한 형태로 번역한 언어<br><br>

2. 컴파일 언어(compile language)와 인터프리터 언어(interpreter language)
    - 컴파일 : 컴파일 언어로 작성된 소스코드가 저급 언어로 변환되는 과정
        - 컴파일 언어 : 컴파일러에 의해  소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어(C)
        - 컴파일러(compiler) : 컴파일을 수행해 주는 도구
        - 목적 코드(object code) : 컴파일러를 통해 저급 언어로 변환된 코드
    - 인터프리터 : 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
        - 인터프리터 언어 : 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어(Python)
    - 컴파일러와 인터프리터의 차이
        - 컴파일
            - 개발자가 작성한 소스 코드 전체를 확인하여 실행
            - 오류가 발생 시 컴파일 실패
        - 인터프리터
            - 개발자가 작성한 소스 코드를 한 줄씩 확인하여 실행
            - 오류 발생 시 오류 발생 전까지의 코드가 실행
            - 소스 코드 전체를 저급 언어로 변환하는 시간이 적음<br><br>

3. 목적 파일과 실행 파일
    - 목적 파일 : 목적 코드로 이루어진 파일
        - 목적 파일을 만드는 것 까지가 컴파일
    - 실행 파일 : 실행 코드로 이루어진 파일
        - 윈도우의 .exe 확장자를 가진 파일
    - 링킹(linking) : 개별 목적 파일을 하나로 묶어서 실행 파일로 만드는 과정<br><br>

## 2. 명령어의 구조
1. 연산 코드(operation code)와 오퍼랜드(operand)
    - 명령어 : 연산 코드와 오퍼랜드로 구성
    - 연산 코드 : 명령어가 수행할 연산 = 연산자
        - 연산 코드 필드 : 연산 코드가 담기는 영역
        - 연산 코드 종류
            - 데이터 전송
                - MOVE : 데이터를 옮겨라
                - STORE : 메모리에 저장하라
                - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
                - PUSH : 스택에 데이터를 저장하라
                - POP : 스택의 최상단 데이터를 가져와라
            - 산술 / 논리 연산
                - ADD / SUBSTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
                - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
                - AND / OR / NOT : AND / OR / NOT 연산을 수행하라
                - COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
            - 제어 흐름 변경
                - JUMP : 특정 주소로 실행 순서를 옮겨라
                - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
                - HALT : 프로그램의 실행을 멈춰라
                - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 = 함수 호출
                - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라 = 함수 리턴
            - 입출력 제어
                - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
                - WRITE(OUTPUT) : 트정 입출력 장치로 데이터를 써라
                - START IO : 입출력 장치를 시작하라
                - TEST IO : 입출력 장치의 상태르 확인하라
    - 오퍼랜드 : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치(메모리, 레지스터 주소 = 주소 필드) = 피연산자
        - 오퍼랜드 필드 : 오퍼랜드가 담기는 영역
        - 오퍼랜드 개수에 따른 명령어
            - 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
            - 1-주소 명령어 : 오퍼랜드가 하나인 명령어
            - 2-주소 명령어 : 오퍼랜드가 두개인 명령어
            - 3-주소 명령어 : 오퍼랜드가 세개인 명령어<br><br>

2. 주소 지정 방식
    - 오퍼랜드 필드에 메모리나 레지스터 주소를 담는 이유
        - 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀만큼의 길이로 연산 코드가 커지는만큼 오퍼랜드 필드의 크기가 작아짐
        - 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지기 때문임
    - 유효 주소(effective address) : 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치 = 오퍼랜드 필드의 데이터가 저장된 위치
    - 주소 지정 방식(addressing mode) : 연산에 사용할 데이터 위치를 찾는 방법 = 유효 주소를 찾는 방법
        - 주소 지정 방식 종류
            - 즉시 주소 지정 방식(immediate addressing mode)
                - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
                - 표현할 수 있는 데이터의 크기가 작아짐
                - 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 다른 방식보다 빠름
            - 직접 주소 지정 방식(direct addressing mode)
                - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
                - 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생김
            - 간접 주소 지정 방식(indirect addressing mode)
                - 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
                - 두 번의 메모리 접근이 필요하여 즉시와 직접 주소 지정 방식보다 느림
            - 레지스터 주소 지정 방식(register addressing mode)
                - 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식
                - CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
                - 직접 주소 지정 방식과 마찬가지로 표현할 수 있는 레지스터 크기에 제한이 생김
            - 레지스터 간접 주소 지정 방식(register direct addressing mode)
                - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식
                - 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한번
                - 레지스터에 접근하기 때문에 간접 주소 지정 방식보다 빠름