# 04 CPU의 작동 원리

## 1. ALU와 제어장치
1. ALU
    - ALU가 받는 정보
        - 레지스터를 통해 피연산자를, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들여 연산을 수행
    - ALU가 내보내는 정보
        - 결괏값 : 연산을 수행한 결괏값은 메모리에 저장하지 않고 일시적으로 레지스트에 저장
            - 결괏값을 레지스터에 저장하는 이유
                - CPU가 메모리에 접근하는 속도 < 레지스터에 접근하는 속도
                - ALU가 연산할 때마다 결과를 메모리에 저장 → CPU가 메모리에 자주 접근 → CPU 프로그램 실행 속도 ↓
        - 플래그(flag) : 연산 결과에 대한 추가적인 상태 정보로, 플래그 레지스터에 저장
            - 플래그 종류
                | 플래그 종류 | 의미 | 사용 예시 |
                |:--------:|:--------:|:--------:|
                | 부호 플래그 | 연산한 결과의 부호 | 1일 경우 계산 결과는 음수, 0일 양수 |
                | 제로 플래그 | 연산 결과가 0인지 여부 | 1일 경우 연산 결과는 0, 0일 경우 0이 아님 |
                | 캐리 플래그 | 연산 결과 올림수나 빌림수 발생 여부 | 1일 경우 올림수나 빌림수가 발생, 0일 경우 발생하지 않음 |
                | 오버플로우 플래그 | 오버플로우 발생 여부 | 1일 경우 오버플로우 발생, 0일 경우 발생하지 않음 |
                | 인터럽트 플래그 | 인터럽트가 가능한지 여부 | 1일 경우 인터럽트 가능, 0일 경우 불가능 |
                | 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 여부 | 1일 경우 커널 모드로 실행 중, 0일 경우 사용자 모드로 실행 중 |<br><br>

2. 제어장치
    - 제어장치가 받는 정보
        - 클럭 신호 : 클럭의 주기에 맞춰 레지스터 간의 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들이는 등의 작업 수행
            - 클럭(clock) : 컴퓨터의 모든 부품을 움직일 수 있게 하는 단위
        - 해석해야할 명령어 : 명령어 레지스터로부터 해석할 명령어를 받아 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행할 내용을 알림
        - 플래그 값 : 받은 값을 참고하여 제어 신호를 발생
        - 시스템 버스(그중에서 제어 버스로 전달된 제어 신호) : 제어 버스를 통해 외부로부터 전달된 제어 신호를 받음
    - 제어장치가 내보내는 정보
        - CPU 외부에 전달하는 제어 신호 : 제어 버스로 제어 신호를 내보낸다는 의미
            - 메모리에 전달하는 제어 신호 : 메모리에 저장된 값을 읽거나 새로운 값을 쓰고 싶을 때 메모리로 제어 신호를 보냄
            - 입출력장치(보조기억장치)에 전달하는 제어 신호 : 입출력장치의 값을 읽거나 새로운 값을 쓰고 싶을 때 입출력장치로 제어 신호를 보냄
        - CPU 내부에 전달하는 제어 신호
            - ALU에 전달하는 제어 신호 : ALU에 수행할 연산 지시를 위해 제어 신호를 보냄
            - 레지스터에 전달하는 제어 신호 : 레지스터에 레지스터 간 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 보냄<br><br>

## 2. 레지스터
1. 레지스터 종류
    - 프로그램 카운터(PC, Program Counter)
        - 메모리에서 읽어 들일 명령어의 주소를 저장하는 레지스터 = 명령어 포인터(IP, Instruction Pointer)
    - 명령어 레지스터(IR, Instruction Register)
        - 메모리에서 읽어 들인 명령어를 저장하는 레지스터
    - 메모리 주소 레지스터(MAR, Memory Address Register)
        - 메모리의 주소를 저장하는 레지스터
        - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침
    - 메모리 버퍼 레지스터(MBR, Memory Buffer Register)
        - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터 = 메모리 데이터 레지스터(MDR, Memory Data Register)
        - 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침
        - CPU가 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침
    - 범용 레지스터(GPR, General Purpose Register)
        - 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터로 데이터와 주소를 모두 저장하는 레지스터
    - 플래그 레지스터(FR, Flag Register)
        - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
    - 스택 포인터(SP, Stack Pointer)
        - 스택 주소 지정 방식에 사용되는 레지스터로, 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
        - 스택은 메모리 안에 스택처럼 사용할 영역인 스택 영역에서 사용
    - 베이스 레지스터(BR, Base Register)
        - 베이스 레지스터 주소 지정 방식에 사용되는 레지스터로, 기준 주소가 저장되는 레지스터<br><br>

2. 메모리에 저장된 프로그램을 실행하는 과정
    - CPU로 실행할 프로그램이 1000 ~ 1500번지까지 저장되어 있고, 1000번지에는 1101₂이 저장되어 있다고 가정
        - 프로그램 카운터에 1000이 저장 : 메모리에서 가져올 명령어가 1000번지에 있다는 의미
        - 메모리 주소 레지스터에 1000이 저장 : 1000번지를 읽어들이기 위해 주소 버스로 1000번지를 내보내야 함
        - '메모리 읽기' 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐
        - 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달
            - 프로그램 카운터가 1000에서 1001로 증가되어 다음 명령어를 읽어 들일 준비를 함
        - 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동 → 여기까지가 인출 사이클 과정
        - 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생
        - 위 과정을 반복하면서 CPU는 프로그램을 차례대로 실행<br><br>

## 3. 명령어 사이클과 인터럽트
1. 명령어 사이클(instruction cycle)
    - 하나의 명령어가 처리되는 주기로, 인출 / 실행 / 간접 / 인터럽트 사이클로 구성
    - 인출 / 실행 / 간접 / 인터럽트 사이클
        - 인출 사이클(fetch cycle) : 메모리에서 실행할 명령어를 CPU로 가져오는 과정
        - 실행 사이클(execution cycle) : CPU로 가져온 명령어를 실행하는 과정
            - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생
        - 간접 사이클(indirect cycle) : 피연산자의 실제 주소를 찾기 위해 메모리 내의 데이터를 한 번 더 인출하는 과정
            - 예 : 간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시하기 때문에 명령어를 인출하여 CPU로 가져왔더라도 바로 실행 사이클에 돌입할 수 없어 명령어를 실행하기 위해 메모리 접근이 한 번 더 필요<br><br>

2. 인터럽트(interrupt)
    - 인터럽트란?
        - CPU의 정상적인 작업을 방해하는 신호
    - 인터럽트 종류
        - 동기 인터럽트(synchronous interrupts) = 예외(exception)
            - CPU에 의해 발생하는 인터럽트
            - CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
            - 예외의 종류
                - 폴트(fault) : 예외를 처리한 직후 예외가 발행한 명령어로부터 실행을 재개하는 예외
                - 트랩(trap) : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외(주로 디버깅할 때 사용)
                - 중단(abort) : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
                - 소프트웨어 인터럽트(software interrupt) : 시스템 호출이 발생했을 때 나타나는 예외
        - 비동기 인터럽트(asynchronous interrupts) = 하드웨어 인터럽트(hardware interrupt)
            - 입출력장치에 의해 발생하는 인터럽트
            - 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림을 보내는 것과 같은 알림을 발생하는 인터럽트
            - 인터럽트 플래그로 막을 수 있는 인터럽트(maskable interrupt)와 막을 수 없는 인터럽트(non maskable interrupt)로 구분
                - 막을 수 없는 인터럽트의 예 : 정전이나 하드웨어 고장으로 인한 인터럽트 등
    - 하드웨어 인터럽트 처리 순서
        - 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
            - 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트에 대한 요청
        - CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
        - CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
            - 인터럽트 플래그(interrupt flag) : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
        - 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
        - CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
            - 인터럽트 서비스 루틴(ISR, Interrupt Service Routine) : 인터럽트를 처리하는 프로그램으로, 인터럽트 핸들러(interrupt handler)라고도 부름
            - 인터럽트 벡터(interrupt vector) : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보, CPU가 수많은 인터럽트 서비스 루틴을 구분하기 위해 이용
        - 인터럽트 서비스 루틴 실행이 끝나면, 백업해 둔 작업을 복구하여 실행을 재개
    - 'CPU가 인터럽트를 처리한다'라는 말의 의미
        - '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다'라는 의미
        - CPU가 작업 수행 도중 인터럽트가 발생한 경우 처리 과정
            - 정상적으로 작업 진행
            - 인터럽트 발생
            - 인터럽트 서비스 루틴으로 점프
            - 인터럽트 서비스 루틴 실행
            - 기존 작업으로 점프
            - 기존 작업 수행 재개