# 05 CPU 성능 향상 기법

## 1. 빠른 CPU를 위한 설계 기법
1. 클럭(clock)
    - 클럭 속도를 높이면 CPU를 빠르게 만들지만, 클럭 속도만으로 CPU의 성능을 올리기에는 한계가 있음
        - 클럭 속도 : 헤르츠(Hz) 단위로 측정하며, 1초에 클럭이 몇 번 반복되는지를 나타냄
    - CPU는 계속 일정한 클럭 속도를 유지하기보다는 고성능을 요하는 순간에는 순간적으로 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮춤
        - 오버클럭킹(overclocking) : 최대 클럭 속도를 강제로 올리기 위해 사용하는 기법<br><br>

2. 코어(core)와 멀티코어(multicore)
    - 코어 : CPU 내에서 명령어를 실행하는 부품으로, 여러 개 있을 수 있음
    - 멀티코어 : 코어를 여러 개 포함하고 있는 CPU = 멀티 프로세서(multiprocessor)
    - 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않아 코어마다 처리할 명령어들을 얼마나 적절히 분배하느냐가 중요<br><br>

3. 스레드(thread)와 멀티스레드(multithread)
    - 스레드 : 사전적 의미로, 실행 흐름의 단위
    - 스레드의 구분
        - CPU에서 사용되는 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
        - 프로그램에서 서용되는 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위
    - 멀티스레드 프로세스(multithread processor) : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU = 멀티스레드 CPU
        - 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터 여러 개가 필요
        - 하이퍼스레딩(hyper-threading) : 인텔의 멀티스레드 기술<br><br>

## 2. 명령어 병렬 처리 기법
1. 명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)이란?
    - 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법<br><br>

2. 명령어 병렬 처리 기법 종류
    - 명령어 파이프라이닝(instruction pipelining) : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
        - 명령어 파이프라인(instruction pipeline) : 명령어 처리 과정을 클럭 단위로 나눠서 병렬처리 하는 기법
            - 명령어 인출(Instruction Fetch)
            - 명령어 해석(Instruction Decode)
            - 명령어 실행(Execute Instruction)
            - 결과 저장(write Back)
        - 파이프라이닝이 높은 성능을 가져오지만, 성능 향상에 실패하는 경우도 있으며, 이를 파이프라인 위험(pipeline hazard)이라고 함
            - 파이프라인 위험 종류
                - 데이터 위험(data hazard) : 명령어 간 '데이터 의존성'에 의해 발생
                    - 어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우
                - 제어 위험(control hazard) : 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생
                    - 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑자기 변화가 생겨 명령어 파이프라인에서 처리 중이었던 명령어들이 쓸모 없어진 경우
                    - 분기 예측(branch prediction) : 제어 위험을 방지하기 위해 사용하는 기술로, 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술
                - 구조적 위험(structual hazard) : 명령어들을 겹처 실행하는 과정에서 서로 다른 명령어가 동시에 CPU 부품을 사용하려고 할 때 발생 = 자원 위험(resource hazard)
    - 슈퍼스칼라(superscalar) : CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
        - 슈퍼스칼라 프로세서 / CPU : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
            - 매 클럭 주기마다 동시에 여러 명령어를 인출 및 실행할 수도 있어야 함
            - 이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 파이프라인 위험 등으로 인해 반드시 그렇지는 않아 이를 방지하기 위해 고도로 설계되야 함
    - 비순차적 명령어 처리(OoOE, Out-of-Order Execution) : 파이프라인의 중단을 방지하기 위해 명령어들을 순차적으로 실행하지 않는 기법<br><br>

## 3. CISC와 RISC
1. 명령어 집합
    - 명령어 집합(instruction set) : CPU가 이해할 수 있는 명령어들의 모음 = 명령어 집합 구조(ISA, Instruction Set Architecture)
        - 같은 소스 코드로 만들어진 같은 프로그램이라도 ISA가 다르면 CPU가 이해할 수 있는 명령어와 어셈블리어도 달라짐<br><br>

2. CISC(Complex Instruction Set Computer)
    - CISC란?
        - 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식
        - 대표적인 CISC 기반의 ISA : x86, x86-64
    - CISC 특징
        - 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 사용
            - 즉, 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것 → 컴파일된 프로그램의 크기가 작다는 것
            - 이로 인해, 메모리 공간을 절약할 수 있음
        - 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하여 멸령어의 크기와 실행되기까지의 시간이 일정하지 않음
        - 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기가 필요 → 명령어 파이프라인을 구현하는 데에 큰 걸림돌이 됨<br><br>

3. RISC(Reduced Instruction Set Computer)
    - RISC란?
        - CISC의 한계를 해결하기 위해 나온 CPU 설계 방식
    - RISC 특징
        - CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향하며, 고정 길이 명령어를 사용 → 명령어 파이프라이닝에 최적화
        - 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구 → CISC보다 주소 지정 방식의 종류가 적음
        - 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용
            - CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많음
            - 사용 가능한 명령어 개수가 CISC보다 적기 때문에 CISC보다 많은 명령으로 프로그램을 작동시킴