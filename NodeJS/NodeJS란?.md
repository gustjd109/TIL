# NodeJS란?

## 1. NodeJS 소개
1. NodeJS 소개
    - Node.js는 서버 측 자바스크립트 런타임 환경이다.
    - 브라우저 밖에서 자바스크립트를 사용하는 V8엔진을 사용한다.
    - 비동기 API를 제공한다.
        - Node.js 이전에는 논블로킹/비동기 API를 서버 환경에 구현하는 데 상당한 노고가 필요했다.
        - 동시 실행되는 스레드와 공유 자원을 프로그래머가 직접 만들과 관리해야 했기 때문이다.
        - 이런 개발 환경을 '논블로킹 감옥'이라고 한다.
    - npm이라는 패키지 매니저를 제공한다.
    - 라이언 달은 현제 디노(Deno)라는 타입스크립트 기반 서버 런타임 환경을 개발했다.
        - Node를 No와 de로 잘라서 순서를 바꾸면 Deno가 된다.
        - Deno는 나중에 따로 알아보기~!

## 2. Ndoe.js는 서버에서 어떻게 자바스크립트를 실행할까?
1. Ndoe.js는 서버에서 어떻게 자바스크립트를 실행할까?
    - Node.js는 V8 자바스크립트 엔진과 Libuv 및 C/C++에 의존성을 가진 자바스크립트 런타임이다.
        - 런타임 : 자바스크립트로 된 프로그램을 실행할 수 있는 프로그램이다.<br><br>
2. Node.js의 구성요소
    - Node.js의 소스 코드는 C++와 자바스크립트, 파이썬(빌드와 테스트에만 사용) 등으로 이루어져 있다.
    - Node.js의 계층 구조
        - 1계층 : Node.js 애플리케이션 → JS
            - 사용자 코드(자바스크립트)는 Node.js의 API를 사용한다.
        - 2계층 : Node.js API(http, fs, crypto, buffer...) → JS
            - Node.js API는 C++에 바인딩 되어 있는 소스이거나 직접만든 C++ 애드온을 호출한다.
        - 3계층 : Node.js 바인딩, Node.js 표준라이브러리, C++ 애드온 → JS, C++
            - C++에서는 V8을 사용해 자바스크립트를 해석(JIT 컴파일러) 및 최적화하고, 어떤 코드냐에 따라 C/C++ 종속성이 있는 코드를 실행한다.
            - Node.js 바인딩 : 자바스크립트에서 C/C++ 함수를 호출할 수 있게 해준다.
            - Node.js 표준라이브러리(C++) : 타이머(setTimeout), 파일시스템(filesystem), 네트워크 요청(HTTP) 등 운영체제와 관련된 함수가 있다.
            - C++ 애드온 : Node.js에서 C/C++ 소스를 실행할 수 있게 해준다.
        - 4계층 : V8, libuv → C, C++
            - V8(C++) : 오픈 소스 자바스크립트 엔진으로, 자바스크립트 파싱, 인터프리터, 컴파일, 최적화에 사용된다.
            - libuv(C++) : 비동기 I/O에 초점을 맞춘 멀티플랫폼을 지원하는 라이브러리, 이벤트 루프, 스레드 풀 등을 사용한다.
        - 5계층 : C-Ares, HTTP 파서, OpenSSL, zlib → C, C++
            - DNS, HTTP 파서, OpenSSL, zlib 이외의 C/C++ 코드들은 libuv의 API를 사용해 해당 운영체제에 알맞는 API를 사용한다.
        - 6계층 : 운영체제
    - Node.js는 각 계층이 각 하단에 있는 API를 사용하는 계층의 집합으로 설계되어 있다.<br><br>
3. 자바스크립트 실행을 위한 V8 엔진
    - V8이란?
        - V8은 C++로 만든 오픈 소스 자바스크립트 엔진이다.
            - 엔진 : 사용자가 작성한 코드를 실행하는 프로그램이다.
            - 엔진은 파서, 컴파일러, 인터프리터, 가비지 컬렉터, 콜 스택, 힙으로 구성되어 있다.
                - 가비지 컬렉터(garbage collector) : 메모리 누수를 방지하기 위해 주기적으로 사용하지 않는 메모리 공간을 회수하는 기능이다.
                - 콜 스택(call stack) : 현재 실행 중인 서브 루틴에 관한 정보를 저장하는 스택이다.
                - 힙(heap) : 객체나 동적 데이터가 저장되는 메모리 공간이다.
        - V8은 자바스크립트를 실행할 수 있는 엔진이며, 인터프리터 역할을 하는 이그니션과 컴파일러 역할을 하는 터보팬을 사용해 컴파일한다.<br><br>
    - V8 엔진의 자바스크립트 코드 컴파일 단계
        - 자바스크립트 코드 : 자바스크립트 코드는 파서에 전달한다.
        - 파서 : 전달된 자바스크립트 코드를 추장 구문 트리로 만든다.
        - AST(추상 구문 트리) : 만들어진 추상 구문 트리를 이그니션 인터프리터에 전달한다.
        - 이그니션 : 추상 구문 트리를 바이트 코드로 만들고, 최적화가 필요한 경우 터보팬으로 전달한다.
        - 터보팬 : 최적화가 필요한 추상 구문 트리를 컴파일 과정을 걸쳐서 바이너리 코드로 만든다.
            - 최적화가 잘 안 된 경우는 다시 최적화를 해제하고, 이그니션의 인터프리터 기능을 사용한다.<br><br>
    - JIT(just-in time)
        - 인터프리터와 컴파일러의 장점을 동시에 가지고 있는 컴파일러이다.
        - 속도가 빠르며, 적재적소에 최적화할 수 있다는 장점이 있다.
        - 컴파일러와 인터프리터가 동시에 실행되어 메모리를 더 많이 쓴다는 단점이 있다.<br><br>
    - 이그니션과 터보팬 특징 비교
        - 이그니션
            - 매우 빠른 초기화
            - 매우 컴팩트한 바이트 코드 생성
            - 자주 실행되지 않는 코드에 적합
        - 터보팬
            - 매우 빠른 기계어 생성
            - 최적화 제공
            - 자주 실행되는 코드에 적합<br><br>
4. 이벤트 루프와 운영체제 단 비동기 API 및 스레드 풀을 지원하는 libuv
    - libuv라는 C++ 라이브러리를 사용하여 자바스크립트에 없는 HTTP, 파일, 소켓 통신 IO 기능 등을 제공한다.
        - libuv : 비동기 입출력, 이벤트 기반에 초점을 맞춘 라이브러리이다.
    - 자바스크립트 언어에서 C++ 코드를 실행할 수 있게 해두었고, 자바스크립트로 C++ 코드를 감싸서 사용하는 방식이며, 이를 C++ 바인딩이라고 한다.
    - libuv는 다양한 플랫폼에서 사용할 수 있는 이벤트 루프를 제공한다.
        - 리눅스는 epoll, 윈도우는 IOCP, 맥OS는 kqueue, SunOS는 이벤트 포트를 제공한다.
    - 네트워크, 파일 IO, DNS, 스레드 풀 기능을 제공한다.<br><br>
5. Node.js 애플리케이션의 코드는 어떻게 실행되는가?
    - 애플리케이션에서 요청이 발생한다.
        - V8 엔진은 자바스크립트 코드로 된 요청을 바이트 코드나 기계어로 변경한다.
    - 자바스크립트로 작성된 Node.js의 API는 C++로 작성된 코드를 사용한다.
    - V8 엔진은 이벤트 루프로 libuv를 사용하고, 전달된 요청을 libuv 내부의 이벤트 큐에 추가한다.
    - 이벤트 큐에 쌓인 요청은 이벤트 루프에 전달되고, 운영체제 커널에 비동기 처리를 맡긴다.
        - 운영체제 내부적으로 비동기 처리가 힘든 경우(DB, DNS 룩업, 파일 처리 등)는 워커 스레드에서 처리한다.
    - 운영체제의 커널 또는 워커 스레드가 완료한 작업은 다시 이벤트 루프로 전달된다.
    - 이벤트 루프에서는 콜백으로 전달된 요청에 대한 완료 처리를 하고 넘긴다.
    - 완료 처리된 응답을 Node.js 애플리케이션으로 전달한다.

## 3. Node.js의 기술적인 특징
1. 싱글 스레드
    - 자바스크립트 엔진(V8) 은 자바스크립트를 실행하는 힙과 콜 스택을 가지고 있으며, 싱글 스레드로 실행된다.
        - 싱글 스레드라는 말은 콜 스택이 하나만 있다는 의미이다.
        - 따라서, 한 번에 하나의 작업만 가능하다.<br><br>
2. 이벤트 기반 아키텍처
    - 싱글 스레드인 자바스크립트의 한계
        - 한 번에 하나를 처리하는 서버에 0.1초가 걸리는 요청이 동시에 100개가 온다면, 마지막에 요청한 사람은 10초를 기다려야 응답을 받을 수 있다.
        - 멀티 스레드를 지원하는 언어라면, 스레드를 100개 만들어서 동시에 처리할 수 있지만 싱글 스레드인 자바스크립트는 그렇게 할 수 없다.
        - 이벤트 기반 아키텍러를 적용하여 콜 스택에 쌓인 작업을 다른 곳에서 처리한 다음 처리가 완료되었을 때 알림을 받으면 스레드가 하나라도 빠르게 처리할 수 있어 위 문제를 해결할 수 있다.<br><br>
    - 커피숍 예를 통한 이벤트 기반 아키텍처 이해
        - 커피숍의 카운터에서 주문을 완료하면 주문은 제조를 하는 직원에게 건네진다.
        - 카운터는 커피가 나올 때까지 기다리지 않고 다음 고객의 주문을 받는다.
        - 진동벨을 받은 고객은 진동벨이 울릴 때까지 기다렸다가 울리면 주문한 음료를 받아간다.
        - 이때 줄을 섰던 순서와는 다르게 빠르게 제조된 음료가 먼저 나올 수 있다.<br><br>
    - Node.js에서는 동시 요청을 어떻게 처리하는가?
        - 자바스크립트 코드는 V8의 콜 스택에 쌓이고 I/O 처리가 필요한 코드는 이벤트 루프로 보내게 된다.
        - 이벤트 루프에서는 말그대로 루프를 실행하면서 운영체제 또는 스레드 워커에 I/O 처리를 맡기게 된다.
        - 스레드 워커와 운영체제는 받은 요청에 대한 결과를 이벤트 루프로 돌려준다.
        - 이벤트 루프에서는 결괏값에 대한 코드를 콜 스택에 다시 추가한다.<br><br>
3. 이벤트 루프
    - Node.js에서는 이벤트 기반 아키텍처를 구축하는 데 반응자 패턴(reactor pattern)을 사용한다.
        - 반응자 패턴 : 이벤트 디멀티플렉서와 이벤트 큐로 구성되고, 이벤트를 추가하는 주체와 해당 이벤트를 실행하는 주체를 분리(decoupling)하는 구조이며, 이벤트 루프가 필수로 있어야 한다.<br><br>
    - Node.js의 이벤트 루프는 libuv에 있으며, 각 운영체제의 계층(IOCP, kqueue, epoll, 이벤트 포트)을 추상화한 기능을 제공한다.
        - libuv 소스 파일의 uv_run() 함수를 살펴보면, while문을 사용해 반복 실행하는 것을 확인할 수 있을 것이다.<br><br>
    - Node.js 이벤트 루프의 흐름
        - 이벤트 루프는 여러 개의 FIFO 큐로 이루어져 있다.
            - 각 단계를 돌면서 각 큐에 쌓인 이벤트를 모두 처리한다.
        - 이벤트 루프의 시작 및 각 반복의 마지막에 루프가 활성화 상태인지 체크한다.
        - 타이머 단계에서는 타이머 큐를 처리하며, setTimeout()과 setInerval()을 여기서 처리한다.
        - 펜딩 I/O 콜백 단계에서는 다음 반복으로 연기된 콜백을 처리한다.
        - 유휴, 준비 단계는 내부적으로만 사용된다.
        - 풀 단계에서는 새로운 연결(소켓 등)을 맺고, 파일 읽기 등의 작업을 한다.
            - 각 작업은 비동기 I/O를 사용하거나 스레드 풀을 사용한다.
        - 검사 단계에서는 setImmediate()를 처리한다.
        - 종료 콜백 단계에서는 콜백의 종료 처리(파일 디스크립터 닫기 등)를 한다.
        - nextTickQueue & microTaskQueue
            - 조금 특별한 장치로, 각 단계의 단계마다 nextTickQueue와 microTaskQueue에 있는 작업을 먼저 실행한다.
            - 즉, 타이머 단계가 끝나면 nextTickQueue와 microTaskQueue를 실행한다.
            - 또한, 펜딩 I/O 콜백 단계가 끝나면 그 사이에 쌓인 nextTickQueue와 microTaskQueue를 실행한다.
            - Node.js의 process.nextTick() 함수로 nextTickQueue에 작업을 추가할 수 있다.
            - microTaskQueue에는 Promise로 만든 콜백 함수가 추가된다.
                - Promise : 비동기 함수를 동기 함수처럼 사용하는 객체이다.
            - nextTickQueue가 microTaskQueue보다 우선순위가 높으므로, process.nextTick()으로 작성된 코드가 Promise로 작성된 코드보다 먼저 실행된다.

## 4. Node.js는 과연 쓸 만한가?
1. Node.js를 사용하는 이유
    - 자바스크립트로 고성는 서버를 손쉽게 개발할 수 있다.
        - 따라서, 프론트엔드 개발자가 백엔드 개발에 입문하고 싶을 때, 자바스크립트를 사용하면 새로운 언어를 배우지 않고 서버를 개발할 수 있다.
    - 페이팔, 넷플릭스, 우버, 링크드인, 나사, 네이버 뿐만 아니라 많은 회사가 Node.js를 실제 상용 서비스에 사용한다.
    - CPU 사용량이 많은 작업을 하는 서버가 아니라면, 굉장히 적은 메모리로 아주 좋은 성능을 낼 수 있다.
    - 마이크로서비스와 클라우드 환경에도 적합하다.
        - 메모리를 적게 사용하며 CPU 성능에 크게 좌우되지 않아서 비용을 절약할 수 있기 때문이다.
    - 랭킹이나 매칭 등 CPU를 많이 사용해야 하는 서비스에는 적합하지 않다.<br><br>
2. Node.js 장단점
    - 장점
        - 비동기 이벤트 기반 IO를 사용해 동시에 여러 요청을 다루기가 용이하다.
        - 자바스크립트를 사용해 프론트엔드 개발자의 백엔드 진입이 용이하다.
        - 클라이언트와 같은 언어를 사용하면 서버의 코드에 사용된 로직을 클라이언트에서도 사용할 수 있다.
        - 개발자 생태계가 잘 구성되어 있어 패키지 매니저에서 필요한 대부분을 제공한다.
        - V8 엔진이 JIT 컴파일러이므로 서버 기동이 빠르다.
    - 단점
        - 기본적으로 CPU를 하나만 사용하므로 멀티코어를 사용하려면 별도의 작업이 필요하다.
        - 비동기를 지원하지 않는 IO 요청이나 CPU 작업은 주의해서 작업해야 한다.
        - 콜백을 중첮ㅂ해서 계속 사용하면 코드 작성 및 디버깅이 힘들어진다.
        - 이벤트 기반으로 프로그래밍을 해본 적이 없다면, 코드 작성이 타 언어에 비해 상대적으로 어려울 수 있다.

## 5. hello Node.js를 출력하는 프로그램 실습
1. hello Node.js를 출력하는 프로그램 소스 코드
    ```js
    const http = require("http"); // http 객체 생성

    let count = 0;

    const server = http.createServer((req, res) => { // 서버 객체 생성
        log(count);                                  // 카운트 1 증가
        res.statusCode = 200;                        // 결괏값 200
        res.setHeader("Content-Type", "text/plain"); // 헤더 설정
        res.write("Hello\n");                        // 응답값 설정
        setTimeout(() => {
            res.end("Node.js"); // 2초 후 Node.js 출력
        }, 2000);
    });

    function log(count) {
        console.log((count += 1));
    }

    server.listen(8000);                            // 8000번 포트로 서버 실행
    ```
    - const http = require("http");
        - require() 함수
            - 모듈을 읽어오는 함수로, http 모듈을 불러와서 http 변수에 할당한다.
            - 모듈명과 변수명을 다르게 해도 문제는 없지만, 특별한 경우가 아니라면 위와 같이 이름 짓는 것이 관행이다.<br><br>
    - const server = http.createServer(callback);
        - createServer() 함수
            - 서버 인스턴스를 만드는 함수이다.
            - 인수로는 콜백 함수를 받는데, 콜백 함수에서는 http 서버로 요청이 들어오면 해당 요청을 처리할 함수를 설정한다.
            - 콜백 함수는 요청 처리에 사용할 요청(req)과 응답(res) 객체를 인수로 받는다.<br><br>
    - log(count);
        - 콜백 변수 count를 사용해 요청에 대한 로그를 남긴다.<br><br>
    - res.statusCode = 200;
        - 요청에 대한 상태 코드를 200으로 설정한다.
        - http 프로토콜에서 200은 성공이라는 의미이다.
        - 주요 상태 코드
            - 200(OK) : 요청 처리 성공
            - 301(Moved Permanently) : 요구한 데이터를 변경된 URL에서 찾음
            - 304(Not modified) : 클라이언트의 캐시에 저장되어 있음
            - 400(Bad Request) : 요청 실패. 클라이언트의 요청에 문제가 있음
            - 403(Forbidden) : 접근 금지
            - 404(Not Found) : 페이지를 찾을 수 없음
            - 405(Method not allowed) : 요청한 메서드가 허용되어 있지 않음
            - 408(Request timeout) : 요청 시간이 지남
            - 500(Internal Server Error) : 서버 에러
            - 501(Not Implemented) : 필요한 기능이 서버에 구현되어 있지 않음
            - 502(Bad gateway) : 케이트웨이 상태가 좋지 않음
            - 503(Service Unavailable) : 서버가 사용 불가 상태임<br><br>
    - res.setHeader("Content-Type", "text/plain");
        - HTTP는 요청/응답에 대한 부가 정보를 설정할 수 있다.
        - 부가 정보는 header에 설정하게 되는데, 여기서는 콘텐츠 타입을 'text/plain'(텍스트를 평문으로 해석하겠다라는 의미)으로 설정되어 있다.
            - 콘텐츠 타입 : 해당 콘텐츠가 어떤 형태의 데이터인지를 나타내며, 자주 설정하는 해더 정보는 text, html, Accept, Accept_Charset, User-Agent, Referer 등이 있다.<br><br>
    - res.write("Hello\n");
        - 응답으로 "Hello\n"을 보내준다.<br><br>
    - setTimeout(() => {res.end("Node.js");}, 2000);
        - setTimeout()은 콜백 함수와 숫자를 인수로 받는다.
        - 숫자는 밀리초이며 해당 시간이 지나면 콜백 함수를 실행하며, 여기서는 2초 후 "Node.js"를 응답으로 주고, http 연결을 끝내는 동작을 한다.<br><br>
    - server.listen(8000);
        - 사용할 포트 번호를 8000번으로 지정한다.
        - IP가 생략되었으므로 기본값이 localhost 혹은 127.0.0.1로 서버에 접근할 수 있다.

## 6. curl을 이용한 HTTP 프로토콜의 다양한 방식의 요청(GET, POST, DELETE, PUT 등) 테스트
1. 터미널에서 curl 명령을 테스트
    - 명령어 : curl localhost:8000
    - 결과 : hello가 먼저 출력되고, 2초 후에 Node.js가 출력되는 것을 확인할 수 있다.

## 7. 정말로 동시에 요청을 처리하는지 성능 테스트
1. 개발 서버 VS 프로덕션 서버
    - 개발 서버와 프로덕션 서버의 가장 큰 차이는 트랙픽이다.
    - 로직을 잘 작성했는지 개발하며 확인해야 한다.
    - 성능이 어느 정도 나오는지는 성능 테스트를 해야 서버의 허용치를 가늠할 수 있다.
        - 원하는 성능을 제공하는 일은 필수이기 때문이다.
    - 아무리 로직을 잘 작성해도 프로덕션 서버에서 성능이 나와주지 않아 장애가 발생한다면, 사용자 입장에서는 기능 오류나 다름이 없다.
        - 그래서, 현업에서는 새로 만든 API 중 성능에 문제가 있을 것 같은 API들을 개별로 또는 섞어가면서 실제 유저의 트래픽이 들어오는 것처럼 테스트한다.
        - 서비스 규모가 커질수록 성능 테스트의 이점은 커진다.
    - 여기서 성능을 테스트하는 도구로는 자바스크립트 문법으로 성능 테스트가 가능한 Go 언어로 만들어진 K6를 사용할 것이다.
        - 성능 테스트 스크립트는 자바스클비트(ES6)로 작성할 수 있다.

## 8. K6로 성능 테스트 스크립트 작성
1. 스크립트 소스 코드
    ```js
    import http from "k6/http";

    export const options = {               // 테스트 옵션
        vus: 100,
        duration: "10s",
    };

    export default function () {
        http.get("http://localhost:8000"); // 테스트에 사용할 함수 지정
    }
    ```
    - export const options = {vus: 100, duration: "10s",};
        - 성능 테스트 옵션값이다.
        - vus : 가상 유저를 설정하는 옵션이다.
        - duration : 몇 초 동안 테스트를 진행할지 선택하는 옵션이다.
        - 즉, 유저 100명이 10초 동안 계속 요청을 보내는 설정이다.<br><br>
    - export default function () {http.get("http://localhost:8000");}
        - 성능 테스트 시 실행되는 함수이다.
        - http 프로토콜의 GET 메서드를 사용해서 http://localhost:8000에 요청을 보낸다는 의미이다.
        - 즉, 유저 100명이 10초 동안 http://localhost:8000에 동시에 계속해서 요청을 보낸다는 의미이다.<br><br>
    - hello.js에서는 요청 하나당 2초 딜레이가 있으므로, 요청 하나가 완료되는 데 2초가 걸린다.
    - 스레드가 하나이므로 동기식 코드라면, 200초가 걸려야 할 것이니만, setTimeout은 이벤트 루프를 통해 비동기로 처리되기 때문에 2초 동안 요청 100개를 동시에 처리할 수 있다.<br><br>
2. 테스트 스크립트 실행
    - 테스트 스크립트 실행 명령어 : node hello.js → k6 run test_hello.js
    - 테스트 스크립트 실행 결과
        ```
                /\      |‾‾| /‾‾/   /‾‾/   
           /\  /  \     |  |/  /   /  /    
          /  \/    \    |     (   /   ‾‾\  
         /          \   |  |\  \ |  (‾)  | 
        / __________ \  |__| \__\ \_____/ .io

        execution: local
            script: test_hello.js
            output: -

        scenarios: (100.00%) 1 scenario, 100 max VUs, 40s max duration (incl. graceful stop):
                * default: 100 looping VUs for 10s (gracefulStop: 30s)


            data_received..................: 93 kB 9.2 kB/s
            data_sent......................: 40 kB 4.0 kB/s
            http_req_blocked...............: avg=493.63µs min=0s    med=1µs    max=3.69ms  p(90)=2.31ms p(95)=3.05ms
            http_req_connecting............: avg=399.29µs min=0s    med=0s     max=2.54ms  p(90)=2.13ms p(95)=2.22ms
            http_req_duration..............: avg=2s       min=1.99s med=2s     max=2.01s   p(90)=2.01s  p(95)=2.01s 
              { expected_response:true }...: avg=2s       min=1.99s med=2s     max=2.01s   p(90)=2.01s  p(95)=2.01s 
            http_req_failed................: 0.00% ✓ 0         ✗ 500  
            http_req_receiving.............: avg=2s       min=1.99s med=2s     max=2s      p(90)=2s     p(95)=2s    
            http_req_sending...............: avg=16.79µs  min=2µs   med=6µs    max=290µs   p(90)=26.1µs p(95)=64µs  
            http_req_tls_handshaking.......: avg=0s       min=0s    med=0s     max=0s      p(90)=0s     p(95)=0s    
            http_req_waiting...............: avg=2.91ms   min=130µs med=1.74ms max=10.21ms p(90)=7.73ms p(95)=8.76ms
            http_reqs......................: 500   49.838796/s
            iteration_duration.............: avg=2s       min=1.99s med=2s     max=2.01s   p(90)=2.01s  p(95)=2.01s 
            iterations.....................: 500   49.838796/s
            vus............................: 100   min=100     max=100
            vus_max........................: 100   min=100     max=100


        running (10.0s), 000/100 VUs, 500 complete and 0 interrupted iterations
        default ✓ [======================================] 100 VUs  10s
        ```
        - http 요청 기간 대한 결과로 2초가 걸리는 것을 확인할 수 있다.
        - 가상 유저 100으로 최대 40초 동안 테스트하는 시나리오로 나온다.
        - 실제 테스트 시간은 10초인데 gracefulStop의 기본값 30초를 더해 40초가 되었다.
        - gracefulStop 옵션은 가상 유저를 테스트 중에 변경하는 시나리오에서 갑자기 유저를 변경하면, 데이터가 급변하는 현상이 생기게 되므로 최소 30초 동안은 기존 유저값이 유지된다는 의미이다.