# 06 프로토타입

## 1. 프로토타입의 개념 이해
1. constructor, prototype, instance
    - 프로토타입 도식(1)<br>
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMkHiI%2Fbtrnc3hzF6i%2FYkod77eK3CyTyxPUKmgc71%2Fimg.png" height="190"></img>
        ```javascript
        var instance = new Constructor();
        ```
        - 프로토타입 도식(1) 그림은 위 코드를 추상화한 것
    - 프로토타입 도식(2)<br>
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FczIpnD%2FbtrniRzVjVd%2FJhdtsNUDnkfz2jrzKYGfO0%2Fimg.png" height="200"></img>
        - 윗변(실선)의 왼쪽 꼭짓점 : Constructor(생성자 함수)
        - 오른쪽 꼭짓점 : Constructor.prototype 프로퍼티
        - 왼쪽 꼭짓점 → 아래를 향한 화살표 : 중간에 new가 있고, 화살표 종점에는 instance가 존재
        - 오른쪽 꼭짓점 → 대각선 아래로 향하는 화살표 종점 : instance.__proto__ 프로퍼티
    - 프로토타입 도식(1)과 (2)를 통한 흐름
        - 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출
        - Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance) 생성
        - instance에는 __proto__라는 프로퍼티가 자동으로 부여
        - __proto__ 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조
    - prototype과 __proto__(던더 프로토, dunder proto) 프로퍼티의 관계
        - prototype과 이를 참조하는 __proto__는 객체
        - prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장
        - 인스턴스에서도 숨겨진 프로퍼티인 __proto__를 통해 이 메서드들에 접근 가능
    - 실무에서의 __proto__ 사용 방법
        - getPrototypeOf() / Object.create()
    - Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 지정한 예시
        ```javascript
        var Person = function(name) {
        this._name = name;
        };
        Person.prototype.getName = function() {
        return this._name;
        };

        var suzi = new Person('Suzi');
        suzi.__proto__getName();            // undefined

        Person.prototype === suzi.__proto__ // true
        ```
        - Person의 인스턴스는 __proto__ 프로퍼티를 통해 getName 호출 가능
            - instance의 __proto__가 Construoctor의 prototype 프로퍼티를 참조하므로 같은 객체를 바라보기 때문임
        - 메서드 호출 결과로 undefined 출력된 이유
            - 'Suzi'라는 값이 나오지 않고 에러도 발생하지 않음
                - 어떤 변수를 실행해 undefined가 나왔다는 것은 이 변수가 '호출할 수 있는 함수'에 해당
                - getName이 실행됐음을 알 수 있고, getName이 함수라는 것이 입증됨
            - 어떤 함수를 '메서드로서' 호출할 때는 메서드명 바로 앞의 객체가 곧 this
                - thomas.__proto__.getName()에서 getName 함수 내부에서는 this는 thomas가 아닌 thomas.__proto__라는 객체
                - 이 객체 내부에는 name 프로퍼티가 없으므로 찾고자 하는 식별자가 정의돼 있지 않을 때는 Error 대신 undefined를 반환
    - __proto__ 객체에 name 프로퍼티가 있을 경우
        ```javascript
        var suzi = new Person('Suzi');
        suzi.__proto__._name = 'SUZI__proto__';
        suzi.__proto__.getName(); // SUZI__proto__
        ```
        - SUZI__proto__가 잘 출력
    - this를 인스턴스로 할 수 있는 방법 : __proto__ 없이 인스턴스에서 곧바로 메서드를 사용
        ```javascript
        var suzi = new Person('Suzi', 28);
        suzi.getName();
        var iu = new Person('Jieun', 28);
        iu.getName();
        ```
        - __proto__는 '생략 가능한 프로퍼티'이므로, __proto__를 빼면 this는 instance가 됨
    - 프로토타입 도식(3)<br>
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHcnBN%2FbtrnevdjV9R%2FKo3WUKD6EwSftEkSfZWVvk%2Fimg.png" height="190"></img>
        - 프로토타입 간단 설명
            - new 연산자로 Constructor를 호출하면 instance가 만들어지는데, 이 instance의 생략 가능한 프로퍼티인 __proto__는 Constructor의 prototype을 참조
        - 프로토타입 상세 설명
            - 자바스크립트는 함수에 자동으로 객체인 prototpye 프로퍼티를 생성
            - 해당 함수를 생성자 함수로서 사용할 경우(new 연산자와 함께 함수를 호출할 경우), 그로부터 생성된 인스턴스에는 숨겨진 프로퍼티인 __proto__가 자동으로 생성
            - 이 프로퍼티는 생성자 함수의 prototype 프로퍼티를 참조
            - __proto__ 프로퍼티는 생략 가능하도록 구현
            - 생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근 가능<br><br>

2. constructor 프로퍼티
    - constructor 프로퍼티란
        - 생성자 함수의 프로퍼티인 prototype와 인스턴스의 __proto__ 객체 내부에 존재
        - 원래의 생성자 함수(자기 자신)을 참조한다는 의미
    - constructor 프로퍼티 예시
        ```javascript
        var arr = [1, 2];
        Array.prototype.constructor === Array; // true
        arr.__proto__.constructor === Array;   // true
        arr.constructor === Array;             // true

        var arr2 = new arr.constructor(3, 4);
        console.log(arr2);                     // [3, 4]
        ```
        - 인스턴스의 __proto__가 생성자 함수의 prototype 프로퍼티를 참조하며,__proto__가 생략 가능하여 인스턴스에서 직접 constructor에 접근할 수 있는 수단이 생김
    - constructor 변경
        ```javascript
        var NewConstructor = function() {
        console.log('this is new constuctor!');
        };
        var dataTypes = [
        1, // Number & false
        'test', // String & false
        true, // Boolean & false
        {}, // NewConstructor & false
        [], // NewConstructor & false
        function() {}, // NewConstructor & false
        /test/, // NewConstructor & false
        new Number(), // NewConstructor & false
        new String(), // NewConstructor & false
        new Boolean(), // NewConstructor & false
        new Object(), // NewConstructor & false
        new Array(), // NewConstructor & false
        new Function(), // NewConstructor & false
        new RegExp(), // NewConstructor & false
        new Date(), // NewConstructor & false
        new Error(), // NewConstructor & false
        ];

        dataTypes.forEach(function(d) {
        d.constructor = NewConstructor;
        console.log(d.constructor.name, '&', d instanceof NewConstructor);
        });
        ```
        - constructor는 읽기 전용 속성이 부여된 예외적인 경우(기본형 리터럴 변수 : number, string, boolean)를 제외하고 값 변경 가능
        - 모든 데이터가 d instanceof NewConstructor 명령에 대해 false를 반환
            - constructor를 변경하더라도 참조하는 대상이 변경될 뿐 이미 만들어진 인스턴스의 원형이 바뀐다거나 데이터 타입이 변하는 것이 아님을 알 수 있음
    - 다양한 constructor 접근 방법
        ```javascript
        var Person = function(name) {
        this.name = name;
        };
        var p1 = new Person('사람1'); // Person { name: "사람1" } true
        var p1Proto = Object.getPrototypeOf(p1);
        var p2 = new Person.prototype.constructor('사람2'); // Person { name: "사람2" } true
        var p3 = new p1Proto.constructor('사람3'); // Person { name: "사람3" } true
        var p4 = new p1.__proto__.constructor('사람4'); // Person { name: "사람4" } true
        var p5 = new p1.constructor('사람5'); // Person { name: "사람5" } true

        [p1, p2, p3, p4, p5].forEach(function(p) {
        console.log(p, p instanceof Person);
        });
        ```
        - p1 ~ p5까지 모두 Person의 인스턴스이며 아래 두 공식이 성립
            - 첫째, 다음 각 줄은 모두 동일한 대상을 가리킴
                - [Constructor]
                - [instance].__proto__.constructor
                - [instance].constructor
                - Object.getPrototypeOf([instance]).constructor
                - [Constructor].prototype.constructor
            - 둘째, 다음 각 줄은 모두 동일한 객체(prototype)dp 접근 가능
                - [Constructor].prototype
                - [instance].__proto__
                - [instance]
                - Object.getPrototypeOf([instance])<br><br>

## 2. 프로토타입 체인
1. 메서드 오버라이드
    - 