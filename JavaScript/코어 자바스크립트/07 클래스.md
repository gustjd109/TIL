# 07 클래스

## 1. 클래스와 인스턴스의 개념 이해
1. 클래스란?
    - 클래스 = 집단
    - 상위 클래스(superclass)와 하위 클래스(subclass)로 구분
    - 하위로 갈수록 상위 클래스의 속성을 상속하면서 더 구체적인 요건이 추가 또는 변경<br><br>

2. 인스턴스란?
    - 어떤 클래스의 속성을 지니는 실존하는 개체
        - 예를 들어, 감귤/자몽/천혜향 등은 음식에 속해 먹을 수 있음 → 과일에 속해 나무에서 열림 → 귤류에 속해 말랑한 껍질 속에 달고 신맛이 나는 과육이 들어있는 구체적인 개체들
    - 어떤 클래스에 속한 개체는 그 클래스의 조건을 모두 만족하므로 그 클래스의 구체적인 예시인 인스턴스가 될 것<br><br>

3. 프로그래밍 언어에서의 클래스와 인스턴스의 관계
    - 인스턴스
        - 사용자가 직접 여러 가지 클래스를 정의하고, 클래스를 바탕으로 인스턴스를 만들 때 어떤 개체가 클래스의 속성을 지님
        - 한 인스턴스는 하나의 클래스만을 바탕으로 생성
        - 어떤 인스턴스가 다양한 클래스에 속할 수 있지만, 이 클래스들은 모두 인스턴스 입장에서 '직계존속'
        - 다중상속을 지원하거나 그렇지 않은 언어이든 결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐
    - 클래스
        - 공통 요소를 지니는 집단 분류를 위한 개념이지만, 클래스가 먼저 정의돼야 그로부터 공통적인 요소를 지니는 개체를 생성할 수 있음
        - 사용하기에 따라 추상적인 대상일 수도 구체적인 개체가 될 수도 있음
            - 추상적인 대상이 되는 경우 : 구체적인 인스턴스가 사용할 메서드를 정의한 '틀'의 역할을 담당하는 목적을 가질 경우
            - 구체적인 개체가 되는 경우 : 클래스 자체를 this로 해서 직접 접근해야만 하는 스태틱 메서드를 호출할 경우<br><br>

## 2. 자바스크립트의 클래스
1. 클래스 관점에서 프로토타입에 접근
    - 생성자 함수 Array를 new 연산자와 함께 호출하면 인스턴스가 생성
    - Array를 일종의 클래스라고 하면, Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'
        - 엄밀히는 상속이 아닌 프로토타입 체이닝에 의한 참조
        - Array 내부 프로퍼티들 중 prototype 프로퍼티를 제외한 나머지는 인스턴스에 상속되지 않음<br><br>

2. 스태틱 멤버와 프로토타입 멤버
    - 인스턴스에 상속되는지(인스턴스가 참조되는지) 여부에 따라 분류
        - 다른 언어의 클래스 구성 요소에 대한 정의를 차용한 것으로서 클래스 입장에서 사용 대상에 따라 구분한 것<br><br>

3. 스태틱 메서드와 프로토타입 메서드
    ```javascript
    var Rectangle = function(width, height) {
    this.width = width;
    this.height = height;
    };
    Rectangle.prototype.getArea = function() {
    return this.width * this.height;
    };
    Rectangle.isRectangle = function(instance) {
    return (
        instance instanceof Rectangle && instance.width > 0 && instance.height > 0
    );
    };

    var rect1 = new Rectangle(3, 4);
    console.log(rect1.getArea()); // 12 (O)
    console.log(rect1.isRectangle(rect1)); // Error (X)
    console.log(Rectangle.isRectangle(rect1)); // true
    ```
    - Rectangle 함수를 new 연산자와 함께 호출해서 생성된 인스턴스를 rect1에 할당
    - 생성된 인스턴스의 width, height 프로퍼티에 각각 3, 4의 값을 할당
    - 프로토타입 객체에 할당한 메서드는 인스턴스가 마치 자신의 것처럼 호출 가능
        - 13번째 줄에서 호출한 getArea는 실제로는 rect1.__proto__.getArea에 접근
        - __proto__를 생략했으므로 this가 rect1인 채로 실행
        - 결과적으로 rect1.width * rect1.height의 계산값이 반환
        - 이처럼 인스턴스에서 직접 호출할 수 있는 메서드가 프로토타입 메서드
    - 14번째 줄에서는 rect1 인스턴스에서 isRectangle이라는 메서드에 접근
        - rect1에 해당 메서드가 있는지 검색했는데 없고, rect1.__proto__에도 없으며, rec1.__proto__.__proto__(=Object.prototype)에도 없음
        - 결국 undefined를 실행하라는 명령이므로, 함수가 아니어서 실행할 수 없다는 의미의 'Uncaught TypeError : not a function' 에러 발생
        - 이렇게 인스턴스에서 직접 접근할 수 없는 메서드가 스태틱 메서드
            - 스태틱 메서드는 15번째 줄처럼 생성자 함수를 this로 해야만 호출 가능<br><br>

## 3. 클래스 상속
1. 기본 구현
    - ES5까지의 자바스크립트에는 클래스가 없음
    - ES6에서 클래스가 도입됐지만, 아래 예제처럼 완벽한 구현이 아닌 프로토타입을 기반으로 프로토타입 체이닝을 잘 연결한 것
        ```javascript
        var Grade = function() {
        var args = Array.prototype.slice.call(arguments);
        for (var i = 0; i < args.length; i++) {
            this[i] = args[i];
        }
        this.length = args.length;
        };
        Grade.prototype = [];
        var g = new Grade(100, 80);
        ```
        - 위 예제의 length 프로퍼티가 configurable(삭제 가능)하다는 점과 Grade.prototype에 빈 배열을 참조시켰다는 문제점
            - length 프로퍼티를 삭제한 경우
                ```javascript
                ...
                g.push(90);
                console.log(g); // Grade { 0: 100, 1: 80, 2: 90, length: 3 }

                delete g.length;
                g.push(70);
                console.log(g); // Grade { 0: 70, 1: 80, 2: 90, length: 1 }
                ```
                - 11번째 줄에서는 원하는 대로 결과가 출력
                - 12번째 줄에서 push한 값이 0번째 인덱스에 삽입 및 length 값이 1로 변경
                    - 내장객체인 배열 인스턴스의 length 프로퍼티는 configurable 속성이 false이므로 삭제가 불가능하지만, Grade 클래스의 인스턴스는 배열 메서드를 상속할 뿐만아니라 일반 객체의 성질을 그대로 지니므로 삭제가 가능하여 생긴 문제
                    - Grade.prototype이 빈 배열을 가리키고 있으므로, push 명령에 의해 자바스크립트 엔진이 g.length를 읽고자 할 때 g.length가 없어 프로토타입 체이닝을 통해 g.__proto__.length를 읽어와 push한 값인 70이 0번째 인덱스에 삽입 및 length 값이 1로 변경된 것
            - 요소가 있는 배열을 prototype에 매칭한 경우
                ```javascript
                Grade.prototype = ['a', 'b', 'c', 'd'];
                var g = new Grade(100, 80);

                g.push(90);
                console.log(g); // Grade { 0: 100, 1: 80, 2: 90, length: 3 }

                delete g.length;
                g.push(70);
                console.log(g); // Grade { 0: 100, 1: 80, 2: 90, ___ 4: 70, length: 5 }
                ```
                - 10, 11번째 줄은 문제 없이 동작하지만, 12번째 줄에서 g.length가 없어서 g.__proto__.length를 찾아 인덱스 4에 70 삽입 및 g.length에 값 5 부여
                - 위와 같이 클래스에 있는 값이 인스턴스의 동작에 영향을 줘 클래스의 추상성을 해치면 안 됨
                    - 인스턴스와의 관계에서는 구체적인 데이터를 지니지 않고 오직 인스턴스가 사용할 메서드만을 지니는 추상적인 '틀'로서만 적용하게끔 작성해야 됨
    - 사용자가 정의한 두 클래스 사이에서의 상속관계
        ```javascript
        var Rectangle = function(width, height) {
        this.width = width;
        this.height = height;
        };
        Rectangle.prototype.getArea = function() {
        return this.width * this.height;
        };
        var rect = new Rectangle(3, 4);
        console.log(rect.getArea()); // 12

        var Square = function(width) {
        this.width = width;
        };
        Square.prototype.getArea = function() {
        return this.width * this.width;
        };
        var sq = new Square(5);
        console.log(sq.getArea()); // 25
        ```
        - Rectangle과 Square 클래스의 공통 요소 : width 프로퍼티 / 내용한 다르지만 비슷한 getArea
        - Square에서 height 프로퍼티에 width 값을 부여하는 형태로 Square 클래스를 변형하면 getArea 사용 가능
            ```javascript
            ...
            var Square = function(width) {
            this.width = width;
            this.height = width;
            };
            Square.prototype.getArea = function() {
            return this.width * this.height;
            };
            ...
            ```
        - getArea라는 메서드는 동일한 동작을 하므로 상위 클래스에서만 정의하고, 하위 클래스에서는 해당 메서드를 상속하면서 height 대신 width를 삽입
            ```javascript
            var Square = function(width) {
            Rectangle.call(this, width, width);
            };
            Square.prototype = new Rectangle();
            ```
            - Square의 생성자 함수 내부에서 Rectangle의 생성자 함수를 함수로써 호출하며, 인자 height 자리에 width를 전달
            - 메서드 상속을 위해 Square의 프로토타입 객체에 Rectangle의 인스턴스를 부여
        - 아래 코드를 이용해 확인한 sq 구조에서의 문제점
            ```javascript
            console.dir(sq);
            ```
            - 첫 줄에서 Square의 인스턴스임을 표시하고 있고, width와 height에 모두 5가 잘 들어가 있음
            - __proto__는 Rectangle의 인스턴스임을 표시하고 있고, width와 height에 undefined가 할당됨
                - Square.prototype에 값이 존재하는 것이 문제
                    - 이후에 임의로 Square.prototype.width(또는 height)에 값을 부여하고 sq.width(또는 height)의 값 삭제 시 프로토타입 체이닝에 의해 엉뚱한 결과가 나올 것
            - constructor가 여전히 Rectangle을 바라보는 문제
                - sq.constructor로 접근하면 프로토타입 체이닝을 따라 Rectangle.prototype(sq.__proto__.__proto__)에서 찾으며, 이는 Rectangle을 가리키고 있기 때문임
                    ```javascript
                    var rect2 = new sq.constructor(2, 3);
                    console.log(rect2); // Rectangle { width: 2, height: 3 }
                    ```
                    - 이처럼 하위 클래소로 삼을 생성자 함수의 prototype에 상위 클래스의 인스턴스를 부여하는 것만으로도 기본적인 메서드 상속은 가능하지만 문제 발생 여지가 있음<br><br>

2. 클래스가 구체적인 데이터를 지니지 않게 하는 방법
    - 