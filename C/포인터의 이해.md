# 포인터의 이해

## 1. 포인터 변수
- 메모리의 주소 값을 저장하는 목적으로 선언되는 변수

## 2. 포인터 변수 선언
- 포인터 변수 선언 기본형태
    ```c
    type * ptr;
    ```
- 포인터 변수 선언에서 * 의 위치에 따른 차이는 없음
- *은 애스터리스크(Asterisk)이며, 포인터 변수임을 나타내는 기호로 포인터라고 읽음

## 3. 변수의 주소값을 반환하는 & 연산자
- & 연산자
    ```c
    int main(void)
    {
        int num = 5;
        int * pnum = &num;
        . . . .
    }
    ```
    - 변수의 주소값을 반환
    - & 연산자의 반환 값은 포인터 변수에 저장

## 4. 포인터가 가리키는 메모리를 참조하는 * 연산자
- 포인터 변수가 가리키는 주소에 든 값을 가져올 수도, 변경할 수도 있음
    ```c
    int main(void)
    {
        int num = 10;
        int * pnum = &num; // pnum이 num을 가리킴
        *pnum = 20; // pnum이 가리키는 공간(변수)에 20을 저장
        printf("%d\n", *pnum); // pnum이 가리키는 공간(변수)에 저장된 값 출력
    }
    ```

## 5. 널(NULL) 포인터
- 널 포인터 NULL은 숫자 0을 의미
    - 0은 0번지를 뜻하는 것이 아니라, 아무것도 가리키지 않는다는 의미로 해석
- 잘못된 포인터 연산을 막기 위해서 특정한 값으로 초기화하지 않는 경우에는 널 포인터로 초기화하는 것이 안전

## 6. 포인터와 배열의 관계
- 아래 예제에서 보이듯이 배열의 이름은 배열의 시작 주소 값을 의미하는(배열의 첫 번째 요소를 가리키는) 포인터이고, 단순히 주소 값이 아닌 포인터인 이유는 메모리 접근에 사용되는 * 연산이 가능하기 때문
    ```c
    int main(void)
    {
        int arr[3] = { 0, 1, 2};
        printf("배열의 이름 : %p\n", arr);
        printf("첫 번째 요소 : %p\n", &arr[0]);
        printf("두 번째 요소 : %p\n", &arr[1]);
        printf("세 번째 요소 : %p\n", &arr[2]);
        // arr = &arr[i]; // 배열의 이름은 변수가 아닌 상수 형태의 포인 터이기에 대입연산이 불가능하다. 따라서, 이 문장은 컴파일 에러를 일으킨다.
        return 0;
    }

    실행결과 ->
    배열의 이름 : 0012FF50
    첫 번째 요소 : 0012FF50
    두 번째 요소 : 0012FF54
    세 번째 요소 : 0012FF58
    ```
- 배열 이름과 포인터 변수의 비교
    - 이름이 존재하는가?
        - 포인터와 배열 모두 존재
    - 무엇을 나타내거나 저장하는가?
        - 포인터와 배열 모두 메모리의 주소 값을 저장
    - 주소 값의 변경이 가능한가?
        - 포인터는 가능하지만, 배열은 불가능