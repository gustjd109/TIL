# 포인터의 이해

## 1. 포인터 변수
- 메모리의 주소 값을 저장하는 목적으로 선언되는 변수

## 2. 포인터 변수 선언
- 포인터 변수 선언 기본형태
    ```c
    type * ptr;
    ```
- 포인터 변수 선언에서 * 의 위치에 따른 차이는 없음
- *은 애스터리스크(Asterisk)이며, 포인터 변수임을 나타내는 기호로 포인터라고 읽음

## 3. 변수의 주소값을 반환하는 & 연산자
- & 연산자
    ```c
    int main(void)
    {
        int num = 5;
        int * pnum = &num;
        . . . .
    }
    ```
    - 변수의 주소값을 반환
    - & 연산자의 반환 값은 포인터 변수에 저장

## 4. 포인터가 가리키는 메모리를 참조하는 * 연산자
- 포인터 변수가 가리키는 주소에 든 값을 가져올 수도, 변경할 수도 있음
    ```c
    int main(void)
    {
        int num = 10;
        int * pnum = &num; // pnum이 num을 가리킴
        *pnum = 20; // pnum이 가리키는 공간(변수)에 20을 저장
        printf("%d\n", *pnum); // pnum이 가리키는 공간(변수)에 저장된 값 출력
    }
    ```

## 5. 널(NULL) 포인터
- 널 포인터 NULL은 숫자 0을 의미
    - 0은 0번지를 뜻하는 것이 아니라, 아무것도 가리키지 않는다는 의미로 해석
- 잘못된 포인터 연산을 막기 위해서 특정한 값으로 초기화하지 않는 경우에는 널 포인터로 초기화하는 것이 안전

## 6. 포인터와 배열의 관계
- 아래 예제에서 보이듯이 배열의 이름은 배열의 시작 주소 값을 의미하는(배열의 첫 번째 요소를 가리키는) 포인터이고, 단순히 주소 값이 아닌 포인터인 이유는 메모리 접근에 사용되는 * 연산이 가능하기 때문
    ```c
    int main(void)
    {
        int arr[3] = { 0, 1, 2};
        printf("배열의 이름 : %p\n", arr);
        printf("첫 번째 요소 : %p\n", &arr[0]);
        printf("두 번째 요소 : %p\n", &arr[1]);
        printf("세 번째 요소 : %p\n", &arr[2]);
        // arr = &arr[i]; // 배열의 이름은 변수가 아닌 상수 형태의 포인 터이기에 대입연산이 불가능하다. 따라서, 이 문장은 컴파일 에러를 일으킨다.
        return 0;
    }

    실행결과 ->
    배열의 이름 : 0012FF50
    첫 번째 요소 : 0012FF50
    두 번째 요소 : 0012FF54
    세 번째 요소 : 0012FF58
    ```
- 배열 이름과 포인터 변수의 비교
    - 이름이 존재하는가?
        - 포인터와 배열 모두 존재
    - 무엇을 나타내거나 저장하는가?
        - 포인터와 배열 모두 메모리의 주소 값을 저장
    - 주소 값의 변경이 가능한가?
        - 포인터는 가능하지만, 배열은 불가능

## 7. 1차원 배열에서의 포인터
- 1차원 배열 이름의 포인터 형 결정하는 방법
    - 배열의 이름이 가리키는 변수의 자료형을 근거로 판단
    - int형 변수를 가리키면 int * 형
    - double형 변수를 가리키면 double * 형
- 1차원 배열 포인터 예
    ```c
    int main(void)
    {
        int arr1[3] = {1, 2, 3}; // int arr1[3]; 에서 arr1은 int * 형
        double arr2[3] = {1.1, 2.2, 3.3}; // double arr2[3]; 에서 arr2는 double * 형

        printf("%d %g\n", *arr1, *arr2);

        *arr1 += 100; // 배열 이름을 대상으로 포인터 연산 수행
        *arr2 += 120.5;

        printf("%d %g\n", arr1[0], arr2[0]);

        return 0;

        실행결과 ->
        1 1.1
        101 121.6
    }
    ```
    - arr1이 int형 포인터이므로 * 연산의 결과로 4바이트 메모리 공간에 정수를 저장
    - arr2는 double형 포인터이므로 * 연산의 결과로 8바이트 메모리 공간에 실수를 저장

## 8. 포인터를 배열의 이름처럼 사용 가능
- 아래 예제에서 arr은 int형 포인터이니 int형 포인터를 대상으로 배열접근을 위한 [idx] 연산을 짂행한 셈
    ```c
    int main(void)
    {
        int arr[3] = {1, 2, 3};
        arr[0] += 5;
        arr[1] += 7;
        arr[2] == 9;
        . . . .
    }
    ```
- 아래 예제를 보면, 실제로 포인터 변수 ptr을 대상으로 ptr[0], ptr[1], ptr[2]와 같은 방식으로 메모리 공간에 접근이 가능
    ```c
    int main(void)
    {
        int arr[3] = {15, 25, 35};
        int * ptr = &arr[0]; // int * ptr = arr;과 동일
        printf("%d %d\n", ptr[0], arr[0]);
        printf("%d %d\n", ptr[1], arr[1]);
        printf("%d %d\n", ptr[2], arr[2]);
        printf("%d %d\n", *ptr, *arr);
        return 0;

        실행결과 ->
        15 15
        25 25
        35 35
        15 15
    }
    ```
    - 포인터 변수를 이용해서 배열의 형태로 메모리 공간에 접근하고 있음

## 9. 포인터를 대상으로 하는 증가 및 감소연산
- 포인터 변수에 저장된 값을 대상으로 하는 증가 및 감소연산 진행 가능(곱셈, 나눗셈 등은 불가능)
    ```c
    int main(void)
    {
        int * ptr1 = 0x0010;
        double * ptr2 = 0x0010;

        print("%p %p\n", ptr1 + 1, ptr1 + 2);
        print("%p %p\n", ptr2 + 1, ptr2 + 2);
        print("%p %p\n", ptr1, ptr2);
        ptr1++;
        ptr2++;
        printf("%p %p\n", ptr1, ptr2);
        return 0;

        실행결과 ->
        00000014 00000018
        00000018 00000020
        00000010 00000010
        00000014 00000018
    }
    ```
    - type형 포인터 변수 대상의 증가 감소 연산 시 sizeof(type)의 크기만큼 값이 증가 및 감소

## 10. 두 가지 형태의 문자열 표현
```c
char str[] = "My String";
char * str = "Your String";
```
- str1은 문자열이 저장된 배열
    - 즉, 문자 배열이고 변수성향의 문자열
    - 변수 성향의 str1에 저장된 문자열은 변경 가능
- str2는 문자열의 주소 값을 저장
    - 즉, 자동 할당된 문자열의 주소 값을 저장하고 상수성향의 문자열
    - 상수 성향의 str2에 저장된 문자열은 변경 불가능

## 11. 배열을 함수의 인자로 전달하는 방법
- 배열을 함수의 인자로 전달하려면 배열을 통째로 복사할 수 있도록 배열 이 매개변수로 선언되어야 함
- 그러나, C언어는 매개변수로 배열의 선언을 허용하지 않음
- 따라서 배열을 통째로 복사해서 전달하는 방식 대신에, 배열의 주소 값을 전달하는 방식을 이용해야 함
- 배열을 함수의 인자로 전달하는 예제
    ```c
    void ShowArrayElem(int * param, int len) // int param[]도 동일한 선언
    {
        for(int i = 0; i < len; i++)
            printf("%d ", param[i]);
            print("\n");
    }

    int main(void)
    {
        int arr1[3] = {1, 2, 3};
        int arr2[5] = {4, 5, 6, 7, 8};
        ShowArrayElem(arr1, sizeof(arr1) / sizeof(int));
        ShowArrayElem(arr2, sizeof(arr2) / sizeof(int));
        return 0;
    }

    실행결과 ->
    1 2 3
    4 5 6 7 8
    ```