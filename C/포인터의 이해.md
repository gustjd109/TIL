# 포인터의 이해

## 1. 포인터 변수
- 메모리의 주소 값을 저장하는 목적으로 선언되는 변수

## 2. 포인터 변수 선언
- 포인터 변수 선언 기본형태
    ```c
    type * ptr;
    ```
- 포인터 변수 선언 예제
    ```c
    #include <stdio.h>

    int main()
    {
	    int *p = NULL;  // int* p == int * p 모두 같음
	    int num = 15;

	    p = &num;

	    printf("포인터 p의 값 : %d \n", p);
	    printf("int 변수 num의 주소 : %d \n", &num);

	    return 0;
    }

    >>> 실행결과
    int 변수 num의 주소 : 2037013036 
    포인터 p의 값 : 2037013036 
    포인터 p가 가리키는 값 : 15
    ```
- 포인터 변수 선언에서 * 의 위치에 따른 차이는 없음
    - type *ptr
    - type* ptr
    - type * ptr
- *은 애스터리스크(Asterisk)이며, 포인터 변수임을 나타내는 기호로 포인터라고 읽음
- 포인터 변수의 주소값의 크기는 자료형에 따라 달리지는가?
    - 포인터 변수의 크기는 모두 동일
        - 동일한 운영체제 시스템일 경우 주소값이 동일한 크기를 갖기 때문임
        - 32비트 시스템이면 4바이트
        - 64비스 시스템이변 8바이트
    - 자료형에 따라 선언하는 자료형이 달리는 이유
        - 가리킬 주소가 어떤 자료형을 갖는지 알려주기 위함

## 3. 변수의 주소값을 반환하는 & 연산자
- & 연산자
    ```c
    int main(void)
    {
        int num = 5;
        int * pnum = &num;
        . . . .
    }
    ```
    - 변수의 주소값을 반환
    - & 연산자의 반환 값은 포인터 변수에 저장

## 4. 포인터가 가리키는 메모리를 참조하는 * 연산자
- * 연산자는 곱셉을 할 때 사용하기도 하지만, 포인터를 이용할 때 쓰기도 함
- & 연산자가 and 연산자와 주소 연산자로 쓰이듯이 마찬가지로 두개의 피연산자(a * b)가 있으면 곱셈 연산자이고, 하나의 피연산자만 있으면 참조 연산자임
- 참조 연산자는 포인터의 이름이나 조소 앞에 사용하며, 포인터가 가리키는 주소에 저장된 값을 반환
- 포인터 변수가 가리키는 주소에 든 값을 가져올 수도, 변경할 수도 있음
    ```c
    int main(void)
    {
        int num = 10;
        int * pnum = &num; // pnum이 num을 가리킴
        *pnum = 20; // pnum이 가리키는 공간(변수)에 20을 저장
        printf("%d\n", *pnum); // pnum이 가리키는 공간(변수)에 저장된 값 출력
    }

    >>> 실행결과
    20
    ```

## 5. 널(NULL) 포인터
- 널 포인터 NULL은 숫자 0을 의미
    - 0은 0번지를 뜻하는 것이 아니라, 아무것도 가리키지 않는다는 의미로 해석
- 잘못된 포인터 연산을 막기 위해서 특정한 값으로 초기화하지 않는 경우에는 널 포인터로 초기화하는 것이 안전
- 널 포인터 초기화의 예
    ```c
    int *p = NULL;
    ```
- 변수를 초기화하지 않았을 때의 초기값은 쓰레기값이 들어가 있음
    - 포인터 변수도 마찬가지이므로, NULL로 꼭 초기화 해주는 것이 좋음

## 6. 포인터와 배열의 관계
- 아래 예제에서 보이듯이 배열의 이름은 배열의 시작 주소 값을 의미하는(배열의 첫 번째 요소를 가리키는) 포인터이고, 단순히 주소 값이 아닌 포인터인 이유는 메모리 접근에 사용되는 * 연산이 가능하기 때문
    ```c
    int main(void)
    {
        int arr[3] = { 0, 1, 2};
        printf("배열의 이름 : %p\n", arr);
        printf("첫 번째 요소 : %p\n", &arr[0]);
        printf("두 번째 요소 : %p\n", &arr[1]);
        printf("세 번째 요소 : %p\n", &arr[2]);
        // arr = &arr[i]; // 배열의 이름은 변수가 아닌 상수 형태의 포인 터이기에 대입연산이 불가능하다. 따라서, 이 문장은 컴파일 에러를 일으킨다.
        return 0;
    }

    실행결과 ->
    배열의 이름 : 0012FF50
    첫 번째 요소 : 0012FF50
    두 번째 요소 : 0012FF54
    세 번째 요소 : 0012FF58
    ```
- 배열 이름과 포인터 변수의 비교
    - 이름이 존재하는가?
        - 포인터와 배열 모두 존재
    - 무엇을 나타내거나 저장하는가?
        - 포인터와 배열 모두 메모리의 주소 값을 저장
    - 주소 값의 변경이 가능한가?
        - 포인터는 가능하지만, 배열은 불가능

## 7. 1차원 배열에서의 포인터
- 1차원 배열 이름의 포인터 형 결정하는 방법
    - 배열의 이름이 가리키는 변수의 자료형을 근거로 판단
    - int형 변수를 가리키면 int * 형
    - double형 변수를 가리키면 double * 형
- 1차원 배열 포인터 예
    ```c
    int main(void)
    {
        int arr1[3] = {1, 2, 3}; // int arr1[3]; 에서 arr1은 int * 형
        double arr2[3] = {1.1, 2.2, 3.3}; // double arr2[3]; 에서 arr2는 double * 형

        printf("%d %g\n", *arr1, *arr2);

        *arr1 += 100; // 배열 이름을 대상으로 포인터 연산 수행
        *arr2 += 120.5;

        printf("%d %g\n", arr1[0], arr2[0]);

        return 0;

        실행결과 ->
        1 1.1
        101 121.6
    }
    ```
    - arr1이 int형 포인터이므로 * 연산의 결과로 4바이트 메모리 공간에 정수를 저장
    - arr2는 double형 포인터이므로 * 연산의 결과로 8바이트 메모리 공간에 실수를 저장

## 8. 포인터를 배열의 이름처럼 사용 가능
- 아래 예제에서 arr은 int형 포인터이니 int형 포인터를 대상으로 배열접근을 위한 [idx] 연산을 짂행한 셈
    ```c
    int main(void)
    {
        int arr[3] = {1, 2, 3};
        arr[0] += 5;
        arr[1] += 7;
        arr[2] == 9;
        . . . .
    }
    ```
- 아래 예제를 보면, 실제로 포인터 변수 ptr을 대상으로 ptr[0], ptr[1], ptr[2]와 같은 방식으로 메모리 공간에 접근이 가능
    ```c
    int main(void)
    {
        int arr[3] = {15, 25, 35};
        int * ptr = &arr[0]; // int * ptr = arr;과 동일
        printf("%d %d\n", ptr[0], arr[0]);
        printf("%d %d\n", ptr[1], arr[1]);
        printf("%d %d\n", ptr[2], arr[2]);
        printf("%d %d\n", *ptr, *arr);
        return 0;

        실행결과 ->
        15 15
        25 25
        35 35
        15 15
    }
    ```
    - 포인터 변수를 이용해서 배열의 형태로 메모리 공간에 접근하고 있음

## 9. 포인터를 대상으로 하는 증가 및 감소연산
- 포인터 변수에 저장된 값을 대상으로 하는 증가 및 감소연산 진행 가능(곱셈, 나눗셈 등은 불가능)
    ```c
    int main(void)
    {
        int * ptr1 = 0x0010;
        double * ptr2 = 0x0010;

        print("%p %p\n", ptr1 + 1, ptr1 + 2);
        print("%p %p\n", ptr2 + 1, ptr2 + 2);
        print("%p %p\n", ptr1, ptr2);
        ptr1++;
        ptr2++;
        printf("%p %p\n", ptr1, ptr2);
        return 0;

        실행결과 ->
        00000014 00000018
        00000018 00000020
        00000010 00000010
        00000014 00000018
    }
    ```
    - type형 포인터 변수 대상의 증가 감소 연산 시 sizeof(type)의 크기만큼 값이 증가 및 감소

## 10. 두 가지 형태의 문자열 표현
```c
char str[] = "My String";
char * str = "Your String";
```
- str1은 문자열이 저장된 배열
    - 즉, 문자 배열이고 변수성향의 문자열
    - 변수 성향의 str1에 저장된 문자열은 변경 가능
- str2는 문자열의 주소 값을 저장
    - 즉, 자동 할당된 문자열의 주소 값을 저장하고 상수성향의 문자열
    - 상수 성향의 str2에 저장된 문자열은 변경 불가능

## 11. 배열을 함수의 인자로 전달하는 방법
- 배열을 함수의 인자로 전달하려면 배열을 통째로 복사할 수 있도록 배열 이 매개변수로 선언되어야 함
- 그러나, C언어는 매개변수로 배열의 선언을 허용하지 않음
- 따라서 배열을 통째로 복사해서 전달하는 방식 대신에, 배열의 주소 값을 전달하는 방식을 이용해야 함
- 배열을 함수의 인자로 전달하는 예제
    ```c
    void ShowArrayElem(int * param, int len) // int param[]도 동일한 선언
    {
        for(int i = 0; i < len; i++)
            printf("%d ", param[i]);
            print("\n");
    }

    int main(void)
    {
        int arr1[3] = {1, 2, 3};
        int arr2[5] = {4, 5, 6, 7, 8};
        ShowArrayElem(arr1, sizeof(arr1) / sizeof(int));
        ShowArrayElem(arr2, sizeof(arr2) / sizeof(int));
        return 0;
    }

    실행결과 ->
    1 2 3
    4 5 6 7 8
    ```

## 12. 상수 포인터
- 상수 포인터
    - 일반 변수에는 값을 절대 바꿀 수 없는 상수가 있음
    - 포인터에도 마찬가지로, 주소값을 바꿀 수 없는 상수 포인터가 있음
    - const 붙여서 상수 포인터를 선언
- 상수 포인터 선언 예제
    ```c
    #include <stdio.h>

    int main()
    {
	    int num = 10;
	    int *ptr1 = &num;
	    const int *ptr2 = &num;

	    *ptr1 = 20;
	    num = 30;

	    *ptr2 = 40;

	    return 0;
    }
    ```
    - const로 선언하지 않은 ptr1은 *ptr1을 이요해 값 20을 대입 가능
    - 상수화된 ptr2는 값을 대입했을 때 오류 발생
        - ptr2를 이용해 변수의 값을 변경할 수 없기 때문임
    - 변수 num 자체가 상수가 된 것은 아니라서, num의 값을 변경하는 것은 가능

## 13. 2중 포인터
- 2중 포인터 변수
    - 포인터 변수의 주소 값을 저장하는 포인터 변수
- 2중 포인터 예제
    ```c
    int main(void)
    {
        double num = 3.14;
        double * ptr = &num;
        double ** dptr = &ptr;
    }
    - 위의 예제에서 *dptr은 포인터 변수 ptr을 의미하고, **dptr은 변수 num을 의미

## 14. 2중 포인터 배열
- 1차원 배열이름의 포인터 형은 배열 이름이 가리키는 대상을 기준으로 결정
    - int arr1[3]; 에서 arr1의 포인터 형은 int *
    - double arr2[3]; 에서 arr2의 포인터 형은 double *
- 따라서 int * arr1[20]; 에서 arr1의 포인터 형은 int **, double * arr2[30]; 에서 arr2의 포인터 형은 double **
- 2중 포인터 배열 예제
    ```c
    int main(void)
    {
        int num1 = 10, num2 = 20, num3 = 30;
        int * ptr1 = &num1;
        int * ptr2 = &num2;
        int * ptr3 = &num3;

        int * ptrArr[] = {ptr1, ptr2, ptr3};
        int ** dptr = ptrArr;

        printf("%d %d %d \n", *(ptrArr[0]), *(ptrArr[1]), *(ptrArr[2]));
        printf("%d %d %d \n", *(dptr[0]), *(dptr[1]), *(dptr[2]));

        return 0;
    }

    >>> 실행결과
    10 20 30
    10 20 30
    ```

## 15. 3중 포인터
- 3중 포인터 변수
    - 2중 포인터 변수의 주소 값을 저장하는 포인터 변수
- 3중 포인터 예제
    ```c
    int main(void)
    {
        int num = 100;
        int * ptr = &num;
        int ** dptr = &ptr;
        int *** tprt = &dptr;

        print("%d %d \n", **dptr, ***tptr);

        return 0;
    }

    >>> 실행결과
    100 100
    ```

## 16. 배열 포인터
- 예를 들어, int arr[10];, int * parr[20];과 int arr2d[3][4];이 있다고 하자.
    - int arr[10];은 1차원 배열이므로 arr은 int형 포인터 (int *)
    - int * parr[20];은 1차원 배열이므로 parr은 int형 이중 포인터 (int **)
    - 하지만, int arr2d[3][4];은 int형 1차원 배열도, int 포인터 형 1차원 배열도 아니므로 arr2d는 int형 포인터 형도, int형 이중 포인터 형도 아님
    - 2차원 배열이름의 포인터 형을 결정짓는 방법은 별도로 존재
- 2차원 배열 이름이 가리키는 것
    - 2차원 배열이름의 포인터 형을 결정지으려면 우선 2차원 배열이름이 가리키는 대상이 무엇인지 알 아야함
    - 그런데 1차원 배열과 달리 이것만으로 포인터 형이 결정되지 않음
    - int arr2d[3][3];에서 배열이름 arr2d가 가리키는 것은 인덱스 기준으로 [0][0]에 위치한 첫 번째 요소
    - 2차원 배열의 경우 arr2d[0], arr2d[1], arr2d[2]도 의미를 지님
    - 각각 1행, 2행, 3행의 첫 번째 요소를 가리키는 주소 값의 의미
- arr2d와 arr2d[0]은 같은가?
    ```c
    int main(void)
    {
        int arr2d[3][3];
        print("%d\n", arr2d);
        print("%d\n", arr2d[0]);
        print("%d\n", arr2d[0][0]);

        print("%d\n", arr2d[1]);
        print("%d\n", arr2d[1][0]);

        print("%d\n", arr2d[2]);
        print("%d\n", arr2d[2][0]);

        print("sizeof(arr2d) : %d\n", sizeof(arr2d));
        print("sizeof(arr2d[0]) : %d\n", sizeof(arr2d[0]));
        print("sizeof(arr2d[1]) : %d\n", sizeof(arr2d[1]));
        print("sizeof(arr2d[2]) : %d\n", sizeof(arr2d[2]));

        return 0;
    }

    >>> 실행결과
    4585464
    4585464
    4585464
    
    4585476
    4585476

    4585488
    4585488

    sizeof(arr2d) : 36
    sizeof(arr2d[0]) : 12
    sizeof(arr2d[1]) : 12
    sizeof(arr2d[2]) : 12
    ```
    - arr2d는 2차원 배열 전체를 의미하고, 반면 arr2d[0]는 2차원 배열 의 첫 번째 행을 의미
    - 배열이름 arr2d를 대상으로 sizeof 연산을 하는 경우 배열 전체의 크기를 반환
    - arr2d[0], arr2d[1], arr2d[2]를 대상으로 sizeof 연산을 하는 경우 각 행의 크기를 반환
- 배열 이름 기반의 포인터 연산
    - int iarr[3];과 double darr[7];이 있다고 하자.
        - iarr은 int형 포인터이기 때문에 +1의 결과로 sizeof(int)의 크기만큼 값이 증가
        - darr은 double형 포인터이기 때문에 +1의 결과로 sizeof(double)의 크기만큼 값이 증가
    - 위와 같이 포인터 연산의 결과는 포인터 형에 의존적
    - 따라서 2차원 배열이름의 포인터 형을 결정짓기 위한 힌트는 포인터 연산의 결과를 주목하면 얻을 수 있음
- 2차원 배열의 포인터 연산 결과
    ```c
    int main(void)
    {
        int arr1[3][2];
        int arr2[2][3];

        printf("arr1 : %p\n", arr1);
        printf("arr1 + 1 : %p\n", arr1 + 1);
        printf("arr1 + 2 : %p\n", arr1 + 2);

        printf("arr2 : %p\n", arr2);
        printf("arr2 + 1 : %p\n", arr2 + 1);

        return 0;
    }

    >>> 실행결과
    arr1 : 004BFBE0
    arr1 + 1 : 004BFBE8
    arr1 + 2 : 004BFBF0
    arr2 : 004BFBC0
    arr2 + 1 : 004BFBCC
    ```
    - arr1과 arr2는 둘 다 int형 2차원 배열
    - 그러나 가로의 길이가 다르기 때문에 포인터 연산결과로 증가 및 감소하는 값의 크기에는 차이가 있음
    - 즉, arr1과 arr2 는 의 포인터 형은 일치하지 않음
    - 이렇듯 2차원 배열이름의 포인터 형도 배열의 가로길이에 따라서도 나뉨
    - 이러한 특징 때문에 2차원 배열이름의 포인터 형 결정이 쉽지 않은 것
- 2차원 배열의 포인터 형
    - int arr[3][4]의 포인터 형은?
        - 가리키는 대상 : int형 변수
        - 포인터 연산의 결과 : sizeof(int) * 4의 크기단위로 값이 증가 및 감소
    - 위의 유형의 포인터 변수 ptr의 선언
        - int (*ptr)[4];
            - (*ptr) : ptr은 포인터
            - int : int형 변수를 가리키는 포인터
            - [4] : 포인터 연산 시 4칸씩 건너뛰는 포인터
        - 2차원 배열을 가리키는 포인터 변수 이므로 배열 포인터 변수라고 함
- 2차원 배열 포이터 형 연습
    - char (*arr1)[4];
        - arr1은 char형 변수를 가리키면서, 포인터 연산 시 sizeof(char) * 4의 크기 단위로 값이 증가 및 감소하는 포인터 변수
    - double (*arr2)[7];
        - arr2는 double형 변수를 가리키면소, 포인터 연산 시 sizeof(double) * 7의 크기 단위로 값이 증가 및 감소하는 포인터 변수
- "배열 포인터"와 "포인터 배열"의 혼동
    - 포인터 배열
        - 포인터 변수로 이루어진 배열
        - int * arr[4];
    - 배열 포인터
        - 배열을 가리킬 수 있는 포인터 변수
        - int (*arr)[4];
- 2차원 배열을 함수의 인자로 전달하는 방법
    ```c
    int main(void)
    {
        int arr1[2][7];
        double arr2[4][5];
        func(arr1, arr2);
    }

    void func(int (*parr1)[7], double (*parr2)[5]) // void func(int parr1[][7], double parr2[][5])도 동일한 선언으로 간주
    {
        . . . .
    }
    ```

## 17. 함수 포인터
- 함수 포인터
    - 함수의 이름은 함수가 저장된 메모리 공간을 가리키는 포인터
    - 함수의 이름이 의미하는 주소 값은 함수 포인터 변수를 선언해서 저장 가능
    - 함수 포인터 변수를 선언하려면 함수 포인터의 형(type)을 알아야 함
- 함수 포인터의 형
    - 함수 포인터의 형 정보에는 "반환형"과 "매개변수 선언"에 대한 정보를 담기로 약속
    - 즉, 함수의 반환형과 매개변수 선언이 동일한 두 함수의 함수 포인터 형은 일치
- 함수 포인터 형 결정
    - int simplefunc(int num)
        - 반환형 : int
        - 매개변수 : int형 1개
    - double complexfunc(double num1, double num2)
        - 반환형 : double
        - 매개변수 : double형 2개
- 함수 포인터 변수 선언
    - 함수 포인터 변수 기본 형태
        - type (*fptr) (type)
    - int func(int num1, int num2) { . . . . }의 함수 포인터 변수 선언
        - int (*fptr) (int, int)
        - fptr = func;
            - 상수의 값을 변수에 저장
        - fptr(3, 4);
            - func(3, 4)와 동일한 결과를 보여줌
            - 함수 포인터 변수에 저장된 값을 통해서도 함수호출 가능

## 18. void 포인터
- void 포인터
    - 어떠한 주소 값도 저장이 가능한 void형 포인터
    - 형 정보가 존재하지 않는 포인터 변수이기에 어떠헌 주소 값도 저장이 가능
    - 형 정보가 존재하지 않기 때문에 메모리 접근을 위한 포인터 연산은 불가능